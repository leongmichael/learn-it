animation
Animate mobjects.

Classes

Animation

An animation.

Wait

A "no operation" animation.

Functions

override_animation(animation_class)[source]
Decorator used to mark methods as overrides for specific Animation types.

Should only be used to decorate methods of classes derived from Mobject. Animation overrides get inherited to subclasses of the Mobject who defined them. They don’t override subclasses of the Animation they override.

See also

add_animation_override()

Parameters:
animation_class (type[Animation]) – The animation to be overridden.

Returns:
The actual decorator. This marks the method as overriding an animation.

Return type:
Callable[[Callable], Callable]

Examples

Example: OverrideAnimationExample 

from manim import *

class MySquare(Square):
    @override_animation(FadeIn)
    def _fade_in_override(self, **kwargs):
        return Create(self, **kwargs)

class OverrideAnimationExample(Scene):
    def construct(self):
        self.play(FadeIn(MySquare()))
Make interactive
prepare_animation(anim)[source]
Returns either an unchanged animation, or the animation built from a passed animation factory.

Examples

from manim import Square, FadeIn
s = Square()
prepare_animation(FadeIn(s))
FadeIn(Square)
prepare_animation(s.animate.scale(2).rotate(42))
_MethodAnimation(Square)
prepare_animation(42)
Traceback (most recent call last):
...
TypeError: Object 42 cannot be converted to an animation
Parameters:
anim (Animation | _AnimationBuilder)

Return type:
Animation


Animation
Qualified name: manim.animation.animation.Animation

class Animation(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: object

An animation.

Animations have a fixed time span.

Parameters:
mobject – The mobject to be animated. This is not required for all types of animations.

lag_ratio –

Defines the delay after which the animation is applied to submobjects. This lag is relative to the duration of the animation.

This does not influence the total runtime of the animation. Instead the runtime of individual animations is adjusted so that the complete animation has the defined run time.

run_time – The duration of the animation in seconds.

rate_func –

The function defining the animation progress based on the relative runtime (see rate_functions) .

For example rate_func(0.5) is the proportion of the animation that is done after half of the animations run time.

Return type:
Self

reverse_rate_function
Reverses the rate function of the animation. Setting reverse_rate_function does not have any effect on remover or introducer. These need to be set explicitly if an introducer-animation should be turned into a remover one and vice versa.

name
The name of the animation. This gets displayed while rendering the animation. Defaults to <class-name>(<Mobject-name>).

remover
Whether the given mobject should be removed from the scene after this animation.

suspend_mobject_updating
Whether updaters of the mobject should be suspended during the animation.

Note

In the current implementation of this class, the specified rate function is applied within Animation.interpolate_mobject() call as part of the call to Animation.interpolate_submobject(). For subclasses of Animation that are implemented by overriding interpolate_mobject(), the rate function has to be applied manually (e.g., by passing self.rate_func(alpha) instead of just alpha).

Examples

Example: LagRatios 

from manim import *

class LagRatios(Scene):
    def construct(self):
        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios

        # Create dot groups
        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()
        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)
        self.add(groups)

        # Label groups
        self.add(Text("lag_ratio = ", font_size=36).next_to(groups, UP, buff=1.5))
        for group, ratio in zip(groups, ratios):
            self.add(Text(str(ratio), font_size=36).next_to(group, UP))

        #Animate groups with different lag_ratios
        self.play(AnimationGroup(*[
            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)
            for group, ratio in zip(groups, ratios)
        ]))

        # lag_ratio also works recursively on nested submobjects:
        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))
Make interactive
Methods

begin

Begin the animation.

clean_up_from_scene

Clean up the Scene after finishing the animation.

copy

Create a copy of the animation.

create_starting_mobject

finish

Finish the animation.

get_all_families_zipped

get_all_mobjects

Get all mobjects involved in the animation.

get_all_mobjects_to_update

Get all mobjects to be updated during the animation.

get_rate_func

Get the rate function of the animation.

get_run_time

Get the run time of the animation.

get_sub_alpha

Get the animation progress of any submobjects subanimation.

interpolate

Set the animation progress.

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

interpolate_submobject

is_introducer

Test if the animation is an introducer.

is_remover

Test if the animation is a remover.

set_name

Set the name of the animation.

set_rate_func

Set the rate function of the animation.

set_run_time

Set the run time of the animation.

update_mobjects

Updates things like starting_mobject, and (for Transforms) target_mobject.

_setup_scene(scene)[source]
Setup up the Scene before starting the animation.

This includes to add() the Animation’s Mobject if the animation is an introducer.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

copy()[source]
Create a copy of the animation.

Returns:
A copy of self

Return type:
Animation

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

get_all_mobjects()[source]
Get all mobjects involved in the animation.

Ordering must match the ordering of arguments to interpolate_submobject

Returns:
The sequence of mobjects.

Return type:
Sequence[Mobject]

get_all_mobjects_to_update()[source]
Get all mobjects to be updated during the animation.

Returns:
The list of mobjects to be updated during the animation.

Return type:
List[Mobject]

get_rate_func()[source]
Get the rate function of the animation.

Returns:
The rate function of the animation.

Return type:
Callable[[float], float]

get_run_time()[source]
Get the run time of the animation.

Returns:
The time the animation takes in seconds.

Return type:
float

get_sub_alpha(alpha, index, num_submobjects)[source]
Get the animation progress of any submobjects subanimation.

Parameters:
alpha (float) – The overall animation progress

index (int) – The index of the subanimation.

num_submobjects (int) – The total count of subanimations.

Returns:
The progress of the subanimation.

Return type:
float

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

is_introducer()[source]
Test if the animation is an introducer.

Returns:
True if the animation is an introducer, False otherwise.

Return type:
bool

is_remover()[source]
Test if the animation is a remover.

Returns:
True if the animation is a remover, False otherwise.

Return type:
bool

set_name(name)[source]
Set the name of the animation.

Parameters:
name (str) – The new name of the animation.

Returns:
self

Return type:
Animation

set_rate_func(rate_func)[source]
Set the rate function of the animation.

Parameters:
rate_func (Callable[[float], float]) – The new function defining the animation progress based on the relative runtime (see rate_functions).

Returns:
self

Return type:
Animation

set_run_time(run_time)[source]
Set the run time of the animation.

Parameters:
run_time (float) – The new time the animation should take in seconds.

note:: (..) – The run_time of an animation should not be changed while it is already running.

Returns:
self

Return type:
Animation

update_mobjects(dt)[source]
Updates things like starting_mobject, and (for Transforms) target_mobject. Note, since typically (always?) self.mobject will have its updating suspended during the animation, this will do nothing to self.mobject.

Parameters:
dt (float)

Return type:
None

Wait
Qualified name: manim.animation.animation.Wait

class Wait(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

A “no operation” animation.

Parameters:
run_time (float) – The amount of time that should pass.

stop_condition (Callable[[], bool] | None) – A function without positional arguments that evaluates to a boolean. The function is evaluated after every new frame has been rendered. Playing the animation stops after the return value is truthy, or after the specified run_time has passed.

frozen_frame (bool | None) – Controls whether or not the wait animation is static, i.e., corresponds to a frozen frame. If False is passed, the render loop still progresses through the animation as usual and (among other things) continues to call updater functions. If None (the default value), the Scene.play() call tries to determine whether the Wait call can be static or not itself via Scene.should_mobjects_update().

kwargs – Keyword arguments to be passed to the parent class, Animation.

rate_func (Callable[[float], float])

Methods

begin

Begin the animation.

clean_up_from_scene

Clean up the Scene after finishing the animation.

finish

Finish the animation.

interpolate

Set the animation progress.

update_mobjects

Updates things like starting_mobject, and (for Transforms) target_mobject.

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

update_mobjects(dt)[source]
Updates things like starting_mobject, and (for Transforms) target_mobject. Note, since typically (always?) self.mobject will have its updating suspended during the animation, this will do nothing to self.mobject.

Parameters:
dt (float)

Return type:
None

changing
Animation of a mobject boundary and tracing of points.

Classes

AnimatedBoundary

Boundary of a VMobject with animated color change.

TracedPath

Traces the path of a point returned by a function call.


AnimatedBoundary
Qualified name: manim.animation.changing.AnimatedBoundary

class AnimatedBoundary(vmobject, colors=[ManimColor('#29ABCA'), ManimColor('#9CDCEB'), ManimColor('#236B8E'), ManimColor('#736357')], max_stroke_width=3, cycle_rate=0.5, back_and_forth=True, draw_rate_func=<function smooth>, fade_rate_func=<function smooth>, **kwargs)[source]
Bases: VGroup

Boundary of a VMobject with animated color change.

Examples

Example: AnimatedBoundaryExample 

from manim import *

class AnimatedBoundaryExample(Scene):
    def construct(self):
        text = Text("So shiny!")
        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],
                                    cycle_rate=3)
        self.add(text, boundary)
        self.wait(2)
Make interactive
Methods

full_family_become_partial

update_boundary_copies

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(vmobject, colors=[ManimColor('#29ABCA'), ManimColor('#9CDCEB'), ManimColor('#236B8E'), ManimColor('#736357')], max_stroke_width=3, cycle_rate=0.5, back_and_forth=True, draw_rate_func=<function smooth>, fade_rate_func=<function smooth>, **kwargs)
Initialize self. See help(type(self)) for accurate signature.


TracedPath
Qualified name: manim.animation.changing.TracedPath

class TracedPath(traced_point_func, stroke_width=2, stroke_color=ManimColor('#FFFFFF'), dissipating_time=None, **kwargs)[source]
Bases: VMobject

Traces the path of a point returned by a function call.

Parameters:
traced_point_func (Callable) – The function to be traced.

stroke_width (float) – The width of the trace.

stroke_color (ParsableManimColor | None) – The color of the trace.

dissipating_time (float | None) – The time taken for the path to dissipate. Default set to None which disables dissipation.

Examples

Example: TracedPathExample 

from manim import *

class TracedPathExample(Scene):
    def construct(self):
        circ = Circle(color=RED).shift(4*LEFT)
        dot = Dot(color=RED).move_to(circ.get_start())
        rolling_circle = VGroup(circ, dot)
        trace = TracedPath(circ.get_start)
        rolling_circle.add_updater(lambda m: m.rotate(-0.3))
        self.add(trace, rolling_circle)
        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)
Make interactive
Example: DissipatingPathExample 

from manim import *

class DissipatingPathExample(Scene):
    def construct(self):
        a = Dot(RIGHT * 2)
        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])
        self.add(a, b)
        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))
        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))
        self.wait()
Make interactive
Methods

update_path

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(traced_point_func, stroke_width=2, stroke_color=ManimColor('#FFFFFF'), dissipating_time=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
traced_point_func (Callable)

stroke_width (float)

stroke_color (ParsableManimColor | None)

dissipating_time (float | None)


composition
Tools for displaying multiple animations at once.

Classes

AnimationGroup

Plays a group or series of Animation.

LaggedStart

Adjusts the timing of a series of Animation according to lag_ratio.

LaggedStartMap

Plays a series of Animation while mapping a function to submobjects.

Succession

Plays a series of animations in succession.


AnimationGroup
Qualified name: manim.animation.composition.AnimationGroup

class AnimationGroup(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Plays a group or series of Animation.

Parameters:
animations (Animation | Iterable[Animation] | types.GeneratorType[Animation]) – Sequence of Animation objects to be played.

group (Group | VGroup | OpenGLGroup | OpenGLVGroup) – A group of multiple Mobject.

run_time (float | None) – The duration of the animation in seconds.

rate_func (Callable[[float], float]) – The function defining the animation progress based on the relative runtime (see rate_functions) .

lag_ratio (float) –

Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played. Defaults to 0.0, meaning that all animations will be played together.

This does not influence the total runtime of the animation. Instead the runtime of individual animations is adjusted so that the complete animation has the defined run time.

Methods

begin

Begin the animation.

build_animations_with_timings

Creates a list of triplets of the form (anim, start_time, end_time).

clean_up_from_scene

Clean up the Scene after finishing the animation.

finish

Finish the animation.

get_all_mobjects

Get all mobjects involved in the animation.

init_run_time

Calculates the run time of the animation, if different from run_time.

interpolate

Set the animation progress.

update_mobjects

Updates things like starting_mobject, and (for Transforms) target_mobject.

_setup_scene(scene)[source]
Setup up the Scene before starting the animation.

This includes to add() the Animation’s Mobject if the animation is an introducer.

Parameters:
scene – The scene the animation should be cleaned up from.

Return type:
None

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

build_animations_with_timings()[source]
Creates a list of triplets of the form (anim, start_time, end_time).

Return type:
None

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

get_all_mobjects()[source]
Get all mobjects involved in the animation.

Ordering must match the ordering of arguments to interpolate_submobject

Returns:
The sequence of mobjects.

Return type:
Sequence[Mobject]

init_run_time(run_time)[source]
Calculates the run time of the animation, if different from run_time.

Parameters:
run_time – The duration of the animation in seconds.

Returns:
The duration of the animation in seconds.

Return type:
run_time

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

update_mobjects(dt)[source]
Updates things like starting_mobject, and (for Transforms) target_mobject. Note, since typically (always?) self.mobject will have its updating suspended during the animation, this will do nothing to self.mobject.

Parameters:
dt (float)

Return type:
None


LaggedStart
Qualified name: manim.animation.composition.LaggedStart

class LaggedStart(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AnimationGroup

Adjusts the timing of a series of Animation according to lag_ratio.

Parameters:
animations (Animation) – Sequence of Animation objects to be played.

lag_ratio (float) –

Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played. Defaults to 0.05, meaning that the next animation will begin when 5% of the current animation has played.

This does not influence the total runtime of the animation. Instead the runtime of individual animations is adjusted so that the complete animation has the defined run time.

Examples

Example: LaggedStartExample 

from manim import *

class LaggedStartExample(Scene):
    def construct(self):
        title = Text("lag_ratio = 0.25").to_edge(UP)

        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)
        dot2 = Dot(point=LEFT * 2, radius=0.16)
        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)
        line_25 = DashedLine(
            start=LEFT + UP * 2,
            end=LEFT + DOWN * 2,
            color=RED
        )
        label = Text("25%", font_size=24).next_to(line_25, UP)
        self.add(title, dot1, dot2, dot3, line_25, label)

        self.play(LaggedStart(
            dot1.animate.shift(RIGHT * 4),
            dot2.animate.shift(RIGHT * 4),
            dot3.animate.shift(RIGHT * 4),
            lag_ratio=0.25,
            run_time=4
        ))
Make interactive
Methods


LaggedStartMap
Qualified name: manim.animation.composition.LaggedStartMap

class LaggedStartMap(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: LaggedStart

Plays a series of Animation while mapping a function to submobjects.

Parameters:
AnimationClass (Callable[..., Animation]) – Animation to apply to mobject.

mobject (Mobject) – Mobject whose submobjects the animation, and optionally the function, are to be applied.

arg_creator (Callable[[Mobject], str]) – Function which will be applied to Mobject.

run_time (float) – The duration of the animation in seconds.

Examples

Example: LaggedStartMapExample 

from manim import *

class LaggedStartMapExample(Scene):
    def construct(self):
        title = Tex("LaggedStartMap").to_edge(UP, buff=LARGE_BUFF)
        dots = VGroup(
            *[Dot(radius=0.16) for _ in range(35)]
            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)
        self.add(dots, title)

        # Animate yellow ripple effect
        for mob in dots, title:
            self.play(LaggedStartMap(
                ApplyMethod, mob,
                lambda m : (m.set_color, YELLOW),
                lag_ratio = 0.1,
                rate_func = there_and_back,
                run_time = 2
            ))
Make interactive
Methods


Succession
Qualified name: manim.animation.composition.Succession

class Succession(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AnimationGroup

Plays a series of animations in succession.

Parameters:
animations (Animation) – Sequence of Animation objects to be played.

lag_ratio (float) –

Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played. Defaults to 1.0, meaning that the next animation will begin when 100% of the current animation has played.

This does not influence the total runtime of the animation. Instead the runtime of individual animations is adjusted so that the complete animation has the defined run time.

Examples

Example: SuccessionExample 

from manim import *

class SuccessionExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)
        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)
        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)
        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)
        self.add(dot1, dot2, dot3, dot4)

        self.play(Succession(
            dot1.animate.move_to(dot2),
            dot2.animate.move_to(dot3),
            dot3.animate.move_to(dot4),
            dot4.animate.move_to(dot1)
        ))
Make interactive
Methods

begin

Begin the animation.

finish

Finish the animation.

interpolate

Set the animation progress.

next_animation

Proceeds to the next animation.

update_active_animation

update_mobjects

Updates things like starting_mobject, and (for Transforms) target_mobject.

_setup_scene(scene)[source]
Setup up the Scene before starting the animation.

This includes to add() the Animation’s Mobject if the animation is an introducer.

Parameters:
scene – The scene the animation should be cleaned up from.

Return type:
None

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

next_animation()[source]
Proceeds to the next animation.

This method is called right when the active animation finishes.

Return type:
None

update_mobjects(dt)[source]
Updates things like starting_mobject, and (for Transforms) target_mobject. Note, since typically (always?) self.mobject will have its updating suspended during the animation, this will do nothing to self.mobject.

Parameters:
dt (float)

Return type:
None


creation
Animate the display or removal of a mobject from a scene.

Classes

AddTextLetterByLetter

Show a Text letter by letter on the scene.

AddTextWordByWord

Show a Text word by word on the scene.

Create

Incrementally show a VMobject.

DrawBorderThenFill

Draw the border first and then show the fill.

RemoveTextLetterByLetter

Remove a Text letter by letter from the scene.

ShowIncreasingSubsets

Show one submobject at a time, leaving all previous ones displayed on screen.

ShowPartial

Abstract class for Animations that show the VMobject partially.

ShowSubmobjectsOneByOne

Show one submobject at a time, removing all previously displayed ones from screen.

SpiralIn

Create the Mobject with sub-Mobjects flying in on spiral trajectories.

Uncreate

Like Create but in reverse.

Unwrite

Simulate erasing by hand a Text or a VMobject.

Write

Simulate hand-writing a Text or hand-drawing a VMobject.


AddTextLetterByLetter
Qualified name: manim.animation.creation.AddTextLetterByLetter

class AddTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ShowIncreasingSubsets

Show a Text letter by letter on the scene.

Parameters:
time_per_char (float) – Frequency of appearance of the letters.

tip:: (..) – This is currently only possible for class:~.Text and not for class:~.MathTex

text (Text)

suspend_mobject_updating (bool)

int_func (Callable[[np.ndarray], np.ndarray])

rate_func (Callable[[float], float])

run_time (float | None)

Methods


AddTextWordByWord
Qualified name: manim.animation.creation.AddTextWordByWord

class AddTextWordByWord(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Succession

Show a Text word by word on the scene. Note: currently broken.

Methods

Parameters:
text_mobject (Text)

run_time (float)

time_per_char (float)


Create
Qualified name: manim.animation.creation.Create

class Create(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ShowPartial

Incrementally show a VMobject.

Parameters:
mobject (VMobject | OpenGLVMobject | OpenGLSurface) – The VMobject to animate.

lag_ratio (float)

introducer (bool)

Raises:
TypeError – If mobject is not an instance of VMobject.

Examples

Example: CreateScene 

from manim import *

class CreateScene(Scene):
    def construct(self):
        self.play(Create(Square()))
Make interactive
See also

ShowPassingFlash

Methods


DrawBorderThenFill
Qualified name: manim.animation.creation.DrawBorderThenFill

class DrawBorderThenFill(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Draw the border first and then show the fill.

Examples

Example: ShowDrawBorderThenFill 

from manim import *

class ShowDrawBorderThenFill(Scene):
    def construct(self):
        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))
Make interactive
Methods

begin

Begin the animation.

get_all_mobjects

Get all mobjects involved in the animation.

get_outline

get_stroke_color

interpolate_submobject

Parameters:
vmobject (VMobject | OpenGLVMobject)

run_time (float)

rate_func (Callable[[float], float])

stroke_width (float)

stroke_color (str)

draw_border_animation_config (dict)

fill_animation_config (dict)

introducer (bool)

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

get_all_mobjects()[source]
Get all mobjects involved in the animation.

Ordering must match the ordering of arguments to interpolate_submobject

Returns:
The sequence of mobjects.

Return type:
Sequence[Mobject]


RemoveTextLetterByLetter
Qualified name: manim.animation.creation.RemoveTextLetterByLetter

class RemoveTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AddTextLetterByLetter

Remove a Text letter by letter from the scene.

Parameters:
time_per_char (float) – Frequency of appearance of the letters.

tip:: (..) – This is currently only possible for class:~.Text and not for class:~.MathTex

text (Text)

suspend_mobject_updating (bool)

int_func (Callable[[np.ndarray], np.ndarray])

rate_func (Callable[[float], float])

run_time (float | None)

Methods


ShowIncreasingSubsets
Qualified name: manim.animation.creation.ShowIncreasingSubsets

class ShowIncreasingSubsets(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Show one submobject at a time, leaving all previous ones displayed on screen.

Examples

Example: ShowIncreasingSubsetsScene 

from manim import *

class ShowIncreasingSubsetsScene(Scene):
    def construct(self):
        p = VGroup(Dot(), Square(), Triangle())
        self.add(p)
        self.play(ShowIncreasingSubsets(p))
        self.wait()
Make interactive
Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

update_submobject_list

Parameters:
group (Mobject)

suspend_mobject_updating (bool)

int_func (Callable[[np.ndarray], np.ndarray])

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None


ShowPartial
Qualified name: manim.animation.creation.ShowPartial

class ShowPartial(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Abstract class for Animations that show the VMobject partially.

Raises:
TypeError – If mobject is not an instance of VMobject.

Parameters:
mobject (VMobject | OpenGLVMobject | OpenGLSurface | None)

See also

Create, ShowPassingFlash

Methods

interpolate_submobject


ShowSubmobjectsOneByOne
Qualified name: manim.animation.creation.ShowSubmobjectsOneByOne

class ShowSubmobjectsOneByOne(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ShowIncreasingSubsets

Show one submobject at a time, removing all previously displayed ones from screen.

Methods

update_submobject_list

Parameters:
group (Iterable[Mobject])

int_func (Callable[[np.ndarray], np.ndarray])


SpiralIn
Qualified name: manim.animation.creation.SpiralIn

class SpiralIn(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Create the Mobject with sub-Mobjects flying in on spiral trajectories.

Parameters:
shapes (Mobject) – The Mobject on which to be operated.

scale_factor (float) – The factor used for scaling the effect.

fade_in_fraction – Fractional duration of initial fade-in of sub-Mobjects as they fly inward.

Examples

Example: SpiralInExample 

from manim import *

class SpiralInExample(Scene):
    def construct(self):
        pi = MathTex(r"\pi").scale(7)
        pi.shift(2.25 * LEFT + 1.5 * UP)
        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)
        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)
        shapes = VGroup(pi, circle, square)
        self.play(SpiralIn(shapes))
Make interactive
Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None


Uncreate
Qualified name: manim.animation.creation.Uncreate

class Uncreate(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Create

Like Create but in reverse.

Examples

Example: ShowUncreate 

from manim import *

class ShowUncreate(Scene):
    def construct(self):
        self.play(Uncreate(Square()))
Make interactive
See also

Create

Methods

Parameters:
mobject (VMobject | OpenGLVMobject)

reverse_rate_function (bool)

remover (bool)


Unwrite
Qualified name: manim.animation.creation.Unwrite

class Unwrite(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Write

Simulate erasing by hand a Text or a VMobject.

Parameters:
reverse (bool) – Set True to have the animation start erasing from the last submobject first.

vmobject (VMobject)

rate_func (Callable[[float], float])

Examples

Example: UnwriteReverseTrue 

from manim import *

class UnwriteReverseTrue(Scene):
    def construct(self):
        text = Tex("Alice and Bob").scale(3)
        self.add(text)
        self.play(Unwrite(text))
Make interactive
Example: UnwriteReverseFalse 

from manim import *

class UnwriteReverseFalse(Scene):
    def construct(self):
        text = Tex("Alice and Bob").scale(3)
        self.add(text)
        self.play(Unwrite(text, reverse=False))
Make interactive
Methods


Write
Qualified name: manim.animation.creation.Write

class Write(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: DrawBorderThenFill

Simulate hand-writing a Text or hand-drawing a VMobject.

Examples

Example: ShowWrite 

from manim import *

class ShowWrite(Scene):
    def construct(self):
        self.play(Write(Text("Hello", font_size=144)))
Make interactive
Example: ShowWriteReversed 

from manim import *

class ShowWriteReversed(Scene):
    def construct(self):
        self.play(Write(Text("Hello", font_size=144), reverse=True, remover=False))
Make interactive
Tests

Check that creating empty Write animations works:

from manim import Write, Text
Write(Text(''))
Write(Text(''))
Methods

begin

Begin the animation.

finish

Finish the animation.

reverse_submobjects

Parameters:
vmobject (VMobject | OpenGLVMobject)

rate_func (Callable[[float], float])

reverse (bool)

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

fading
Fading in and out of view.

Example: Fading 

from manim import *

class Fading(Scene):
    def construct(self):
        tex_in = Tex("Fade", "In").scale(3)
        tex_out = Tex("Fade", "Out").scale(3)
        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))
        self.play(ReplacementTransform(tex_in, tex_out))
        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))
Make interactive
Classes

FadeIn

Fade in Mobject s.

FadeOut

Fade out Mobject s.



FadeIn
Qualified name: manim.animation.fading.FadeIn

class FadeIn(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: _Fade

Fade in Mobject s.

Parameters:
mobjects (Mobject) – The mobjects to be faded in.

shift – The vector by which the mobject shifts while being faded in.

target_position – The position from which the mobject starts while being faded in. In case another mobject is given as target position, its center is used.

scale – The factor by which the mobject is scaled initially before being rescaling to its original size while being faded in.

Examples

Example: FadeInExample 

from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            "FadeIn with ", "shift ", " or target\_position", " and scale"
        ).scale(1)
        animations = [
            FadeIn(tex[0]),
            FadeIn(tex[1], shift=DOWN),
            FadeIn(tex[2], target_position=dot),
            FadeIn(tex[3], scale=1.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))
Make interactive
Methods

create_starting_mobject

create_target

Attributes

path_arc

path_func

FadeOut
Qualified name: manim.animation.fading.FadeOut

class FadeOut(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: _Fade

Fade out Mobject s.

Parameters:
mobjects (Mobject) – The mobjects to be faded out.

shift – The vector by which the mobject shifts while being faded out.

target_position – The position to which the mobject moves while being faded out. In case another mobject is given as target position, its center is used.

scale – The factor by which the mobject is scaled while being faded out.

Examples

Example: FadeInExample 

from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            "FadeOut with ", "shift ", " or target\_position", " and scale"
        ).scale(1)
        animations = [
            FadeOut(tex[0]),
            FadeOut(tex[1], shift=DOWN),
            FadeOut(tex[2], target_position=dot),
            FadeOut(tex[3], scale=0.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))
Make interactive
Methods

clean_up_from_scene

Clean up the Scene after finishing the animation.

create_target

Attributes

path_arc

path_func

clean_up_from_scene(scene=None)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None


growing
Animations that introduce mobjects to scene by growing them from points.

Example: Growing 

from manim import *

class Growing(Scene):
    def construct(self):
        square = Square()
        circle = Circle()
        triangle = Triangle()
        arrow = Arrow(LEFT, RIGHT)
        star = Star()

        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)
        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)

        self.play(GrowFromPoint(square, ORIGIN))
        self.play(GrowFromCenter(circle))
        self.play(GrowFromEdge(triangle, DOWN))
        self.play(GrowArrow(arrow))
        self.play(SpinInFromNothing(star))
Make interactive
Classes

GrowArrow

Introduce an Arrow by growing it from its start toward its tip.

GrowFromCenter

Introduce an Mobject by growing it from its center.

GrowFromEdge

Introduce an Mobject by growing it from one of its bounding box edges.

GrowFromPoint

Introduce an Mobject by growing it from a point.

SpinInFromNothing

Introduce an Mobject spinning and growing it from its center.


GrowArrow
Qualified name: manim.animation.growing.GrowArrow

class GrowArrow(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: GrowFromPoint

Introduce an Arrow by growing it from its start toward its tip.

Parameters:
arrow (Arrow) – The arrow to be introduced.

point_color (str) – Initial color of the arrow before growing to its full size. Leave empty to match arrow’s color.

Examples

Example: GrowArrowExample 

from manim import *

class GrowArrowExample(Scene):
    def construct(self):
        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]
        VGroup(*arrows).set_x(0).arrange(buff=2)
        self.play(GrowArrow(arrows[0]))
        self.play(GrowArrow(arrows[1], point_color=RED))
Make interactive
Methods

create_starting_mobject

Attributes

path_arc

path_func



GrowFromCenter
Qualified name: manim.animation.growing.GrowFromCenter

class GrowFromCenter(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: GrowFromPoint

Introduce an Mobject by growing it from its center.

Parameters:
mobject (Mobject) – The mobjects to be introduced.

point_color (str) – Initial color of the mobject before growing to its full size. Leave empty to match mobject’s color.

Examples

Example: GrowFromCenterExample 

from manim import *

class GrowFromCenterExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(2)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(GrowFromCenter(squares[0]))
        self.play(GrowFromCenter(squares[1], point_color=RED))
Make interactive
Methods

Attributes

path_arc

path_func


GrowFromEdge
Qualified name: manim.animation.growing.GrowFromEdge

class GrowFromEdge(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: GrowFromPoint

Introduce an Mobject by growing it from one of its bounding box edges.

Parameters:
mobject (Mobject) – The mobjects to be introduced.

edge (np.ndarray) – The direction to seek bounding box edge of mobject.

point_color (str) – Initial color of the mobject before growing to its full size. Leave empty to match mobject’s color.

Examples

Example: GrowFromEdgeExample 

from manim import *

class GrowFromEdgeExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.play(GrowFromEdge(squares[0], DOWN))
        self.play(GrowFromEdge(squares[1], RIGHT))
        self.play(GrowFromEdge(squares[2], UR))
        self.play(GrowFromEdge(squares[3], UP, point_color=RED))
Make interactive
Methods

Attributes

path_arc

path_func



GrowFromPoint
Qualified name: manim.animation.growing.GrowFromPoint

class GrowFromPoint(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Introduce an Mobject by growing it from a point.

Parameters:
mobject (Mobject) – The mobjects to be introduced.

point (np.ndarray) – The point from which the mobject grows.

point_color (str) – Initial color of the mobject before growing to its full size. Leave empty to match mobject’s color.

Examples

Example: GrowFromPointExample 

from manim import *

class GrowFromPointExample(Scene):
    def construct(self):
        dot = Dot(3 * UR, color=GREEN)
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.add(dot)
        self.play(GrowFromPoint(squares[0], ORIGIN))
        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))
        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))
        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))
Make interactive
Methods

create_starting_mobject

create_target

Attributes

path_arc

path_func



SpinInFromNothing
Qualified name: manim.animation.growing.SpinInFromNothing

class SpinInFromNothing(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: GrowFromCenter

Introduce an Mobject spinning and growing it from its center.

Parameters:
mobject (Mobject) – The mobjects to be introduced.

angle (float) – The amount of spinning before mobject reaches its full size. E.g. 2*PI means that the object will do one full spin before being fully introduced.

point_color (str) – Initial color of the mobject before growing to its full size. Leave empty to match mobject’s color.

Examples

Example: SpinInFromNothingExample 

from manim import *

class SpinInFromNothingExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(3)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(SpinInFromNothing(squares[0]))
        self.play(SpinInFromNothing(squares[1], angle=2 * PI))
        self.play(SpinInFromNothing(squares[2], point_color=RED))
Make interactive
Methods

Attributes

path_arc

path_func



indication
Animations drawing attention to particular mobjects.

Examples

Example: Indications 

from manim import *

class Indications(Scene):
    def construct(self):
        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]
        names = [Tex(i.__name__).scale(3) for i in indications]

        self.add(names[0])
        for i in range(len(names)):
            if indications[i] is Flash:
                self.play(Flash(UP))
            elif indications[i] is ShowPassingFlash:
                self.play(ShowPassingFlash(Underline(names[i])))
            else:
                self.play(indications[i](names[i]))
            self.play(AnimationGroup(
                FadeOut(names[i], shift=UP*1.5),
                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),
            ))
Make interactive
Classes

ApplyWave

Send a wave through the Mobject distorting it temporarily.

Circumscribe

Draw a temporary line surrounding the mobject.

Flash

Send out lines in all directions.

FocusOn

Shrink a spotlight to a position.

Indicate

Indicate a Mobject by temporarily resizing and recoloring it.

ShowPassingFlash

Show only a sliver of the VMobject each frame.

ShowPassingFlashWithThinningStrokeWidth

Wiggle

Wiggle a Mobject.


ApplyWave
Qualified name: manim.animation.indication.ApplyWave

class ApplyWave(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Homotopy

Send a wave through the Mobject distorting it temporarily.

Parameters:
mobject (Mobject) – The mobject to be distorted.

direction (ndarray) – The direction in which the wave nudges points of the shape

amplitude (float) – The distance points of the shape get shifted

wave_func (Callable[[float], float]) – The function defining the shape of one wave flank.

time_width (float) – The length of the wave relative to the width of the mobject.

ripples (int) – The number of ripples of the wave

run_time (float) – The duration of the animation.

Examples

Example: ApplyingWaves 

from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex("WaveWaveWaveWaveWave").scale(2)
        self.play(ApplyWave(tex))
        self.play(ApplyWave(
            tex,
            direction=RIGHT,
            time_width=0.5,
            amplitude=0.3
        ))
        self.play(ApplyWave(
            tex,
            rate_func=linear,
            ripples=4
        ))
Make interactive
Methods

Circumscribe
Qualified name: manim.animation.indication.Circumscribe

class Circumscribe(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Succession

Draw a temporary line surrounding the mobject.

Parameters:
mobject (Mobject) – The mobject to be circumscribed.

shape (Type) – The shape with which to surround the given mobject. Should be either Rectangle or Circle

fade_in – Whether to make the surrounding shape to fade in. It will be drawn otherwise.

fade_out – Whether to make the surrounding shape to fade out. It will be undrawn otherwise.

time_width – The time_width of the drawing and undrawing. Gets ignored if either fade_in or fade_out is True.

buff (float) – The distance between the surrounding shape and the given mobject.

color (ManimColor | int | str | tuple[int, int, int] | tuple[float, float, float] | tuple[int, int, int, int] | tuple[float, float, float, float] | ndarray[Any, dtype[int64]] | ndarray[Any, dtype[float64]]) – The color of the surrounding shape.

run_time – The duration of the entire animation.

kwargs – Additional arguments to be passed to the Succession constructor

Examples

Example: UsingCircumscribe 

from manim import *

class UsingCircumscribe(Scene):
    def construct(self):
        lbl = Tex(r"Circum-\\scribe").scale(2)
        self.add(lbl)
        self.play(Circumscribe(lbl))
        self.play(Circumscribe(lbl, Circle))
        self.play(Circumscribe(lbl, fade_out=True))
        self.play(Circumscribe(lbl, time_width=2))
        self.play(Circumscribe(lbl, Circle, True))
Make interactive
Methods

Flash
Qualified name: manim.animation.indication.Flash

class Flash(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AnimationGroup

Send out lines in all directions.

Parameters:
point (ndarray | Mobject) – The center of the flash lines. If it is a Mobject its center will be used.

line_length (float) – The length of the flash lines.

num_lines (int) – The number of flash lines.

flash_radius (float) – The distance from point at which the flash lines start.

line_stroke_width (int) – The stroke width of the flash lines.

color (str) – The color of the flash lines.

time_width (float) – The time width used for the flash lines. See ShowPassingFlash for more details.

run_time (float) – The duration of the animation.

kwargs – Additional arguments to be passed to the Succession constructor

Examples

Example: UsingFlash 

from manim import *

class UsingFlash(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex("Flash the dot below:"), dot)
        self.play(Flash(dot))
        self.wait()
Make interactive
Example: FlashOnCircle 

from manim import *

class FlashOnCircle(Scene):
    def construct(self):
        radius = 2
        circle = Circle(radius)
        self.add(circle)
        self.play(Flash(
            circle, line_length=1,
            num_lines=30, color=RED,
            flash_radius=radius+SMALL_BUFF,
            time_width=0.3, run_time=2,
            rate_func = rush_from
        ))
Make interactive
Methods

create_line_anims

create_lines

FocusOn
Qualified name: manim.animation.indication.FocusOn

class FocusOn(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Shrink a spotlight to a position.

Parameters:
focus_point (ndarray | Mobject) – The point at which to shrink the spotlight. If it is a Mobject its center will be used.

opacity (float) – The opacity of the spotlight.

color (str) – The color of the spotlight.

run_time (float) – The duration of the animation.

kwargs – Additional arguments to be passed to the Succession constructor

Examples

Example: UsingFocusOn 

from manim import *

class UsingFocusOn(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex("Focusing on the dot below:"), dot)
        self.play(FocusOn(dot))
        self.wait()
Make interactive
Methods

create_target

Attributes

path_arc

path_func

Indicate
Qualified name: manim.animation.indication.Indicate

class Indicate(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Indicate a Mobject by temporarily resizing and recoloring it.

Parameters:
mobject (Mobject) – The mobject to indicate.

scale_factor (float) – The factor by which the mobject will be temporally scaled

color (str) – The color the mobject temporally takes.

rate_func (Callable[[float, float | None], ndarray]) – The function defining the animation progress at every point in time.

kwargs – Additional arguments to be passed to the Succession constructor

Examples

Example: UsingIndicate 

from manim import *

class UsingIndicate(Scene):
    def construct(self):
        tex = Tex("Indicate").scale(3)
        self.play(Indicate(tex))
        self.wait()
Make interactive
Methods

create_target

Attributes

path_arc

path_func

ShowPassingFlash
Qualified name: manim.animation.indication.ShowPassingFlash

class ShowPassingFlash(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ShowPartial

Show only a sliver of the VMobject each frame.

Parameters:
mobject (VMobject) – The mobject whose stroke is animated.

time_width (float) – The length of the sliver relative to the length of the stroke.

Examples

Example: TimeWidthValues 

from manim import *

class TimeWidthValues(Scene):
    def construct(self):
        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)
        lbl = VMobject()
        self.add(p, lbl)
        p = p.copy().set_color(BLUE)
        for time_width in [0.2, 0.5, 1, 2]:
            lbl.become(Tex(r"\texttt{time\_width={{%.1f}}}"%time_width))
            self.play(ShowPassingFlash(
                p.copy().set_color(BLUE),
                run_time=2,
                time_width=time_width
            ))
Make interactive
See also

Create

Methods

clean_up_from_scene

Clean up the Scene after finishing the animation.

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

ShowPassingFlashWithThinningStrokeWidth
Qualified name: manim.animation.indication.ShowPassingFlashWithThinningStrokeWidth

class ShowPassingFlashWithThinningStrokeWidth(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AnimationGroup

Methods

Wiggle
Qualified name: manim.animation.indication.Wiggle

class Wiggle(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Wiggle a Mobject.

Parameters:
mobject (Mobject) – The mobject to wiggle.

scale_value (float) – The factor by which the mobject will be temporarily scaled.

rotation_angle (float) – The wiggle angle.

n_wiggles (int) – The number of wiggles.

scale_about_point (ndarray | None) – The point about which the mobject gets scaled.

rotate_about_point (ndarray | None) – The point around which the mobject gets rotated.

run_time (float) – The duration of the animation

Examples

Example: ApplyingWaves 

from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex("Wiggle").scale(3)
        self.play(Wiggle(tex))
        self.wait()
Make interactive
Methods

get_rotate_about_point

get_scale_about_point

interpolate_submobject

movement
Animations related to movement.

Classes

ComplexHomotopy

Complex Homotopy a function Cx[0, 1] to C

Homotopy

A Homotopy.

MoveAlongPath

Make one mobject move along the path of another mobject.

PhaseFlow

SmoothedVectorizedHomotopy

ComplexHomotopy
Qualified name: manim.animation.movement.ComplexHomotopy

class ComplexHomotopy(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Homotopy

Complex Homotopy a function Cx[0, 1] to C

Methods

Parameters:
complex_homotopy (Callable[[complex], float])

mobject (Mobject)

Homotopy
Qualified name: manim.animation.movement.Homotopy

class Homotopy(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

A Homotopy.

This is an animation transforming the points of a mobject according to the specified transformation function. With the parameter 
 moving from 0 to 1 throughout the animation and 
 describing the coordinates of the point of a mobject, the function passed to the homotopy keyword argument should transform the tuple 
 to 
, the coordinates the original point is transformed to at time 
.

Parameters:
homotopy (Callable[[float, float, float, float], tuple[float, float, float]]) – A function mapping 
 to 
.

mobject (Mobject) – The mobject transformed under the given homotopy.

run_time (float) – The run time of the animation.

apply_function_kwargs (dict[str, Any] | None) – Keyword arguments propagated to Mobject.apply_function().

kwargs – Further keyword arguments passed to the parent class.

Methods

function_at_time_t

interpolate_submobject

MoveAlongPath
Qualified name: manim.animation.movement.MoveAlongPath

class MoveAlongPath(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Make one mobject move along the path of another mobject.

Example: MoveAlongPathExample 

from manim import *

class MoveAlongPathExample(Scene):
    def construct(self):
        d1 = Dot().set_color(ORANGE)
        l1 = Line(LEFT, RIGHT)
        l2 = VMobject()
        self.add(d1, l1, l2)
        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))
        self.play(MoveAlongPath(d1, l1), rate_func=linear)
Make interactive
Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
mobject (Mobject)

path (VMobject)

suspend_mobject_updating (bool | None)

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None



PhaseFlow
Qualified name: manim.animation.movement.PhaseFlow

class PhaseFlow(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
function (Callable[[np.ndarray], np.ndarray])

mobject (Mobject)

virtual_time (float)

suspend_mobject_updating (bool)

rate_func (Callable[[float], float])

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

SmoothedVectorizedHomotopy
Qualified name: manim.animation.movement.SmoothedVectorizedHomotopy

class SmoothedVectorizedHomotopy(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Homotopy

Methods

interpolate_submobject

Parameters:
homotopy (Callable[[float, float, float, float], tuple[float, float, float]])

mobject (Mobject)

run_time (float)

apply_function_kwargs (dict[str, Any] | None)

numbers
Animations for changing numbers.

Classes

ChangeDecimalToValue

ChangingDecimal

ChangeDecimalToValue
Qualified name: manim.animation.numbers.ChangeDecimalToValue

class ChangeDecimalToValue(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ChangingDecimal

Methods

Parameters:
decimal_mob (DecimalNumber)

target_number (int)

ChangingDecimal
Qualified name: manim.animation.numbers.ChangingDecimal

class ChangingDecimal(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Methods

check_validity_of_input

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
decimal_mob (DecimalNumber)

number_update_func (Callable[[float], float])

suspend_mobject_updating (bool | None)

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

rotation
Animations related to rotation.

Classes

Rotate

Animation that rotates a Mobject.

Rotating

Rotate
Qualified name: manim.animation.rotation.Rotate

class Rotate(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Animation that rotates a Mobject.

Parameters:
mobject (Mobject) – The mobject to be rotated.

angle (float) – The rotation angle.

axis (np.ndarray) – The rotation axis as a numpy vector.

about_point (Sequence[float] | None) – The rotation center.

about_edge (Sequence[float] | None) – If about_point is None, this argument specifies the direction of the bounding box point to be taken as the rotation center.

Examples

Example: UsingRotate 

from manim import *

class UsingRotate(Scene):
    def construct(self):
        self.play(
            Rotate(
                Square(side_length=0.5).shift(UP * 2),
                angle=2*PI,
                about_point=ORIGIN,
                rate_func=linear,
            ),
            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),
            )
Make interactive
Methods

create_target

Attributes

path_arc

path_func

Rotating
Qualified name: manim.animation.rotation.Rotating

class Rotating(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
mobject (Mobject)

axis (np.ndarray)

radians (np.ndarray)

about_point (np.ndarray | None)

about_edge (np.ndarray | None)

run_time (float)

rate_func (Callable[[float], float])

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

specialized
Classes

Broadcast

Broadcast a mobject starting from an initial_width, up to the actual size of the mobject.

Broadcast
Qualified name: manim.animation.specialized.Broadcast

class Broadcast(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: LaggedStart

Broadcast a mobject starting from an initial_width, up to the actual size of the mobject.

Parameters:
mobject – The mobject to be broadcast.

focal_point (Sequence[float]) – The center of the broadcast, by default ORIGIN.

n_mobs (int) – The number of mobjects that emerge from the focal point, by default 5.

initial_opacity (float) – The starting stroke opacity of the mobjects emitted from the broadcast, by default 1.

final_opacity (float) – The final stroke opacity of the mobjects emitted from the broadcast, by default 0.

initial_width (float) – The initial width of the mobjects, by default 0.0.

remover (bool) – Whether the mobjects should be removed from the scene after the animation, by default True.

lag_ratio (float) – The time between each iteration of the mobject, by default 0.2.

run_time (float) – The total duration of the animation, by default 3.

kwargs (Any) – Additional arguments to be passed to LaggedStart.

Examples

Example: BroadcastExample 

from manim import *

class BroadcastExample(Scene):
    def construct(self):
        mob = Circle(radius=4, color=TEAL_A)
        self.play(Broadcast(mob))
Make interactive
Methods

speedmodifier
Utilities for modifying the speed at which animations are played.

Classes

ChangeSpeed

Modifies the speed of passed animation.

ChangeSpeed
Qualified name: manim.animation.speedmodifier.ChangeSpeed

class ChangeSpeed(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Modifies the speed of passed animation. AnimationGroup with different lag_ratio can also be used which combines multiple animations into one. The run_time of the passed animation is changed to modify the speed.

Parameters:
anim (Animation | _AnimationBuilder) – Animation of which the speed is to be modified.

speedinfo (dict[float, float]) – Contains nodes (percentage of run_time) and its corresponding speed factor.

rate_func (Callable[[float], float] | None) – Overrides rate_func of passed animation, applied before changing speed.

affects_speed_updaters (bool)

Examples

Example: SpeedModifierExample 

from manim import *

class SpeedModifierExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        b = Dot().shift(RIGHT * 4)
        self.add(a, b)
        self.play(
            ChangeSpeed(
                AnimationGroup(
                    a.animate(run_time=1).shift(RIGHT * 8),
                    b.animate(run_time=1).shift(LEFT * 8),
                ),
                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},
                rate_func=linear,
            )
        )
Make interactive
Example: SpeedModifierUpdaterExample 

from manim import *

class SpeedModifierUpdaterExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.play(
            ChangeSpeed(
                Wait(2),
                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},
                affects_speed_updaters=True,
            )
        )
Make interactive
Example: SpeedModifierUpdaterExample2 

from manim import *

class SpeedModifierUpdaterExample2(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.wait()
        self.play(
            ChangeSpeed(
                Wait(),
                speedinfo={1: 0},
                affects_speed_updaters=True,
            )
        )
Make interactive
Methods

add_updater

This static method can be used to apply speed change to updaters.

begin

Begin the animation.

clean_up_from_scene

Clean up the Scene after finishing the animation.

finish

Finish the animation.

get_scaled_total_time

The time taken by the animation under the assumption that the run_time is 1.

interpolate

Set the animation progress.

setup

update_mobjects

Updates things like starting_mobject, and (for Transforms) target_mobject.

Attributes

dt

is_changing_dt

_setup_scene(scene)[source]
Setup up the Scene before starting the animation.

This includes to add() the Animation’s Mobject if the animation is an introducer.

Parameters:
scene – The scene the animation should be cleaned up from.

Return type:
None

classmethod add_updater(mobject, update_function, index=None, call_updater=False)[source]
This static method can be used to apply speed change to updaters.

This updater will follow speed and rate function of any ChangeSpeed animation that is playing with affects_speed_updaters=True. By default, updater functions added via the usual Mobject.add_updater() method do not respect the change of animation speed.

Parameters:
mobject (Mobject) – The mobject to which the updater should be attached.

update_function (Updater) – The function that is called whenever a new frame is rendered.

index (int | None) – The position in the list of the mobject’s updaters at which the function should be inserted.

call_updater (bool) – If True, calls the update function when attaching it to the mobject.

See also

ChangeSpeed, Mobject.add_updater()

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

finish()[source]
Finish the animation.

This method gets called when the animation is over.

Return type:
None

get_scaled_total_time()[source]
The time taken by the animation under the assumption that the run_time is 1.

Return type:
float

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

update_mobjects(dt)[source]
Updates things like starting_mobject, and (for Transforms) target_mobject. Note, since typically (always?) self.mobject will have its updating suspended during the animation, this will do nothing to self.mobject.

Parameters:
dt (float)

Return type:
None

transform
Animations transforming one mobject into another.

Classes

ApplyComplexFunction

ApplyFunction

ApplyMatrix

Applies a matrix transform to an mobject.

ApplyMethod

Animates a mobject by applying a method.

ApplyPointwiseFunction

Animation that applies a pointwise function to a mobject.

ApplyPointwiseFunctionToCenter

ClockwiseTransform

Transforms the points of a mobject along a clockwise oriented arc.

CounterclockwiseTransform

Transforms the points of a mobject along a counterclockwise oriented arc.

CyclicReplace

An animation moving mobjects cyclically.

FadeToColor

Animation that changes color of a mobject.

FadeTransform

Fades one mobject into another.

FadeTransformPieces

Fades submobjects of one mobject into submobjects of another one.

MoveToTarget

Transforms a mobject to the mobject stored in its target attribute.

ReplacementTransform

Replaces and morphs a mobject into a target mobject.

Restore

Transforms a mobject to its last saved state.

ScaleInPlace

Animation that scales a mobject by a certain factor.

ShrinkToCenter

Animation that makes a mobject shrink to center.

Swap

Transform

A Transform transforms a Mobject into a target Mobject.

TransformAnimations

TransformFromCopy

Performs a reversed Transform

ApplyComplexFunction
Qualified name: manim.animation.transform.ApplyComplexFunction

class ApplyComplexFunction(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyMethod

Methods

Attributes

path_arc

path_func

Parameters:
function (types.MethodType)

mobject (Mobject)

ApplyFunction
Qualified name: manim.animation.transform.ApplyFunction

class ApplyFunction(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Methods

create_target

Attributes

path_arc

path_func

Parameters:
function (types.MethodType)

mobject (Mobject)

ApplyMatrix
Qualified name: manim.animation.transform.ApplyMatrix

class ApplyMatrix(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyPointwiseFunction

Applies a matrix transform to an mobject.

Parameters:
matrix (np.ndarray) – The transformation matrix.

mobject (Mobject) – The Mobject.

about_point (np.ndarray) – The origin point for the transform. Defaults to ORIGIN.

kwargs – Further keyword arguments that are passed to ApplyPointwiseFunction.

Examples

Example: ApplyMatrixExample 

from manim import *

class ApplyMatrixExample(Scene):
    def construct(self):
        matrix = [[1, 1], [0, 2/3]]
        self.play(ApplyMatrix(matrix, Text("Hello World!")), ApplyMatrix(matrix, NumberPlane()))
Make interactive
Methods

initialize_matrix

Attributes

path_arc

path_func

ApplyMethod
Qualified name: manim.animation.transform.ApplyMethod

class ApplyMethod(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Animates a mobject by applying a method.

Note that only the method needs to be passed to this animation, it is not required to pass the corresponding mobject. Furthermore, this animation class only works if the method returns the modified mobject.

Parameters:
method (Callable) – The method that will be applied in the animation.

args – Any positional arguments to be passed when applying the method.

kwargs – Any keyword arguments passed to Transform.

Methods

check_validity_of_input

create_target

Attributes

path_arc

path_func

ApplyPointwiseFunction
Qualified name: manim.animation.transform.ApplyPointwiseFunction

class ApplyPointwiseFunction(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyMethod

Animation that applies a pointwise function to a mobject.

Examples

Example: WarpSquare 

from manim import *

class WarpSquare(Scene):
    def construct(self):
        square = Square()
        self.play(
            ApplyPointwiseFunction(
                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square
            )
        )
        self.wait()
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
function (types.MethodType)

mobject (Mobject)

run_time (float)

ApplyPointwiseFunctionToCenter
Qualified name: manim.animation.transform.ApplyPointwiseFunctionToCenter

class ApplyPointwiseFunctionToCenter(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyPointwiseFunction

Methods

begin

Begin the animation.

Attributes

path_arc

path_func

Parameters:
function (types.MethodType)

mobject (Mobject)

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

ClockwiseTransform
Qualified name: manim.animation.transform.ClockwiseTransform

class ClockwiseTransform(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Transforms the points of a mobject along a clockwise oriented arc.

See also

Transform, CounterclockwiseTransform

Examples

Example: ClockwiseExample 

from manim import *

class ClockwiseExample(Scene):
    def construct(self):
        dl, dr = Dot(), Dot()
        sl, sr = Square(), Square()

        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)
        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)

        self.add(dl, dr)
        self.wait()
        self.play(
            ClockwiseTransform(dl, sl),
            Transform(dr, sr)
        )
        self.wait()
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

target_mobject (Mobject)

path_arc (float)

CounterclockwiseTransform
Qualified name: manim.animation.transform.CounterclockwiseTransform

class CounterclockwiseTransform(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Transforms the points of a mobject along a counterclockwise oriented arc.

See also

Transform, ClockwiseTransform

Examples

Example: CounterclockwiseTransform_vs_Transform 

from manim import *

class CounterclockwiseTransform_vs_Transform(Scene):
    def construct(self):
        # set up the numbers
        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))
        text_1 = Text("CounterclockwiseTransform", color=RED)
        c_transform.add(text_1)

        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))
        text_2 = Text("Transform", color=BLUE)
        transform.add(text_2)

        ints = VGroup(c_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        c_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs move in clockwise direction for ClockwiseTransform()
        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))

        # The mobs move straight up for Transform()
        self.play(Transform(transform[0], transform[1]))
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

target_mobject (Mobject)

path_arc (float)

CyclicReplace
Qualified name: manim.animation.transform.CyclicReplace

class CyclicReplace(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

An animation moving mobjects cyclically.

In particular, this means: the first mobject takes the place of the second mobject, the second one takes the place of the third mobject, and so on. The last mobject takes the place of the first one.

Parameters:
mobjects (Mobject) – List of mobjects to be transformed.

path_arc (float) – The angle of the arc (in radians) that the mobjects will follow to reach their target.

kwargs – Further keyword arguments that are passed to Transform.

Examples

Example: CyclicReplaceExample 

from manim import *

class CyclicReplaceExample(Scene):
    def construct(self):
        group = VGroup(Square(), Circle(), Triangle(), Star())
        group.arrange(RIGHT)
        self.add(group)

        for _ in range(4):
            self.play(CyclicReplace(*group))
Make interactive
Methods

create_target

Attributes

path_arc

path_func

FadeToColor
Qualified name: manim.animation.transform.FadeToColor

class FadeToColor(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyMethod

Animation that changes color of a mobject.

Examples

Example: FadeToColorExample 

from manim import *

class FadeToColorExample(Scene):
    def construct(self):
        self.play(FadeToColor(Text("Hello World!"), color=RED))
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

color (str)

FadeTransform
Qualified name: manim.animation.transform.FadeTransform

class FadeTransform(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Fades one mobject into another.

Parameters:
mobject – The starting Mobject.

target_mobject – The target Mobject.

stretch – Controls whether the target Mobject is stretched during the animation. Default: True.

dim_to_match – If the target mobject is not stretched automatically, this allows to adjust the initial scale of the target Mobject while it is shifted in. Setting this to 0, 1, and 2, respectively, matches the length of the target with the length of the starting Mobject in x, y, and z direction, respectively.

kwargs – Further keyword arguments are passed to the parent class.

Examples

Example: DifferentFadeTransforms 

from manim import *

class DifferentFadeTransforms(Scene):
    def construct(self):
        starts = [Rectangle(width=4, height=1) for _ in range(3)]
        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)
        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]
        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)

        self.play(*[FadeIn(s) for s in starts])
        self.play(
            FadeTransform(starts[0], targets[0], stretch=True),
            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),
            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)
        )

        self.play(*[FadeOut(mobj) for mobj in self.mobjects])
Make interactive
Methods

begin

Initial setup for the animation.

clean_up_from_scene

Clean up the Scene after finishing the animation.

get_all_families_zipped

get_all_mobjects

Get all mobjects involved in the animation.

ghost_to

Replaces the source by the target and sets the opacity to 0.

Attributes

path_arc

path_func

begin()[source]
Initial setup for the animation.

The mobject to which this animation is bound is a group consisting of both the starting and the ending mobject. At the start, the ending mobject replaces the starting mobject (and is completely faded). In the end, it is set to be the other way around.

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene – The scene the animation should be cleaned up from.

get_all_mobjects()[source]
Get all mobjects involved in the animation.

Ordering must match the ordering of arguments to interpolate_submobject

Returns:
The sequence of mobjects.

Return type:
Sequence[Mobject]

ghost_to(source, target)[source]
Replaces the source by the target and sets the opacity to 0.

If the provided target has no points, and thus a location of [0, 0, 0] the source will simply fade out where it currently is.

FadeTransformPieces
Qualified name: manim.animation.transform.FadeTransformPieces

class FadeTransformPieces(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: FadeTransform

Fades submobjects of one mobject into submobjects of another one.

See also

FadeTransform

Examples

Example: FadeTransformSubmobjects 

from manim import *

class FadeTransformSubmobjects(Scene):
    def construct(self):
        src = VGroup(Square(), Circle().shift(LEFT + UP))
        src.shift(3*LEFT + 2*UP)
        src_copy = src.copy().shift(4*DOWN)

        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))
        target.shift(3*RIGHT + 2*UP)
        target_copy = target.copy().shift(4*DOWN)

        self.play(FadeIn(src), FadeIn(src_copy))
        self.play(
            FadeTransform(src, target),
            FadeTransformPieces(src_copy, target_copy)
        )
        self.play(*[FadeOut(mobj) for mobj in self.mobjects])
Make interactive
Methods

begin

Initial setup for the animation.

ghost_to

Replaces the source submobjects by the target submobjects and sets the opacity to 0.

Attributes

path_arc

path_func

begin()[source]
Initial setup for the animation.

The mobject to which this animation is bound is a group consisting of both the starting and the ending mobject. At the start, the ending mobject replaces the starting mobject (and is completely faded). In the end, it is set to be the other way around.

ghost_to(source, target)[source]
Replaces the source submobjects by the target submobjects and sets the opacity to 0.

MoveToTarget
Qualified name: manim.animation.transform.MoveToTarget

class MoveToTarget(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Transforms a mobject to the mobject stored in its target attribute.

After calling the generate_target() method, the target attribute of the mobject is populated with a copy of it. After modifying the attribute, playing the MoveToTarget animation transforms the original mobject into the modified one stored in the target attribute.

Examples

Example: MoveToTargetExample 

from manim import *

class MoveToTargetExample(Scene):
    def construct(self):
        c = Circle()

        c.generate_target()
        c.target.set_fill(color=GREEN, opacity=0.5)
        c.target.shift(2*RIGHT + UP).scale(0.5)

        self.add(c)
        self.play(MoveToTarget(c))
Make interactive
Methods

check_validity_of_input

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

ReplacementTransform
Qualified name: manim.animation.transform.ReplacementTransform

class ReplacementTransform(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Replaces and morphs a mobject into a target mobject.

Parameters:
mobject (Mobject) – The starting Mobject.

target_mobject (Mobject) – The target Mobject.

kwargs – Further keyword arguments that are passed to Transform.

Examples

Example: ReplacementTransformOrTransform 

from manim import *

class ReplacementTransformOrTransform(Scene):
    def construct(self):
        # set up the numbers
        r_transform = VGroup(*[Integer(i) for i in range(1,4)])
        text_1 = Text("ReplacementTransform", color=RED)
        r_transform.add(text_1)

        transform = VGroup(*[Integer(i) for i in range(4,7)])
        text_2 = Text("Transform", color=BLUE)
        transform.add(text_2)

        ints = VGroup(r_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        r_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs replace each other and none are left behind
        self.play(ReplacementTransform(r_transform[0], r_transform[1]))
        self.play(ReplacementTransform(r_transform[1], r_transform[2]))

        # The mobs linger after the Transform()
        self.play(Transform(transform[0], transform[1]))
        self.play(Transform(transform[1], transform[2]))
        self.wait()
Make interactive
Methods

Attributes

path_arc

path_func

Restore
Qualified name: manim.animation.transform.Restore

class Restore(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyMethod

Transforms a mobject to its last saved state.

To save the state of a mobject, use the save_state() method.

Examples

Example: RestoreExample 

from manim import *

class RestoreExample(Scene):
    def construct(self):
        s = Square()
        s.save_state()
        self.play(FadeIn(s))
        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))
        self.play(s.animate.shift(5*DOWN).rotate(PI/4))
        self.wait()
        self.play(Restore(s), run_time=2)
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

ScaleInPlace
Qualified name: manim.animation.transform.ScaleInPlace

class ScaleInPlace(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ApplyMethod

Animation that scales a mobject by a certain factor.

Examples

Example: ScaleInPlaceExample 

from manim import *

class ScaleInPlaceExample(Scene):
    def construct(self):
        self.play(ScaleInPlace(Text("Hello World!"), 2))
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

scale_factor (float)

ShrinkToCenter
Qualified name: manim.animation.transform.ShrinkToCenter

class ShrinkToCenter(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: ScaleInPlace

Animation that makes a mobject shrink to center.

Examples

Example: ShrinkToCenterExample 

from manim import *

class ShrinkToCenterExample(Scene):
    def construct(self):
        self.play(ShrinkToCenter(Text("Hello World!")))
Make interactive
Methods

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

Swap
Qualified name: manim.animation.transform.Swap

class Swap(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: CyclicReplace

Methods

Attributes

path_arc

path_func

Parameters:
mobjects (Mobject)

path_arc (float)

Transform
Qualified name: manim.animation.transform.Transform

class Transform(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

A Transform transforms a Mobject into a target Mobject.

Parameters:
mobject (Mobject | None) – The Mobject to be transformed. It will be mutated to become the target_mobject.

target_mobject (Mobject | None) – The target of the transformation.

path_func (Callable | None) – A function defining the path that the points of the mobject are being moved along until they match the points of the target_mobject, see utils.paths.

path_arc (float) – The arc angle (in radians) that the points of mobject will follow to reach the points of the target if using a circular path arc, see path_arc_centers. See also manim.utils.paths.path_along_arc().

path_arc_axis (np.ndarray) – The axis to rotate along if using a circular path arc, see path_arc_centers.

path_arc_centers (np.ndarray) –

The center of the circular arcs along which the points of mobject are moved by the transformation.

If this is set and path_func is not set, then a path_along_circles path will be generated using the path_arc parameters and stored in path_func. If path_func is set, this and the other path_arc fields are set as attributes, but a path_func is not generated from it.

replace_mobject_with_target_in_scene (bool) –

Controls which mobject is replaced when the transformation is complete.

If set to True, mobject will be removed from the scene and target_mobject will replace it. Otherwise, target_mobject is never added and mobject just takes its shape.

Examples

Example: TransformPathArc 

from manim import *

class TransformPathArc(Scene):
    def construct(self):
        def make_arc_path(start, end, arc_angle):
            points = []
            p_fn = path_along_arc(arc_angle)
            # alpha animates between 0.0 and 1.0, where 0.0
            # is the beginning of the animation and 1.0 is the end.
            for alpha in range(0, 11):
                points.append(p_fn(start, end, alpha / 10.0))
            path = VMobject(stroke_color=YELLOW)
            path.set_points_smoothly(points)
            return path

        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)
        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]
        # Positive angles move counter-clockwise, negative angles move clockwise.
        examples = [-90, 0, 30, 90, 180, 270]
        anims = []
        for idx, angle in enumerate(examples):
            left_c = left.copy().shift((3 - idx) * UP)
            left_c.fill_color = colors[idx]
            right_c = left_c.copy().shift(4 * RIGHT)
            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),
                                     arc_angle=angle * DEGREES)
            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)
            # Make the circles in front of the text in front of the arcs.
            self.add(
                path_arc.set_z_index(1),
                desc.set_z_index(2),
                left_c.set_z_index(3),
            )
            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))

        self.play(*anims, run_time=2)
        self.wait()
Make interactive
Methods

begin

Begin the animation.

clean_up_from_scene

Clean up the Scene after finishing the animation.

create_target

get_all_families_zipped

get_all_mobjects

Get all mobjects involved in the animation.

interpolate_submobject

Attributes

path_arc

path_func

begin()[source]
Begin the animation.

This method is called right as an animation is being played. As much initialization as possible, especially any mobject copying, should live in this method.

Return type:
None

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

get_all_mobjects()[source]
Get all mobjects involved in the animation.

Ordering must match the ordering of arguments to interpolate_submobject

Returns:
The sequence of mobjects.

Return type:
Sequence[Mobject]

TransformAnimations
Qualified name: manim.animation.transform.TransformAnimations

class TransformAnimations(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Methods

interpolate

Set the animation progress.

Attributes

path_arc

path_func

Parameters:
start_anim (Animation)

end_anim (Animation)

rate_func (Callable)

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

TransformFromCopy
Qualified name: manim.animation.transform.TransformFromCopy

class TransformFromCopy(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Transform

Performs a reversed Transform

Methods

interpolate

Set the animation progress.

Attributes

path_arc

path_func

Parameters:
mobject (Mobject)

target_mobject (Mobject)

interpolate(alpha)[source]
Set the animation progress.

This method gets called for every frame during an animation.

Parameters:
alpha (float) – The relative time to set the animation to, 0 meaning the start, 1 meaning the end.

Return type:
None

transform_matching_parts
Animations that try to transform Mobjects while keeping track of identical parts.

Classes

TransformMatchingAbstractBase

Abstract base class for transformations that keep track of matching parts.

TransformMatchingShapes

An animation trying to transform groups by matching the shape of their submobjects.

TransformMatchingTex

A transformation trying to transform rendered LaTeX strings.

TransformMatchingAbstractBase
Qualified name: manim.animation.transform\_matching\_parts.TransformMatchingAbstractBase

class TransformMatchingAbstractBase(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: AnimationGroup

Abstract base class for transformations that keep track of matching parts.

Subclasses have to implement the two static methods get_mobject_parts() and get_mobject_key().

Basically, this transformation first maps all submobjects returned by the get_mobject_parts method to certain keys by applying the get_mobject_key method. Then, submobjects with matching keys are transformed into each other.

Parameters:
mobject (Mobject) – The starting Mobject.

target_mobject (Mobject) – The target Mobject.

transform_mismatches (bool) – Controls whether submobjects without a matching key are transformed into each other by using Transform. Default: False.

fade_transform_mismatches (bool) – Controls whether submobjects without a matching key are transformed into each other by using FadeTransform. Default: False.

key_map (dict | None) – Optional. A dictionary mapping keys belonging to some of the starting mobject’s submobjects (i.e., the return values of the get_mobject_key method) to some keys belonging to the target mobject’s submobjects that should be transformed although the keys don’t match.

kwargs – All further keyword arguments are passed to the submobject transformations.

Note

If neither transform_mismatches nor fade_transform_mismatches are set to True, submobjects without matching keys in the starting mobject are faded out in the direction of the unmatched submobjects in the target mobject, and unmatched submobjects in the target mobject are faded in from the direction of the unmatched submobjects in the start mobject.

Methods

clean_up_from_scene

Clean up the Scene after finishing the animation.

get_mobject_key

get_mobject_parts

get_shape_map

clean_up_from_scene(scene)[source]
Clean up the Scene after finishing the animation.

This includes to remove() the Animation’s Mobject if the animation is a remover.

Parameters:
scene (Scene) – The scene the animation should be cleaned up from.

Return type:
None

TransformMatchingShapes
Qualified name: manim.animation.transform\_matching\_parts.TransformMatchingShapes

class TransformMatchingShapes(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: TransformMatchingAbstractBase

An animation trying to transform groups by matching the shape of their submobjects.

Two submobjects match if the hash of their point coordinates after normalization (i.e., after translation to the origin, fixing the submobject height at 1 unit, and rounding the coordinates to three decimal places) matches.

See also

TransformMatchingAbstractBase

Examples

Example: Anagram 

from manim import *

class Anagram(Scene):
    def construct(self):
        src = Text("the morse code")
        tar = Text("here come dots")
        self.play(Write(src))
        self.wait(0.5)
        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))
        self.wait(0.5)
Make interactive
Methods

get_mobject_key

get_mobject_parts

Parameters:
mobject (Mobject)

target_mobject (Mobject)

transform_mismatches (bool)

fade_transform_mismatches (bool)

key_map (dict | None)

TransformMatchingTex
Qualified name: manim.animation.transform\_matching\_parts.TransformMatchingTex

class TransformMatchingTex(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: TransformMatchingAbstractBase

A transformation trying to transform rendered LaTeX strings.

Two submobjects match if their tex_string matches.

See also

TransformMatchingAbstractBase

Examples

Example: MatchingEquationParts 

from manim import *

class MatchingEquationParts(Scene):
    def construct(self):
        variables = VGroup(MathTex("a"), MathTex("b"), MathTex("c")).arrange_submobjects().shift(UP)

        eq1 = MathTex("{{x}}^2", "+", "{{y}}^2", "=", "{{z}}^2")
        eq2 = MathTex("{{a}}^2", "+", "{{b}}^2", "=", "{{c}}^2")
        eq3 = MathTex("{{a}}^2", "=", "{{c}}^2", "-", "{{b}}^2")

        self.add(eq1)
        self.wait(0.5)
        self.play(TransformMatchingTex(Group(eq1, variables), eq2))
        self.wait(0.5)
        self.play(TransformMatchingTex(eq2, eq3))
        self.wait(0.5)
Make interactive
Methods

get_mobject_key

get_mobject_parts

Parameters:
mobject (Mobject)

target_mobject (Mobject)

transform_mismatches (bool)

fade_transform_mismatches (bool)

key_map (dict | None)

updaters
Animations and utility mobjects related to update functions.

Modules
mobject_update_utils

Utility functions for continuous animation of mobjects.

update

Animations that update mobjects.

mobject_update_utils
Utility functions for continuous animation of mobjects.

Functions

always(method, *args, **kwargs)[source]
Parameters:
method (Callable)

Return type:
Mobject

always_redraw(func)[source]
Redraw the mobject constructed by a function every frame.

This function returns a mobject with an attached updater that continuously regenerates the mobject according to the specified function.

Parameters:
func (Callable[[], Mobject]) – A function without (required) input arguments that returns a mobject.

Return type:
Mobject

Examples

Example: TangentAnimation 

from manim import *

class TangentAnimation(Scene):
    def construct(self):
        ax = Axes()
        sine = ax.plot(np.sin, color=RED)
        alpha = ValueTracker(0)
        point = always_redraw(
            lambda: Dot(
                sine.point_from_proportion(alpha.get_value()),
                color=BLUE
            )
        )
        tangent = always_redraw(
            lambda: TangentLine(
                sine,
                alpha=alpha.get_value(),
                color=YELLOW,
                length=4
            )
        )
        self.add(ax, sine, point, tangent)
        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)
Make interactive
always_rotate(mobject, rate=0.3490658503988659, **kwargs)[source]
A mobject which is continuously rotated at a certain rate.

Parameters:
mobject (Mobject) – The mobject to be rotated.

rate (float) – The angle which the mobject is rotated by over one second.

kwags – Further arguments to be passed to Mobject.rotate().

Return type:
Mobject

Examples

Example: SpinningTriangle 

from manim import *

class SpinningTriangle(Scene):
    def construct(self):
        tri = Triangle().set_fill(opacity=1).set_z_index(2)
        sq = Square().to_edge(LEFT)

        # will keep spinning while there is an animation going on
        always_rotate(tri, rate=2*PI, about_point=ORIGIN)

        self.add(tri, sq)
        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)
Make interactive
always_shift(mobject, direction=array([1., 0., 0.]), rate=0.1)[source]
A mobject which is continuously shifted along some direction at a certain rate.

Parameters:
mobject (Mobject) – The mobject to shift.

direction (ndarray[float64]) – The direction to shift. The vector is normalized, the specified magnitude is not relevant.

rate (float) – Length in Manim units which the mobject travels in one second along the specified direction.

Return type:
Mobject

Examples

Example: ShiftingSquare 

from manim import *

class ShiftingSquare(Scene):
    def construct(self):
        sq = Square().set_fill(opacity=1)
        tri = Triangle()
        VGroup(sq, tri).arrange(LEFT)

        # construct a square which is continuously
        # shifted to the right
        always_shift(sq, RIGHT, rate=5)

        self.add(sq)
        self.play(tri.animate.set_fill(opacity=1))
Make interactive
assert_is_mobject_method(method)[source]
Parameters:
method (Callable)

Return type:
None

cycle_animation(animation, **kwargs)[source]
Parameters:
animation (Animation)

Return type:
Mobject

f_always(method, *arg_generators, **kwargs)[source]
More functional version of always, where instead of taking in args, it takes in functions which output the relevant arguments.

Parameters:
method (Callable[[Mobject], None])

Return type:
Mobject

turn_animation_into_updater(animation, cycle=False, **kwargs)[source]
Add an updater to the animation’s mobject which applies the interpolation and update functions of the animation

If cycle is True, this repeats over and over. Otherwise, the updater will be popped upon completion

Examples

Example: WelcomeToManim 

from manim import *

class WelcomeToManim(Scene):
    def construct(self):
        words = Text("Welcome to")
        banner = ManimBanner().scale(0.5)
        VGroup(words, banner).arrange(DOWN)

        turn_animation_into_updater(Write(words, run_time=0.9))
        self.add(words)
        self.wait(0.5)
        self.play(banner.expand(), run_time=0.5)
Make interactive
Parameters:
animation (Animation)

cycle (bool)

Return type:
Mobject

update
Animations that update mobjects.

Classes

MaintainPositionRelativeTo

UpdateFromAlphaFunc

UpdateFromFunc

update_function of the form func(mobject), presumably to be used when the state of one mobject is dependent on another simultaneously animated mobject

MaintainPositionRelativeTo
Qualified name: manim.animation.updaters.update.MaintainPositionRelativeTo

class MaintainPositionRelativeTo(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
mobject (Mobject)

tracked_mobject (Mobject)

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

UpdateFromAlphaFunc
Qualified name: manim.animation.updaters.update.UpdateFromAlphaFunc

class UpdateFromAlphaFunc(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: UpdateFromFunc

Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
mobject (Mobject)

update_function (Callable[[Mobject], Any])

suspend_mobject_updating (bool)

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

UpdateFromFunc
Qualified name: manim.animation.updaters.update.UpdateFromFunc

class UpdateFromFunc(mobject=None, *args, use_override=True, **kwargs)[source]
Bases: Animation

update_function of the form func(mobject), presumably to be used when the state of one mobject is dependent on another simultaneously animated mobject

Methods

interpolate_mobject

Interpolates the mobject of the Animation based on alpha value.

Parameters:
mobject (Mobject)

update_function (Callable[[Mobject], Any])

suspend_mobject_updating (bool)

interpolate_mobject(alpha)[source]
Interpolates the mobject of the Animation based on alpha value.

Parameters:
alpha (float) – A float between 0 and 1 expressing the ratio to which the animation is completed. For example, alpha-values of 0, 0.5, and 1 correspond to the animation being completed 0%, 50%, and 100%, respectively.

Return type:
None

Cameras
camera

A camera converts the mobjects contained in a Scene into an array of pixels.

mapping_camera

A camera that allows mapping between objects.

moving_camera

A camera able to move through a scene.

multi_camera

A camera supporting multiple perspectives.

three_d_camera

A camera that can be positioned and oriented in three-dimensional space

camera
A camera converts the mobjects contained in a Scene into an array of pixels.

Classes

BackgroundColoredVMobjectDisplayer

Auxiliary class that handles displaying vectorized mobjects with a set background image.

Camera

Base camera class.

BackgroundColoredVMobjectDisplayer
Qualified name: manim.camera.camera.BackgroundColoredVMobjectDisplayer

class BackgroundColoredVMobjectDisplayer(camera)[source]
Bases: object

Auxiliary class that handles displaying vectorized mobjects with a set background image.

Parameters:
camera (Camera) – Camera object to use.

Methods

display

Displays the colored VMobjects.

get_background_array

Gets the background array that has the passed file_name.

reset_pixel_array

resize_background_array

Resizes the pixel array representing the background.

resize_background_array_to_match

Resizes the background array to match the passed pixel array.

display(*cvmobjects)[source]
Displays the colored VMobjects.

Parameters:
*cvmobjects (VMobject) – The VMobjects

Returns:
The pixel array with the cvmobjects displayed.

Return type:
np.array

get_background_array(image)[source]
Gets the background array that has the passed file_name.

Parameters:
image (Image.Image | pathlib.Path | str) – The background image or its file name.

Returns:
The pixel array of the image.

Return type:
np.ndarray

resize_background_array(background_array, new_width, new_height, mode='RGBA')[source]
Resizes the pixel array representing the background.

Parameters:
background_array (ndarray) – The pixel

new_width (float) – The new width of the background

new_height (float) – The new height of the background

mode (str) – The PIL image mode, by default “RGBA”

Returns:
The numpy pixel array of the resized background.

Return type:
np.array

resize_background_array_to_match(background_array, pixel_array)[source]
Resizes the background array to match the passed pixel array.

Parameters:
background_array (ndarray) – The prospective pixel array.

pixel_array (ndarray) – The pixel array whose width and height should be matched.

Returns:
The resized background array.

Return type:
np.array

Camera
Qualified name: manim.camera.camera.Camera

class Camera(background_image=None, frame_center=array([0., 0., 0.]), image_mode='RGBA', n_channels=4, pixel_array_dtype='uint8', cairo_line_width_multiple=0.01, use_z_index=True, background=None, pixel_height=None, pixel_width=None, frame_height=None, frame_width=None, frame_rate=None, background_color=None, background_opacity=None, **kwargs)[source]
Bases: object

Base camera class.

This is the object which takes care of what exactly is displayed on screen at any given moment.

Parameters:
background_image (str | None) – The path to an image that should be the background image. If not set, the background is filled with self.background_color

background (np.ndarray | None) – What background is set to. By default, None.

pixel_height (int | None) – The height of the scene in pixels.

pixel_width (int | None) – The width of the scene in pixels.

kwargs – Additional arguments (background_color, background_opacity) to be set.

frame_center (np.ndarray)

image_mode (str)

n_channels (int)

pixel_array_dtype (str)

cairo_line_width_multiple (float)

use_z_index (bool)

frame_height (float | None)

frame_width (float | None)

frame_rate (float | None)

background_color (ParsableManimColor | None)

background_opacity (float | None)

Methods

adjust_out_of_range_points

If any of the points in the passed array are out of the viable range, they are adjusted suitably.

adjusted_thickness

Computes the adjusted stroke width for a zoomed camera.

apply_fill

Fills the cairo context

apply_stroke

Applies a stroke to the VMobject in the cairo context.

cache_cairo_context

Caches the passed Pixel array into a Cairo Context

capture_mobject

Capture mobjects by storing it in pixel_array.

capture_mobjects

Capture mobjects by printing them on pixel_array.

convert_pixel_array

Converts a pixel array from values that have floats in then to proper RGB values.

display_image_mobject

Displays an ImageMobject by changing the pixel_array suitably.

display_multiple_background_colored_vmobjects

Displays multiple vmobjects that have the same color as the background.

display_multiple_image_mobjects

Displays multiple image mobjects by modifying the passed pixel_array.

display_multiple_non_background_colored_vmobjects

Displays multiple VMobjects in the cairo context, as long as they don't have background colors.

display_multiple_point_cloud_mobjects

Displays multiple PMobjects by modifying the passed pixel array.

display_multiple_vectorized_mobjects

Displays multiple VMobjects in the pixel_array

display_point_cloud

Displays a PMobject by modifying the pixel array suitably.

display_vectorized

Displays a VMobject in the cairo context

get_background_colored_vmobject_displayer

Returns the background_colored_vmobject_displayer if it exists or makes one and returns it if not.

get_cached_cairo_context

Returns the cached cairo context of the passed pixel array if it exists, and None if it doesn't.

get_cairo_context

Returns the cairo context for a pixel array after caching it to self.pixel_array_to_cairo_context If that array has already been cached, it returns the cached version instead.

get_coords_of_all_pixels

Returns the cartesian coordinates of each pixel.

get_fill_rgbas

Returns the RGBA array of the fill of the passed VMobject

get_image

Returns an image from the passed pixel array, or from the current frame if the passed pixel array is none.

get_mobjects_to_display

Used to get the list of mobjects to display with the camera.

get_stroke_rgbas

Gets the RGBA array for the stroke of the passed VMobject.

get_thickening_nudges

Determine a list of vectors used to nudge two-dimensional pixel coordinates.

init_background

Initialize the background.

is_in_frame

Checks whether the passed mobject is in frame or not.

make_background_from_func

Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color.

on_screen_pixels

Returns array of pixels that are on the screen from a given array of pixel_coordinates

overlay_PIL_image

Overlays a PIL image on the passed pixel array.

overlay_rgba_array

Overlays an RGBA array on top of the given Pixel array.

points_to_pixel_coords

reset

Resets the camera's pixel array to that of the background

reset_pixel_shape

This method resets the height and width of a single pixel to the passed new_height and new_width.

resize_frame_shape

Changes frame_shape to match the aspect ratio of the pixels, where fixed_dimension determines whether frame_height or frame_width remains fixed while the other changes accordingly.

set_background

Sets the background to the passed pixel_array after converting to valid RGB values.

set_background_from_func

Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color.

set_cairo_context_color

Sets the color of the cairo context

set_cairo_context_path

Sets a path for the cairo context with the vmobject passed

set_frame_to_background

set_pixel_array

Sets the pixel array of the camera to the passed pixel array.

thickened_coordinates

Returns thickened coordinates for a passed array of pixel coords and a thickness to thicken by.

transform_points_pre_display

type_or_raise

Return the type of mobject, if it is a type that can be rendered.

Attributes

background_color

background_opacity

adjust_out_of_range_points(points)[source]
If any of the points in the passed array are out of the viable range, they are adjusted suitably.

Parameters:
points (ndarray) – The points to adjust

Returns:
The adjusted points.

Return type:
np.array

adjusted_thickness(thickness)[source]
Computes the adjusted stroke width for a zoomed camera.

Parameters:
thickness (float) – The stroke width of a mobject.

Returns:
The adjusted stroke width that reflects zooming in with the camera.

Return type:
float

apply_fill(ctx, vmobject)[source]
Fills the cairo context

Parameters:
ctx (Context) – The cairo context

vmobject (VMobject) – The VMobject

Returns:
The camera object.

Return type:
Camera

apply_stroke(ctx, vmobject, background=False)[source]
Applies a stroke to the VMobject in the cairo context.

Parameters:
ctx (Context) – The cairo context

vmobject (VMobject) – The VMobject

background (bool) – Whether or not to consider the background when applying this stroke width, by default False

Returns:
The camera object with the stroke applied.

Return type:
Camera

cache_cairo_context(pixel_array, ctx)[source]
Caches the passed Pixel array into a Cairo Context

Parameters:
pixel_array (ndarray) – The pixel array to cache

ctx (Context) – The context to cache it into.

capture_mobject(mobject, **kwargs)[source]
Capture mobjects by storing it in pixel_array.

This is a single-mobject version of capture_mobjects().

Parameters:
mobject (Mobject) – Mobject to capture.

kwargs (Any) – Keyword arguments to be passed to get_mobjects_to_display().

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects (Iterable[Mobject]) – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

convert_pixel_array(pixel_array, convert_from_floats=False)[source]
Converts a pixel array from values that have floats in then to proper RGB values.

Parameters:
pixel_array (ndarray | list | tuple) – Pixel array to convert.

convert_from_floats (bool) – Whether or not to convert float values to ints, by default False

Returns:
The new, converted pixel array.

Return type:
np.array

display_image_mobject(image_mobject, pixel_array)[source]
Displays an ImageMobject by changing the pixel_array suitably.

Parameters:
image_mobject (AbstractImageMobject) – The imageMobject to display

pixel_array (ndarray) – The Pixel array to put the imagemobject in.

display_multiple_background_colored_vmobjects(cvmobjects, pixel_array)[source]
Displays multiple vmobjects that have the same color as the background.

Parameters:
cvmobjects (list) – List of Colored VMobjects

pixel_array (ndarray) – The pixel array.

Returns:
The camera object.

Return type:
Camera

display_multiple_image_mobjects(image_mobjects, pixel_array)[source]
Displays multiple image mobjects by modifying the passed pixel_array.

Parameters:
image_mobjects (list) – list of ImageMobjects

pixel_array (ndarray) – The pixel array to modify.

display_multiple_non_background_colored_vmobjects(vmobjects, pixel_array)[source]
Displays multiple VMobjects in the cairo context, as long as they don’t have background colors.

Parameters:
vmobjects (list) – list of the VMobjects

pixel_array (ndarray) – The Pixel array to add the VMobjects to.

display_multiple_point_cloud_mobjects(pmobjects, pixel_array)[source]
Displays multiple PMobjects by modifying the passed pixel array.

Parameters:
pmobjects (list) – List of PMobjects

pixel_array (ndarray) – The pixel array to modify.

display_multiple_vectorized_mobjects(vmobjects, pixel_array)[source]
Displays multiple VMobjects in the pixel_array

Parameters:
vmobjects (list) – list of VMobjects to display

pixel_array (ndarray) – The pixel array

display_point_cloud(pmobject, points, rgbas, thickness, pixel_array)[source]
Displays a PMobject by modifying the pixel array suitably.

TODO: Write a description for the rgbas argument.

Parameters:
pmobject (PMobject) – Point Cloud Mobject

points (list) – The points to display in the point cloud mobject

rgbas (ndarray)

thickness (float) – The thickness of each point of the PMobject

pixel_array (ndarray) – The pixel array to modify.

display_vectorized(vmobject, ctx)[source]
Displays a VMobject in the cairo context

Parameters:
vmobject (VMobject) – The Vectorized Mobject to display

ctx (Context) – The cairo context to use.

Returns:
The camera object

Return type:
Camera

get_background_colored_vmobject_displayer()[source]
Returns the background_colored_vmobject_displayer if it exists or makes one and returns it if not.

Returns:
Object that displays VMobjects that have the same color as the background.

Return type:
BackGroundColoredVMobjectDisplayer

get_cached_cairo_context(pixel_array)[source]
Returns the cached cairo context of the passed pixel array if it exists, and None if it doesn’t.

Parameters:
pixel_array (ndarray) – The pixel array to check.

Returns:
The cached cairo context.

Return type:
cairo.Context

get_cairo_context(pixel_array)[source]
Returns the cairo context for a pixel array after caching it to self.pixel_array_to_cairo_context If that array has already been cached, it returns the cached version instead.

Parameters:
pixel_array (ndarray) – The Pixel array to get the cairo context of.

Returns:
The cairo context of the pixel array.

Return type:
cairo.Context

get_coords_of_all_pixels()[source]
Returns the cartesian coordinates of each pixel.

Returns:
The array of cartesian coordinates.

Return type:
np.ndarray

get_fill_rgbas(vmobject)[source]
Returns the RGBA array of the fill of the passed VMobject

Parameters:
vmobject (VMobject) – The VMobject

Returns:
The RGBA Array of the fill of the VMobject

Return type:
np.array

get_image(pixel_array=None)[source]
Returns an image from the passed pixel array, or from the current frame if the passed pixel array is none.

Parameters:
pixel_array (ndarray | list | tuple | None) – The pixel array from which to get an image, by default None

Returns:
The PIL image of the array.

Return type:
PIL.Image

get_mobjects_to_display(mobjects, include_submobjects=True, excluded_mobjects=None)[source]
Used to get the list of mobjects to display with the camera.

Parameters:
mobjects (Iterable[Mobject]) – The Mobjects

include_submobjects (bool) – Whether or not to include the submobjects of mobjects, by default True

excluded_mobjects (list | None) – Any mobjects to exclude, by default None

Returns:
list of mobjects

Return type:
list

get_stroke_rgbas(vmobject, background=False)[source]
Gets the RGBA array for the stroke of the passed VMobject.

Parameters:
vmobject (VMobject) – The VMobject

background (bool) – Whether or not to consider the background when getting the stroke RGBAs, by default False

Returns:
The RGBA array of the stroke.

Return type:
np.ndarray

get_thickening_nudges(thickness)[source]
Determine a list of vectors used to nudge two-dimensional pixel coordinates.

Parameters:
thickness (float)

Return type:
np.array

init_background()[source]
Initialize the background. If self.background_image is the path of an image the image is set as background; else, the default background color fills the background.

is_in_frame(mobject)[source]
Checks whether the passed mobject is in frame or not.

Parameters:
mobject (Mobject) – The mobject for which the checking needs to be done.

Returns:
True if in frame, False otherwise.

Return type:
bool

make_background_from_func(coords_to_colors_func)[source]
Makes a pixel array for the background by using coords_to_colors_func to determine each pixel’s color. Each input pixel’s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not pixel coordinates), and each output is expected to be an RGBA array of 4 floats.

Parameters:
coords_to_colors_func (Callable[[ndarray], ndarray]) – The function whose input is an (x,y) pair of coordinates and whose return values must be the colors for that point

Returns:
The pixel array which can then be passed to set_background.

Return type:
np.array

on_screen_pixels(pixel_coords)[source]
Returns array of pixels that are on the screen from a given array of pixel_coordinates

Parameters:
pixel_coords (ndarray) – The pixel coords to check.

Returns:
The pixel coords on screen.

Return type:
np.array

overlay_PIL_image(pixel_array, image)[source]
Overlays a PIL image on the passed pixel array.

Parameters:
pixel_array (ndarray) – The Pixel array

image (Image) – The Image to overlay.

overlay_rgba_array(pixel_array, new_array)[source]
Overlays an RGBA array on top of the given Pixel array.

Parameters:
pixel_array (ndarray) – The original pixel array to modify.

new_array (ndarray) – The new pixel array to overlay.

reset()[source]
Resets the camera’s pixel array to that of the background

Returns:
The camera object after setting the pixel array.

Return type:
Camera

reset_pixel_shape(new_height, new_width)[source]
This method resets the height and width of a single pixel to the passed new_height and new_width.

Parameters:
new_height (float) – The new height of the entire scene in pixels

new_width (float) – The new width of the entire scene in pixels

resize_frame_shape(fixed_dimension=0)[source]
Changes frame_shape to match the aspect ratio of the pixels, where fixed_dimension determines whether frame_height or frame_width remains fixed while the other changes accordingly.

Parameters:
fixed_dimension (int) – If 0, height is scaled with respect to width else, width is scaled with respect to height.

set_background(pixel_array, convert_from_floats=False)[source]
Sets the background to the passed pixel_array after converting to valid RGB values.

Parameters:
pixel_array (ndarray | list | tuple) – The pixel array to set the background to.

convert_from_floats (bool) – Whether or not to convert floats values to proper RGB valid ones, by default False

set_background_from_func(coords_to_colors_func)[source]
Sets the background to a pixel array using coords_to_colors_func to determine each pixel’s color. Each input pixel’s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not pixel coordinates), and each output is expected to be an RGBA array of 4 floats.

Parameters:
coords_to_colors_func (Callable[[ndarray], ndarray]) – The function whose input is an (x,y) pair of coordinates and whose return values must be the colors for that point

set_cairo_context_color(ctx, rgbas, vmobject)[source]
Sets the color of the cairo context

Parameters:
ctx (Context) – The cairo context

rgbas (ndarray) – The RGBA array with which to color the context.

vmobject (VMobject) – The VMobject with which to set the color.

Returns:
The camera object

Return type:
Camera

set_cairo_context_path(ctx, vmobject)[source]
Sets a path for the cairo context with the vmobject passed

Parameters:
ctx (Context) – The cairo context

vmobject (VMobject) – The VMobject

Returns:
Camera object after setting cairo_context_path

Return type:
Camera

set_pixel_array(pixel_array, convert_from_floats=False)[source]
Sets the pixel array of the camera to the passed pixel array.

Parameters:
pixel_array (ndarray | list | tuple) – The pixel array to convert and then set as the camera’s pixel array.

convert_from_floats (bool) – Whether or not to convert float values to proper RGB values, by default False

thickened_coordinates(pixel_coords, thickness)[source]
Returns thickened coordinates for a passed array of pixel coords and a thickness to thicken by.

Parameters:
pixel_coords (ndarray) – Pixel coordinates

thickness (float) – Thickness

Returns:
Array of thickened pixel coords.

Return type:
np.array

type_or_raise(mobject)[source]
Return the type of mobject, if it is a type that can be rendered.

If mobject is an instance of a class that inherits from a class that can be rendered, return the super class. For example, an instance of a Square is also an instance of VMobject, and these can be rendered. Therefore, type_or_raise(Square()) returns True.

Parameters:
mobject (Mobject) – The object to take the type of.

Notes

For a list of classes that can currently be rendered, see display_funcs().

Returns:
The type of mobjects, if it can be rendered.

Return type:
Type[Mobject]

Raises:
TypeError – When mobject is not an instance of a class that can be rendered.

Parameters:
mobject (Mobject)

mapping_camera
A camera that allows mapping between objects.

Classes

MappingCamera

Camera object that allows mapping between objects.

OldMultiCamera

SplitScreenCamera

MappingCamera
Qualified name: manim.camera.mapping\_camera.MappingCamera

class MappingCamera(mapping_func=<function MappingCamera.<lambda>>, min_num_curves=50, allow_object_intrusion=False, **kwargs)[source]
Bases: Camera

Camera object that allows mapping between objects.

Methods

capture_mobjects

Capture mobjects by printing them on pixel_array.

points_to_pixel_coords

Attributes

background_color

background_opacity

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

OldMultiCamera
Qualified name: manim.camera.mapping\_camera.OldMultiCamera

class OldMultiCamera(*cameras_with_start_positions, **kwargs)[source]
Bases: Camera

Methods

capture_mobjects

Capture mobjects by printing them on pixel_array.

init_background

Initialize the background.

set_background

Sets the background to the passed pixel_array after converting to valid RGB values.

set_pixel_array

Sets the pixel array of the camera to the passed pixel array.

Attributes

background_color

background_opacity

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

init_background()[source]
Initialize the background. If self.background_image is the path of an image the image is set as background; else, the default background color fills the background.

set_background(pixel_array, **kwargs)[source]
Sets the background to the passed pixel_array after converting to valid RGB values.

Parameters:
pixel_array – The pixel array to set the background to.

convert_from_floats – Whether or not to convert floats values to proper RGB valid ones, by default False

set_pixel_array(pixel_array, **kwargs)[source]
Sets the pixel array of the camera to the passed pixel array.

Parameters:
pixel_array – The pixel array to convert and then set as the camera’s pixel array.

convert_from_floats – Whether or not to convert float values to proper RGB values, by default False

SplitScreenCamera
Qualified name: manim.camera.mapping\_camera.SplitScreenCamera

class SplitScreenCamera(left_camera, right_camera, **kwargs)[source]
Bases: OldMultiCamera

Methods

Attributes

background_color

background_opacity

moving_camera
A camera able to move through a scene.

See also

moving_camera_scene

Classes

MovingCamera

Stays in line with the height, width and position of it's 'frame', which is a Rectangle

MovingCamera
Qualified name: manim.camera.moving\_camera.MovingCamera

class MovingCamera(frame=None, fixed_dimension=0, default_frame_stroke_color=ManimColor('#FFFFFF'), default_frame_stroke_width=0, **kwargs)[source]
Bases: Camera

Stays in line with the height, width and position of it’s ‘frame’, which is a Rectangle

See also

MovingCameraScene

Frame is a Mobject, (should almost certainly be a rectangle) determining which region of space the camera displays

Methods

auto_zoom

Zooms on to a given array of mobjects (or a singular mobject) and automatically resizes to frame all the mobjects.

cache_cairo_context

Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame.

capture_mobjects

Capture mobjects by printing them on pixel_array.

get_cached_cairo_context

Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame.

get_mobjects_indicating_movement

Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving

Attributes

background_color

background_opacity

frame_center

Returns the centerpoint of the frame in cartesian coordinates.

frame_height

Returns the height of the frame.

frame_width

Returns the width of the frame

auto_zoom(mobjects, margin=0, only_mobjects_in_frame=False, animate=True)[source]
Zooms on to a given array of mobjects (or a singular mobject) and automatically resizes to frame all the mobjects.

Note

This method only works when 2D-objects in the XY-plane are considered, it will not work correctly when the camera has been rotated.

Parameters:
mobjects (list[Mobject]) – The mobject or array of mobjects that the camera will focus on.

margin (float) – The width of the margin that is added to the frame (optional, 0 by default).

only_mobjects_in_frame (bool) – If set to True, only allows focusing on mobjects that are already in frame.

animate (bool) – If set to False, applies the changes instead of returning the corresponding animation

Returns:
_AnimationBuilder that zooms the camera view to a given list of mobjects or ScreenRectangle with position and size updated to zoomed position.

Return type:
Union[_AnimationBuilder, ScreenRectangle]

cache_cairo_context(pixel_array, ctx)[source]
Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. So no caching.

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

property frame_center
Returns the centerpoint of the frame in cartesian coordinates.

Returns:
The cartesian coordinates of the center of the frame.

Return type:
np.array

property frame_height
Returns the height of the frame.

Returns:
The height of the frame.

Return type:
float

property frame_width
Returns the width of the frame

Returns:
The width of the frame.

Return type:
float

get_cached_cairo_context(pixel_array)[source]
Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. So no caching.

get_mobjects_indicating_movement()[source]
Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving

Return type:
list

multi_camera
A camera supporting multiple perspectives.

Classes

MultiCamera

Camera Object that allows for multiple perspectives.

MultiCamera
Qualified name: manim.camera.multi\_camera.MultiCamera

class MultiCamera(image_mobjects_from_cameras=None, allow_cameras_to_capture_their_own_display=False, **kwargs)[source]
Bases: MovingCamera

Camera Object that allows for multiple perspectives.

Initialises the MultiCamera

Parameters:
image_mobjects_from_cameras (ImageMobject | None)

kwargs – Any valid keyword arguments of MovingCamera.

Methods

add_image_mobject_from_camera

Adds an ImageMobject that's been obtained from the camera into the list self.image_mobject_from_cameras

capture_mobjects

Capture mobjects by printing them on pixel_array.

get_mobjects_indicating_movement

Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving

reset

Resets the MultiCamera.

update_sub_cameras

Reshape sub_camera pixel_arrays

Attributes

background_color

background_opacity

frame_center

Returns the centerpoint of the frame in cartesian coordinates.

frame_height

Returns the height of the frame.

frame_width

Returns the width of the frame

add_image_mobject_from_camera(image_mobject_from_camera)[source]
Adds an ImageMobject that’s been obtained from the camera into the list self.image_mobject_from_cameras

Parameters:
image_mobject_from_camera (ImageMobject) – The ImageMobject to add to self.image_mobject_from_cameras

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

get_mobjects_indicating_movement()[source]
Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving

Return type:
list

reset()[source]
Resets the MultiCamera.

Returns:
The reset MultiCamera

Return type:
MultiCamera

update_sub_cameras()[source]
Reshape sub_camera pixel_arrays

three_d_camera
A camera that can be positioned and oriented in three-dimensional space.

Classes

ThreeDCamera

Initializes the ThreeDCamera

ThreeDCamera
Qualified name: manim.camera.three\_d\_camera.ThreeDCamera

class ThreeDCamera(focal_distance=20.0, shading_factor=0.2, default_distance=5.0, light_source_start_point=array([-7., -9., 10.]), should_apply_shading=True, exponential_projection=False, phi=0, theta=-1.5707963267948966, gamma=0, zoom=1, **kwargs)[source]
Bases: Camera

Initializes the ThreeDCamera

Parameters:
*kwargs – Any keyword argument of Camera.

Methods

add_fixed_in_frame_mobjects

This method allows the mobject to have a fixed position, even when the camera moves around.

add_fixed_orientation_mobjects

This method allows the mobject to have a fixed orientation, even when the camera moves around.

capture_mobjects

Capture mobjects by printing them on pixel_array.

generate_rotation_matrix

Generates a rotation matrix based off the current position of the camera.

get_fill_rgbas

Returns the RGBA array of the fill of the passed VMobject

get_focal_distance

Returns focal_distance of the Camera.

get_gamma

Returns the rotation of the camera about the vector from the ORIGIN to the Camera.

get_mobjects_to_display

Used to get the list of mobjects to display with the camera.

get_phi

Returns the Polar angle (the angle off Z_AXIS) phi.

get_rotation_matrix

Returns the matrix corresponding to the current position of the camera.

get_stroke_rgbas

Gets the RGBA array for the stroke of the passed VMobject.

get_theta

Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.

get_value_trackers

A list of ValueTrackers of phi, theta, focal_distance, gamma and zoom.

get_zoom

Returns the zoom amount of the camera.

modified_rgbas

project_point

Applies the current rotation_matrix as a projection matrix to the passed point.

project_points

Applies the current rotation_matrix as a projection matrix to the passed array of points.

remove_fixed_in_frame_mobjects

If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects(), then this undoes that fixing.

remove_fixed_orientation_mobjects

If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects(), then this undoes that fixing.

reset_rotation_matrix

Sets the value of self.rotation_matrix to the matrix corresponding to the current position of the camera

set_focal_distance

Sets the focal_distance of the Camera.

set_gamma

Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.

set_phi

Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.

set_theta

Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.

set_zoom

Sets the zoom amount of the camera.

transform_points_pre_display

Attributes

background_color

background_opacity

frame_center

add_fixed_in_frame_mobjects(*mobjects)[source]
This method allows the mobject to have a fixed position, even when the camera moves around. E.G If it was passed through this method, at the top of the frame, it will continue to be displayed at the top of the frame.

Highly useful when displaying Titles or formulae or the like.

Parameters:
**mobjects (Mobject) – The mobject to fix in frame.

add_fixed_orientation_mobjects(*mobjects, use_static_center_func=False, center_func=None)[source]
This method allows the mobject to have a fixed orientation, even when the camera moves around. E.G If it was passed through this method, facing the camera, it will continue to face the camera even as the camera moves. Highly useful when adding labels to graphs and the like.

Parameters:
*mobjects (Mobject) – The mobject whose orientation must be fixed.

use_static_center_func (bool) – Whether or not to use the function that takes the mobject’s center as centerpoint, by default False

center_func (Callable[[], ndarray] | None) – The function which returns the centerpoint with respect to which the mobject will be oriented, by default None

capture_mobjects(mobjects, **kwargs)[source]
Capture mobjects by printing them on pixel_array.

This is the essential function that converts the contents of a Scene into an array, which is then converted to an image or video.

Parameters:
mobjects – Mobjects to capture.

kwargs – Keyword arguments to be passed to get_mobjects_to_display().

Notes

For a list of classes that can currently be rendered, see display_funcs().

generate_rotation_matrix()[source]
Generates a rotation matrix based off the current position of the camera.

Returns:
The matrix corresponding to the current position of the camera.

Return type:
np.array

get_fill_rgbas(vmobject)[source]
Returns the RGBA array of the fill of the passed VMobject

Parameters:
vmobject – The VMobject

Returns:
The RGBA Array of the fill of the VMobject

Return type:
np.array

get_focal_distance()[source]
Returns focal_distance of the Camera.

Returns:
The focal_distance of the Camera in MUnits.

Return type:
float

get_gamma()[source]
Returns the rotation of the camera about the vector from the ORIGIN to the Camera.

Returns:
The angle of rotation of the camera about the vector from the ORIGIN to the Camera in radians

Return type:
float

get_mobjects_to_display(*args, **kwargs)[source]
Used to get the list of mobjects to display with the camera.

Parameters:
mobjects – The Mobjects

include_submobjects – Whether or not to include the submobjects of mobjects, by default True

excluded_mobjects – Any mobjects to exclude, by default None

Returns:
list of mobjects

Return type:
list

get_phi()[source]
Returns the Polar angle (the angle off Z_AXIS) phi.

Returns:
The Polar angle in radians.

Return type:
float

get_rotation_matrix()[source]
Returns the matrix corresponding to the current position of the camera.

Returns:
The matrix corresponding to the current position of the camera.

Return type:
np.array

get_stroke_rgbas(vmobject, background=False)[source]
Gets the RGBA array for the stroke of the passed VMobject.

Parameters:
vmobject – The VMobject

background – Whether or not to consider the background when getting the stroke RGBAs, by default False

Returns:
The RGBA array of the stroke.

Return type:
np.ndarray

get_theta()[source]
Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.

Returns:
The Azimuthal angle in radians.

Return type:
float

get_value_trackers()[source]
A list of ValueTrackers of phi, theta, focal_distance, gamma and zoom.

Returns:
list of ValueTracker objects

Return type:
list

get_zoom()[source]
Returns the zoom amount of the camera.

Returns:
The zoom amount of the camera.

Return type:
float

project_point(point)[source]
Applies the current rotation_matrix as a projection matrix to the passed point.

Parameters:
point (list | ndarray) – The point to project.

Returns:
The point after projection.

Return type:
np.array

project_points(points)[source]
Applies the current rotation_matrix as a projection matrix to the passed array of points.

Parameters:
points (ndarray | list) – The list of points to project.

Returns:
The points after projecting.

Return type:
np.array

remove_fixed_in_frame_mobjects(*mobjects)[source]
If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects(), then this undoes that fixing. The Mobject will no longer be fixed in frame.

Parameters:
mobjects (Mobject) – The mobjects which need not be fixed in frame any longer.

remove_fixed_orientation_mobjects(*mobjects)[source]
If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects(), then this undoes that fixing. The Mobject will no longer have a fixed orientation.

Parameters:
mobjects (Mobject) – The mobjects whose orientation need not be fixed any longer.

reset_rotation_matrix()[source]
Sets the value of self.rotation_matrix to the matrix corresponding to the current position of the camera

set_focal_distance(value)[source]
Sets the focal_distance of the Camera.

Parameters:
value (float) – The focal_distance of the Camera.

set_gamma(value)[source]
Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.

Parameters:
value (float) – The new angle of rotation of the camera.

set_phi(value)[source]
Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.

Parameters:
value (float) – The new value of the polar angle in radians.

set_theta(value)[source]
Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.

Parameters:
value (float) – The new value of the azimuthal angle in radians.

set_zoom(value)[source]
Sets the zoom amount of the camera.

Parameters:
value (float) – The zoom amount of the camera.

Configuration
Module Index
_config

Set the global config and logger.

utils

Utilities to create and set the config.

logger_utils

Utilities to create and set the logger.

_config
Set the global config and logger.

Functions

tempconfig(temp)[source]
Context manager that temporarily modifies the global config object.

Inside the with statement, the modified config will be used. After context manager exits, the config will be restored to its original state.

Parameters:
temp (ManimConfig | dict[str, Any]) – Object whose keys will be used to temporarily update the global config.

Return type:
Generator[None, None, None]

Examples

Use with tempconfig({...}) to temporarily change the default values of certain config options.

config["frame_height"]
8.0
with tempconfig({"frame_height": 100.0}):
    print(config["frame_height"])

100.0
config["frame_height"]
8.0

utils
Utilities to create and set the config.

The main class exported by this module is ManimConfig. This class contains all configuration options, including frame geometry (e.g. frame height/width, frame rate), output (e.g. directories, logging), styling (e.g. background color, transparency), and general behavior (e.g. writing a movie vs writing a single frame).

See Configuration for an introduction to Manim’s configuration system.

Classes

ManimConfig

Dict-like class storing all config options.

ManimFrame

Functions

config_file_paths()[source]
The paths where .cfg files will be searched for.

When manim is first imported, it processes any .cfg files it finds. This function returns the locations in which these files are searched for. In ascending order of precedence, these are: the library-wide config file, the user-wide config file, and the folder-wide config file.

The library-wide config file determines manim’s default behavior. The user-wide config file is stored in the user’s home folder, and determines the behavior of manim whenever the user invokes it from anywhere in the system. The folder-wide config file only affects scenes that are in the same folder. The latter two files are optional.

These files, if they exist, are meant to loaded into a single configparser.ConfigParser object, and then processed by ManimConfig.

Returns:
List of paths which may contain .cfg files, in ascending order of precedence.

Return type:
List[Path]

See also

make_config_parser(), ManimConfig.digest_file(), ManimConfig.digest_parser()

Notes

The location of the user-wide config file is OS-specific.

make_config_parser(custom_file=None)[source]
Make a ConfigParser object and load any .cfg files.

The user-wide file, if it exists, overrides the library-wide file. The folder-wide file, if it exists, overrides the other two.

The folder-wide file can be ignored by passing custom_file. However, the user-wide and library-wide config files cannot be ignored.

Parameters:
custom_file (StrPath | None) – Path to a custom config file. If used, the folder-wide file in the relevant directory will be ignored, if it exists. If None, the folder-wide file will be used, if it exists.

Returns:
A parser containing the config options found in the .cfg files that were found. It is guaranteed to contain at least the config options found in the library-wide file.

Return type:
ConfigParser

See also

config_file_paths()

ManimConfig
Qualified name: manim.\_config.utils.ManimConfig

class ManimConfig[source]
Bases: MutableMapping

Dict-like class storing all config options.

The global config object is an instance of this class, and acts as a single source of truth for all of the library’s customizable behavior.

The global config object is capable of digesting different types of sources and converting them into a uniform interface. These sources are (in ascending order of precedence): configuration files, command line arguments, and programmatic changes. Regardless of how the user chooses to set a config option, she can access its current value using ManimConfig’s attributes and properties.

Notes

Each config option is implemented as a property of this class.

Each config option can be set via a config file, using the full name of the property. If a config option has an associated CLI flag, then the flag is equal to the full name of the property. Those that admit an alternative flag or no flag at all are documented in the individual property’s docstring.

Examples

We use a copy of the global configuration object in the following examples for the sake of demonstration; you can skip these lines and just import config directly if you actually want to modify the configuration:

from manim import config as global_config
config = global_config.copy()
Each config option allows for dict syntax and attribute syntax. For example, the following two lines are equivalent,

from manim import WHITE
config.background_color = WHITE
config["background_color"] = WHITE
The former is preferred; the latter is provided mostly for backwards compatibility.

The config options are designed to keep internal consistency. For example, setting frame_y_radius will affect frame_height:

config.frame_height
8.0
config.frame_y_radius = 5.0
config.frame_height
10.0
There are many ways of interacting with config options. Take for example the config option background_color. There are three ways to change it: via a config file, via CLI flags, or programmatically.

To set the background color via a config file, save the following manim.cfg file with the following contents.

[CLI]
background_color = WHITE
In order to have this .cfg file apply to a manim scene, it needs to be placed in the same directory as the script,

project/
├─scene.py
└─manim.cfg
Now, when the user executes

manim scene.py
the background of the scene will be set to WHITE. This applies regardless of where the manim command is invoked from.

Command line arguments override .cfg files. In the previous example, executing

manim scene.py -c BLUE
will set the background color to BLUE, regardless of the contents of manim.cfg.

Finally, any programmatic changes made within the scene script itself will override the command line arguments. For example, if scene.py contains the following

from manim import *

config.background_color = RED

class MyScene(Scene): ...
the background color will be set to RED, regardless of the contents of manim.cfg or the CLI arguments used when invoking manim.

Methods

copy

Deepcopy the contents of this ManimConfig.

digest_args

Process the config options present in CLI arguments.

digest_file

Process the config options present in a .cfg file.

digest_parser

Process the config options present in a ConfigParser object.

get_dir

Resolve a config option that stores a directory.

resolve_movie_file_extension

update

Digest the options found in another ManimConfig or in a dict.

Attributes

aspect_ratio

Aspect ratio (width / height) in pixels (--resolution, -r).

assets_dir

Directory to locate video assets (no flag).

background_color

Background color of the scene (-c).

background_opacity

A number between 0.0 (fully transparent) and 1.0 (fully opaque).

bottom

Coordinate at the center bottom of the frame.

custom_folders

Whether to use custom folder output.

disable_caching

Whether to use scene caching.

disable_caching_warning

Whether a warning is raised if there are too much submobjects to hash.

dry_run

Whether dry run is enabled.

enable_gui

Enable GUI interaction.

enable_wireframe

Whether to enable wireframe debugging mode in opengl.

ffmpeg_executable

Custom path to the ffmpeg executable.

ffmpeg_loglevel

Verbosity level of ffmpeg (no flag).

flush_cache

Whether to delete all the cached partial movie files.

force_window

Whether to force window when using the opengl renderer.

format

File format; "png", "gif", "mp4", "webm" or "mov".

frame_height

Frame height in logical units (no flag).

frame_rate

Frame rate in frames per second.

frame_size

Tuple with (pixel width, pixel height) (no flag).

frame_width

Frame width in logical units (no flag).

frame_x_radius

Half the frame width (no flag).

frame_y_radius

Half the frame height (no flag).

from_animation_number

Start rendering animations at this number (-n).

fullscreen

Expand the window to its maximum possible size.

gui_location

Enable GUI interaction.

images_dir

Directory to place images (no flag).

input_file

Input file name.

left_side

Coordinate at the middle left of the frame.

log_dir

Directory to place logs.

log_to_file

Whether to save logs to a file.

max_files_cached

Maximum number of files cached.

media_dir

Main output directory.

media_embed

Whether to embed videos in Jupyter notebook.

media_width

Media width in Jupyter notebook.

movie_file_extension

Either .mp4, .webm or .mov.

no_latex_cleanup

Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex.

notify_outdated_version

Whether to notify if there is a version update available.

output_file

Output file name (-o).

partial_movie_dir

Directory to place partial movie files (no flag).

pixel_height

Frame height in pixels (--resolution, -r).

pixel_width

Frame width in pixels (--resolution, -r).

plugins

List of plugins to enable.

preview

Whether to play the rendered movie (-p).

preview_command

progress_bar

Whether to show progress bars while rendering animations.

quality

Video quality (-q).

renderer

The currently active renderer.

right_side

Coordinate at the middle right of the frame.

save_as_gif

Whether to save the rendered scene in .gif format (-i).

save_last_frame

Whether to save the last frame of the scene as an image file (-s).

save_pngs

Whether to save all frames in the scene as images files (-g).

save_sections

Whether to save single videos for each section in addition to the movie file.

scene_names

Scenes to play from file.

sections_dir

Directory to place section videos (no flag).

show_in_file_browser

Whether to show the output file in the file browser (-f).

tex_dir

Directory to place tex (no flag).

tex_template

Template used when rendering Tex.

tex_template_file

File to read Tex template from (no flag).

text_dir

Directory to place text (no flag).

top

Coordinate at the center top of the frame.

transparent

Whether the background opacity is 0.0 (-t).

upto_animation_number

Stop rendering animations at this number.

use_projection_fill_shaders

Use shaders for OpenGLVMobject fill which are compatible with transformation matrices.

use_projection_stroke_shaders

Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices.

verbosity

Logger verbosity; "DEBUG", "INFO", "WARNING", "ERROR", or "CRITICAL" (-v).

video_dir

Directory to place videos (no flag).

window_monitor

The monitor on which the scene will be rendered.

window_position

Set the position of preview window.

window_size

The size of the opengl window.

write_all

Whether to render all scenes in the input file (-a).

write_to_movie

Whether to render the scene to a movie file (-w).

zero_pad

PNG zero padding.

_set_between(key, val, lo, hi)[source]
Set key to val if lo <= val <= hi.

Parameters:
key (str)

val (float)

lo (float)

hi (float)

Return type:
None

_set_boolean(key, val)[source]
Set key to val if val is Boolean.

Parameters:
key (str)

val (Any)

Return type:
None

_set_from_enum(key, enum_value, enum_class)[source]
Set key to the enum object with value enum_value in the given enum_class.

Tests:

from enum import Enum
class Fruit(Enum):
    APPLE = 1
    BANANA = 2
    CANTALOUPE = 3
test_config = ManimConfig()
test_config._set_from_enum("fruit", 1, Fruit)
test_config._d['fruit']
<Fruit.APPLE: 1>
test_config._set_from_enum("fruit", Fruit.BANANA, Fruit)
test_config._d['fruit']
<Fruit.BANANA: 2>
test_config._set_from_enum("fruit", 42, Fruit)
Traceback (most recent call last):
...
ValueError: 42 is not a valid Fruit
Parameters:
key (str)

enum_value (Any)

enum_class (EnumMeta)

Return type:
None

_set_from_list(key, val, values)[source]
Set key to val if val is contained in values.

Parameters:
key (str)

val (Any)

values (list[Any])

Return type:
None

_set_int_between(key, val, lo, hi)[source]
Set key to val if lo <= val <= hi.

Parameters:
key (str)

val (int)

lo (int)

hi (int)

Return type:
None

_set_pos_number(key, val, allow_inf)[source]
Set key to val if val is a positive integer.

Parameters:
key (str)

val (int)

allow_inf (bool)

Return type:
None

_set_str(key, val)[source]
Set key to val if val is a string.

Parameters:
key (str)

val (Any)

Return type:
None

property aspect_ratio: int
Aspect ratio (width / height) in pixels (–resolution, -r).

property assets_dir: str
Directory to locate video assets (no flag).

property background_color: ManimColor
Background color of the scene (-c).

property background_opacity: float
A number between 0.0 (fully transparent) and 1.0 (fully opaque).

property bottom: Vector3D
Coordinate at the center bottom of the frame.

copy()[source]
Deepcopy the contents of this ManimConfig.

Returns:
A copy of this object containing no shared references.

Return type:
ManimConfig

See also

tempconfig()

Notes

This is the main mechanism behind tempconfig().

property custom_folders: str
Whether to use custom folder output.

digest_args(args)[source]
Process the config options present in CLI arguments.

Parameters:
args (argparse.Namespace) – An object returned by main_utils.parse_args().

Returns:
self – This object, after processing the contents of parser.

Return type:
ManimConfig

See also

main_utils.parse_args(), digest_parser(), digest_file()

Notes

If args.config_file is a non-empty string, ManimConfig tries to digest the contents of said file with digest_file() before digesting any other CLI arguments.

digest_file(filename)[source]
Process the config options present in a .cfg file.

This method processes a single .cfg file, whereas digest_parser() can process arbitrary parsers, built perhaps from multiple .cfg files.

Parameters:
filename (StrPath) – Path to the .cfg file.

Returns:
self – This object, after processing the contents of filename.

Return type:
ManimConfig

See also

digest_file(), digest_args(), make_config_parser()

Notes

If there are multiple .cfg files to process, it is always more efficient to parse them into a single ConfigParser object first and digesting them with one call to digest_parser(), instead of calling this method multiple times.

digest_parser(parser)[source]
Process the config options present in a ConfigParser object.

This method processes arbitrary parsers, not only those read from a single file, whereas digest_file() can only process one file at a time.

Parameters:
parser (configparser.ConfigParser) – An object reflecting the contents of one or many .cfg files. In particular, it may reflect the contents of multiple files that have been parsed in a cascading fashion.

Returns:
self – This object, after processing the contents of parser.

Return type:
ManimConfig

See also

make_config_parser(), digest_file(), digest_args()

Notes

If there are multiple .cfg files to process, it is always more efficient to parse them into a single ConfigParser object first, and then call this function once (instead of calling digest_file() multiple times).

Examples

To digest the config options set in two files, first create a ConfigParser and parse both files and then digest the parser:

parser = configparser.ConfigParser()
parser.read([file1, file2])
config = ManimConfig().digest_parser(parser)
In fact, the global config object is initialized like so:

parser = make_config_parser()
config = ManimConfig().digest_parser(parser)
property disable_caching: bool
Whether to use scene caching.

property disable_caching_warning: bool
Whether a warning is raised if there are too much submobjects to hash.

property dry_run: bool
Whether dry run is enabled.

property enable_gui: bool
Enable GUI interaction.

property enable_wireframe: bool
Whether to enable wireframe debugging mode in opengl.

property ffmpeg_executable: str
Custom path to the ffmpeg executable.

property ffmpeg_loglevel: str
Verbosity level of ffmpeg (no flag).

property flush_cache: bool
Whether to delete all the cached partial movie files.

property force_window: bool
Whether to force window when using the opengl renderer.

property format: str
File format; “png”, “gif”, “mp4”, “webm” or “mov”.

property frame_height: float
Frame height in logical units (no flag).

property frame_rate: float
Frame rate in frames per second.

property frame_size: tuple[int, int]
Tuple with (pixel width, pixel height) (no flag).

property frame_width: float
Frame width in logical units (no flag).

property frame_x_radius: float
Half the frame width (no flag).

property frame_y_radius: float
Half the frame height (no flag).

property from_animation_number: int
Start rendering animations at this number (-n).

property fullscreen: bool
Expand the window to its maximum possible size.

get_dir(key, **kwargs)[source]
Resolve a config option that stores a directory.

Config options that store directories may depend on one another. This method is used to provide the actual directory to the end user.

Parameters:
key (str) – The config option to be resolved. Must be an option ending in '_dir', for example 'media_dir' or 'video_dir'.

kwargs (Any) – Any strings to be used when resolving the directory.

Returns:
Path to the requested directory. If the path resolves to the empty string, return None instead.

Return type:
pathlib.Path

Raises:
KeyError – When key is not a config option that stores a directory and thus get_dir() is not appropriate; or when key is appropriate but there is not enough information to resolve the directory.

Notes

Standard str.format() syntax is used to resolve the paths so the paths may contain arbitrary placeholders using f-string notation. However, these will require kwargs to contain the required values.

Examples

The value of config.tex_dir is '{media_dir}/Tex' by default, i.e. it is a subfolder of wherever config.media_dir is located. In order to get the actual directory, use get_dir().

from manim import config as globalconfig
config = globalconfig.copy()
config.tex_dir
'{media_dir}/Tex'
config.media_dir
'./media'
config.get_dir("tex_dir").as_posix()
'media/Tex'
Resolving directories is done in a lazy way, at the last possible moment, to reflect any changes in other config options:

config.media_dir = "my_media_dir"
config.get_dir("tex_dir").as_posix()
'my_media_dir/Tex'
Some directories depend on information that is not available to ManimConfig. For example, the default value of video_dir includes the name of the input file and the video quality (e.g. 480p15). This informamtion has to be supplied via kwargs:

config.video_dir
'{media_dir}/videos/{module_name}/{quality}'
config.get_dir("video_dir")
Traceback (most recent call last):
KeyError: 'video_dir {media_dir}/videos/{module_name}/{quality} requires the following keyword arguments: module_name'
config.get_dir("video_dir", module_name="myfile").as_posix()
'my_media_dir/videos/myfile/1080p60'
Note the quality does not need to be passed as keyword argument since ManimConfig does store information about quality.

Directories may be recursively defined. For example, the config option partial_movie_dir depends on video_dir, which in turn depends on media_dir:

config.partial_movie_dir
'{video_dir}/partial_movie_files/{scene_name}'
config.get_dir("partial_movie_dir")
Traceback (most recent call last):
KeyError: 'partial_movie_dir {video_dir}/partial_movie_files/{scene_name} requires the following keyword arguments: scene_name'
config.get_dir(
    "partial_movie_dir", module_name="myfile", scene_name="myscene"
).as_posix()
'my_media_dir/videos/myfile/1080p60/partial_movie_files/myscene'
Standard f-string syntax is used. Arbitrary names can be used when defining directories, as long as the corresponding values are passed to ManimConfig.get_dir() via kwargs.

config.media_dir = "{dir1}/{dir2}"
config.get_dir("media_dir")
Traceback (most recent call last):
KeyError: 'media_dir {dir1}/{dir2} requires the following keyword arguments: dir1'
config.get_dir("media_dir", dir1="foo", dir2="bar").as_posix()
'foo/bar'
config.media_dir = "./media"
config.get_dir("media_dir").as_posix()
'media'
property gui_location: tuple[Any]
Enable GUI interaction.

property images_dir: str
Directory to place images (no flag). See ManimConfig.get_dir().

property input_file: str
Input file name.

property left_side: Vector3D
Coordinate at the middle left of the frame.

property log_dir: str
Directory to place logs. See ManimConfig.get_dir().

property log_to_file: bool
Whether to save logs to a file.

property max_files_cached: int
Maximum number of files cached. Use -1 for infinity (no flag).

property media_dir: str
Main output directory. See ManimConfig.get_dir().

property media_embed: bool
Whether to embed videos in Jupyter notebook.

property media_width: str
Media width in Jupyter notebook.

property movie_file_extension: str
Either .mp4, .webm or .mov.

property no_latex_cleanup: bool
Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex.

property notify_outdated_version: bool
Whether to notify if there is a version update available.

property output_file: str
Output file name (-o).

property partial_movie_dir: str
Directory to place partial movie files (no flag). See ManimConfig.get_dir().

property pixel_height: int
Frame height in pixels (–resolution, -r).

property pixel_width: int
Frame width in pixels (–resolution, -r).

property plugins: list[str]
List of plugins to enable.

property preview: bool
Whether to play the rendered movie (-p).

property progress_bar: str
Whether to show progress bars while rendering animations.

property quality: str | None
Video quality (-q).

property renderer: RendererType
The currently active renderer.

Populated with one of the available renderers in RendererType.

Tests:

test_config = ManimConfig()
test_config.renderer is None  # a new ManimConfig is unpopulated
True
test_config.renderer = 'opengl'
test_config.renderer
<RendererType.OPENGL: 'opengl'>
test_config.renderer = 42
Traceback (most recent call last):
...
ValueError: 42 is not a valid RendererType
Check that capitalization of renderer types is irrelevant:

test_config.renderer = 'OpenGL'
test_config.renderer = 'cAirO'
property right_side: Vector3D
Coordinate at the middle right of the frame.

property save_as_gif: bool
Whether to save the rendered scene in .gif format (-i).

property save_last_frame: bool
Whether to save the last frame of the scene as an image file (-s).

property save_pngs: bool
Whether to save all frames in the scene as images files (-g).

property save_sections: bool
Whether to save single videos for each section in addition to the movie file.

property scene_names: list[str]
Scenes to play from file.

property sections_dir: str
Directory to place section videos (no flag). See ManimConfig.get_dir().

property show_in_file_browser: bool
Whether to show the output file in the file browser (-f).

property tex_dir: str
Directory to place tex (no flag). See ManimConfig.get_dir().

property tex_template: TexTemplate
Template used when rendering Tex. See TexTemplate.

property tex_template_file: Path
File to read Tex template from (no flag). See TexTemplate.

property text_dir: str
Directory to place text (no flag). See ManimConfig.get_dir().

property top: Vector3D
Coordinate at the center top of the frame.

property transparent: bool
Whether the background opacity is 0.0 (-t).

update(obj)[source]
Digest the options found in another ManimConfig or in a dict.

Similar to dict.update(), replaces the values of this object with those of obj.

Parameters:
obj (ManimConfig | dict[str, Any]) – The object to copy values from.

Return type:
None

Raises:
AttributeError – If obj is a dict but contains keys that do not belong to any config options.

See also

digest_file(), digest_args(), digest_parser()

property upto_animation_number: int
Stop rendering animations at this number. Use -1 to avoid skipping (-n).

property use_projection_fill_shaders: bool
Use shaders for OpenGLVMobject fill which are compatible with transformation matrices.

property use_projection_stroke_shaders: bool
Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices.

property verbosity: str
Logger verbosity; “DEBUG”, “INFO”, “WARNING”, “ERROR”, or “CRITICAL” (-v).

property video_dir: str
Directory to place videos (no flag). See ManimConfig.get_dir().

property window_monitor: int
The monitor on which the scene will be rendered.

property window_position: str
Set the position of preview window. You can use directions, e.g. UL/DR/ORIGIN/LEFT…or the position(pixel) of the upper left corner of the window, e.g. ‘960,540’.

property window_size: str
The size of the opengl window. ‘default’ to automatically scale the window based on the display monitor.

property write_all: bool
Whether to render all scenes in the input file (-a).

property write_to_movie: bool
Whether to render the scene to a movie file (-w).

property zero_pad: int
PNG zero padding. A number between 0 (no zero padding) and 9 (9 columns minimum).

ManimFrame
Qualified name: manim.\_config.utils.ManimFrame

class ManimFrame(c)[source]
Bases: Mapping

Methods

Attributes

DL

DOWN

DR

IN

LEFT

ORIGIN

OUT

RIGHT

UL

UP

UR

X_AXIS

Y_AXIS

Z_AXIS

aspect_ratio

bottom

frame_height

frame_width

frame_x_radius

frame_y_radius

left_side

pixel_height

pixel_width

right_side

top

Parameters:
c (ManimConfig)

logger_utils
Utilities to create and set the logger.

Manim’s logger can be accessed as manim.logger, or as logging.getLogger("manim"), once the library has been imported. Manim also exports a second object, console, which should be used to print on screen messages that need not be logged.

Both logger and console use the rich library to produce rich text format.

Classes

JSONFormatter

A formatter that outputs logs in a custom JSON format.

Functions

make_logger(parser, verbosity)[source]
Make the manim logger and console.

Parameters:
parser (SectionProxy) – A parser containing any .cfg files in use.

verbosity (str) – The verbosity level of the logger.

Returns:
The manim logger and consoles. The first console outputs to stdout, the second to stderr. All use the theme returned by parse_theme().

Return type:
logging.Logger, rich.Console, rich.Console

See also

make_config_parser(), parse_theme()

Notes

The parser is assumed to contain only the options related to configuring the logger at the top level.

parse_theme(parser)[source]
Configure the rich style of logger and console output.

Parameters:
parser (SectionProxy) – A parser containing any .cfg files in use.

Returns:
The rich theme to be used by the manim logger.

Return type:
rich.Theme

See also

make_logger()

set_file_logger(scene_name, module_name, log_dir)[source]
Add a file handler to manim logger.

The path to the file is built using config.log_dir.

Parameters:
scene_name (str) – The name of the scene, used in the name of the log file.

module_name (str) – The name of the module, used in the name of the log file.

log_dir (Path) – Path to the folder where log files are stored.

Return type:
None

JSONFormatter
Qualified name: manim.\_config.logger\_utils.JSONFormatter

class JSONFormatter(fmt=None, datefmt=None, style='%', validate=True, *, defaults=None)[source]
Bases: Formatter

A formatter that outputs logs in a custom JSON format.

This class is used internally for testing purposes.

Initialize the formatter with specified format strings.

Initialize the formatter either with the specified format string, or a default as described above. Allow for specialized date formatting with the optional datefmt argument. If datefmt is omitted, you get an ISO8601-like (or RFC 3339-like) format.

Use a style parameter of ‘%’, ‘{’ or ‘$’ to specify that you want to use one of %-formatting, str.format() ({}) formatting or string.Template formatting in your format string.

Changed in version 3.2: Added the style parameter.

Methods

format

Format the record in a custom JSON format.

Attributes

default_msec_format

default_time_format

format(record)[source]
Format the record in a custom JSON format.

Parameters:
record (LogRecord)

Return type:
str

Mobjects
frame

Special rectangles.

geometry

Various geometric Mobjects.

graph

Mobjects used to represent mathematical graphs (think graph theory, not plotting).

graphing

Coordinate systems and function graphing related mobjects.

logo

Utilities for Manim's logo and banner.

matrix

Mobjects representing matrices.

mobject

Base classes for objects that can be displayed.

svg

Mobjects related to SVG images.

table

Mobjects representing tables.

text

Mobjects used to display Text using Pango or LaTeX.

three_d

Three-dimensional mobjects.

types

Specialized mobject base classes.

utils

Utilities for working with mobjects.

value_tracker

Simple mobjects that can be used for storing (and updating) a value.

vector_field

Mobjects representing vector fields.

frame
Special rectangles.

Classes

FullScreenRectangle

ScreenRectangle

FullScreenRectangle
Qualified name: manim.mobject.frame.FullScreenRectangle

class FullScreenRectangle(**kwargs)[source]
Bases: ScreenRectangle

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

aspect_ratio

The aspect ratio.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(**kwargs)
Initialize self. See help(type(self)) for accurate signature

ScreenRectangle
Qualified name: manim.mobject.frame.ScreenRectangle

class ScreenRectangle(aspect_ratio=1.7777777777777777, height=4, **kwargs)[source]
Bases: Rectangle

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

aspect_ratio

The aspect ratio.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(aspect_ratio=1.7777777777777777, height=4, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

property aspect_ratio
The aspect ratio.

When set, the width is stretched to accommodate the new aspect ratio.

geometry
Various geometric Mobjects.

Modules
arc

Mobjects that are curved.

boolean_ops

Boolean operations for two-dimensional mobjects.

labeled

Mobjects that inherit from lines and contain a label along the length.

line

Mobjects that are lines or variations of them.

polygram

Mobjects that are simple geometric shapes.

shape_matchers

Mobjects used to mark and annotate other mobjects.

tips

A collection of tip mobjects for use with TipableVMobject.

arc
Mobjects that are curved.

Examples

Example: UsefulAnnotations 

../_images/UsefulAnnotations-1.png
from manim import *

class UsefulAnnotations(Scene):
    def construct(self):
        m0 = Dot()
        m1 = AnnotationDot()
        m2 = LabeledDot("ii")
        m3 = LabeledDot(MathTex(r"\alpha").set_color(ORANGE))
        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)
        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)
        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)

        self.add(m0, m1, m2, m3, m4, m5, m6)
        for i, mobj in enumerate(self.mobjects):
            mobj.shift(DOWN * (i-3))
Make interactive
Classes

AnnotationDot

A dot with bigger radius and bold stroke to annotate scenes.

AnnularSector

A sector of an annulus.

Annulus

Region between two concentric Circles.

Arc

A circular arc.

ArcBetweenPoints

Inherits from Arc and additionally takes 2 points between which the arc is spanned.

ArcPolygon

A generalized polygon allowing for points to be connected with arcs.

ArcPolygonFromArcs

A generalized polygon allowing for points to be connected with arcs.

Circle

A circle.

CubicBezier

A cubic Bézier curve.

CurvedArrow

CurvedDoubleArrow

Dot

A circle with a very small radius.

Ellipse

A circular shape; oval, circle.

LabeledDot

A Dot containing a label in its center.

Sector

A sector of a circle.

TipableVMobject

Meant for shared functionality between Arc and Line.

AnnotationDot
Qualified name: manim.mobject.geometry.arc.AnnotationDot

class AnnotationDot(radius=0.10400000000000001, stroke_width=5, stroke_color=ManimColor('#FFFFFF'), fill_color=ManimColor('#58C4DD'), **kwargs)[source]
Bases: Dot

A dot with bigger radius and bold stroke to annotate scenes.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
radius (float)

stroke_width (float)

stroke_color (ParsableManimColor)

fill_color (ParsableManimColor)

_original__init__(radius=0.10400000000000001, stroke_width=5, stroke_color=ManimColor('#FFFFFF'), fill_color=ManimColor('#58C4DD'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
radius (float)

stroke_width (float)

stroke_color (ParsableManimColor)

fill_color (ParsableManimColor)

Return type:
None

AnnularSector
Qualified name: manim.mobject.geometry.arc.AnnularSector

class AnnularSector(inner_radius=1, outer_radius=2, angle=1.5707963267948966, start_angle=0, fill_opacity=1, stroke_width=0, color=ManimColor('#FFFFFF'), **kwargs)[source]
Bases: Arc

A sector of an annulus.

Parameters:
inner_radius (float) – The inside radius of the Annular Sector.

outer_radius (float) – The outside radius of the Annular Sector.

angle (float) – The clockwise angle of the Annular Sector.

start_angle (float) – The starting clockwise angle of the Annular Sector.

fill_opacity (float) – The opacity of the color filled in the Annular Sector.

stroke_width (float) – The stroke width of the Annular Sector.

color (ParsableManimColor) – The color filled into the Annular Sector.

Examples

Example: AnnularSectorExample 

../_images/AnnularSectorExample-1.png
from manim import *

class AnnularSectorExample(Scene):
    def construct(self):
        # Changes background color to clearly visualize changes in fill_opacity.
        self.camera.background_color = WHITE

        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.
        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)

        # Different inner_radius and outer_radius than the default.
        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)

        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.
        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)

        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.
        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)

        self.add(s1, s2, s3, s4)
Make interactive
Methods

generate_points

Initializes points and therefore the shape.

init_points

Initializes points and therefore the shape.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(inner_radius=1, outer_radius=2, angle=1.5707963267948966, start_angle=0, fill_opacity=1, stroke_width=0, color=ManimColor('#FFFFFF'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
inner_radius (float)

outer_radius (float)

angle (float)

start_angle (float)

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor)

Return type:
None

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

init_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

Annulus
Qualified name: manim.mobject.geometry.arc.Annulus

class Annulus(inner_radius=1, outer_radius=2, fill_opacity=1, stroke_width=0, color=ManimColor('#FFFFFF'), mark_paths_closed=False, **kwargs)[source]
Bases: Circle

Region between two concentric Circles.

Parameters:
inner_radius (float | None) – The radius of the inner Circle.

outer_radius (float | None) – The radius of the outer Circle.

kwargs – Additional arguments to be passed to Annulus

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor)

mark_paths_closed (bool)

Examples

Example: AnnulusExample 

../_images/AnnulusExample-1.png
from manim import *

class AnnulusExample(Scene):
    def construct(self):
        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)
        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)
        self.add(annulus_1, annulus_2)
Make interactive
Methods

generate_points

Initializes points and therefore the shape.

init_points

Initializes points and therefore the shape.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(inner_radius=1, outer_radius=2, fill_opacity=1, stroke_width=0, color=ManimColor('#FFFFFF'), mark_paths_closed=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
inner_radius (float | None)

outer_radius (float | None)

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor)

mark_paths_closed (bool)

Return type:
None

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

init_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

Arc
Qualified name: manim.mobject.geometry.arc.Arc

class Arc(radius=1.0, start_angle=0, angle=1.5707963267948966, num_components=9, arc_center=array([0., 0., 0.]), **kwargs)[source]
Bases: TipableVMobject

A circular arc.

Examples

A simple arc of angle Pi.

Example: ArcExample 

../_images/ArcExample-1.png
from manim import *

class ArcExample(Scene):
    def construct(self):
        self.add(Arc(angle=PI))
Make interactive
Methods

generate_points

Initializes points and therefore the shape.

get_arc_center

Looks at the normals to the first two anchors, and finds their intersection points

init_points

move_arc_center_to

stop_angle

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
radius (float)

start_angle (float)

angle (float)

num_components (int)

arc_center (Point3D)

_original__init__(radius=1.0, start_angle=0, angle=1.5707963267948966, num_components=9, arc_center=array([0., 0., 0.]), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
radius (float)

start_angle (float)

angle (float)

num_components (int)

arc_center (Point3D)

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

get_arc_center(warning=True)[source]
Looks at the normals to the first two anchors, and finds their intersection points

Parameters:
warning (bool)

Return type:
Point3D

ArcBetweenPoints
Qualified name: manim.mobject.geometry.arc.ArcBetweenPoints

class ArcBetweenPoints(start, end, angle=1.5707963267948966, radius=None, **kwargs)[source]
Bases: Arc

Inherits from Arc and additionally takes 2 points between which the arc is spanned.

Example

Example: ArcBetweenPointsExample 

from manim import *

class ArcBetweenPointsExample(Scene):
    def construct(self):
        circle = Circle(radius=2, stroke_color=GREY)
        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)
        dot_1_text = Tex("(2,0)").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)
        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)
        dot_2_text = Tex("(0,2)").scale(0.5).next_to(dot_2, UP).set_color(BLUE)
        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)
        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)
        self.play(Create(arc))
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
start (Point3D)

end (Point3D)

angle (float)

radius (float)

_original__init__(start, end, angle=1.5707963267948966, radius=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
start (Point3D)

end (Point3D)

angle (float)

radius (float)

Return type:
None

ArcPolygon
Qualified name: manim.mobject.geometry.arc.ArcPolygon

class ArcPolygon(*vertices, angle=0.7853981633974483, radius=None, arc_config=None, **kwargs)[source]
Bases: VMobject

A generalized polygon allowing for points to be connected with arcs.

This version tries to stick close to the way Polygon is used. Points can be passed to it directly which are used to generate the according arcs (using ArcBetweenPoints). An angle or radius can be passed to it to use across all arcs, but to configure arcs individually an arc_config list has to be passed with the syntax explained below.

Parameters:
vertices (Point3D) – A list of vertices, start and end points for the arc segments.

angle (float) – The angle used for constructing the arcs. If no other parameters are set, this angle is used to construct all arcs.

radius (float | None) – The circle radius used to construct the arcs. If specified, overrides the specified angle.

arc_config (list[dict] | None) – When passing a dict, its content will be passed as keyword arguments to ArcBetweenPoints. Otherwise, a list of dictionaries containing values that are passed as keyword arguments for every individual arc can be passed.

kwargs – Further keyword arguments that are passed to the constructor of VMobject.

arcs
The arcs created from the input parameters:

from manim import ArcPolygon
ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])
ap.arcs
[ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]
Type:
list

Tip

Two instances of ArcPolygon can be transformed properly into one another as well. Be advised that any arc initialized with angle=0 will actually be a straight line, so if a straight section should seamlessly transform into an arced section or vice versa, initialize the straight section with a negligible angle instead (such as angle=0.0001).

Note

There is an alternative version (ArcPolygonFromArcs) that is instantiated with pre-defined arcs.

See also

ArcPolygonFromArcs

Examples

Example: SeveralArcPolygons 

from manim import *

class SeveralArcPolygons(Scene):
    def construct(self):
        a = [0, 0, 0]
        b = [2, 0, 0]
        c = [0, 2, 0]
        ap1 = ArcPolygon(a, b, c, radius=2)
        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)
        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})
        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,
                                    arc_config=[{'radius': 1.7, 'color': RED},
                                    {'angle': 20*DEGREES, 'color': BLUE},
                                    {'radius': 1}])
        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()
        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])
        self.wait()
Make interactive
For further examples see ArcPolygonFromArcs.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*vertices, angle=0.7853981633974483, radius=None, arc_config=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertices (Point3D)

angle (float)

radius (float | None)

arc_config (list[dict] | None)

Return type:
None

ArcPolygonFromArcs
Qualified name: manim.mobject.geometry.arc.ArcPolygonFromArcs

class ArcPolygonFromArcs(*arcs, **kwargs)[source]
Bases: VMobject

A generalized polygon allowing for points to be connected with arcs.

This version takes in pre-defined arcs to generate the arcpolygon and introduces little new syntax. However unlike Polygon it can’t be created with points directly.

For proper appearance the passed arcs should connect seamlessly: [a,b][b,c][c,a]

If there are any gaps between the arcs, those will be filled in with straight lines, which can be used deliberately for any straight sections. Arcs can also be passed as straight lines such as an arc initialized with angle=0.

Parameters:
arcs (Arc | ArcBetweenPoints) – These are the arcs from which the arcpolygon is assembled.

kwargs – Keyword arguments that are passed to the constructor of VMobject. Affects how the ArcPolygon itself is drawn, but doesn’t affect passed arcs.

arcs
The arcs used to initialize the ArcPolygonFromArcs:

from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints
ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())
ap.arcs
[Arc, ArcBetweenPoints, Arc]
Tip

Two instances of ArcPolygon can be transformed properly into one another as well. Be advised that any arc initialized with angle=0 will actually be a straight line, so if a straight section should seamlessly transform into an arced section or vice versa, initialize the straight section with a negligible angle instead (such as angle=0.0001).

Note

There is an alternative version (ArcPolygon) that can be instantiated with points.

See also

ArcPolygon

Examples

One example of an arcpolygon is the Reuleaux triangle. Instead of 3 straight lines connecting the outer points, a Reuleaux triangle has 3 arcs connecting those points, making a shape with constant width.

Passed arcs are stored as submobjects in the arcpolygon. This means that the arcs are changed along with the arcpolygon, for example when it’s shifted, and these arcs can be manipulated after the arcpolygon has been initialized.

Also both the arcs contained in an ArcPolygonFromArcs, as well as the arcpolygon itself are drawn, which affects draw time in Create for example. In most cases the arcs themselves don’t need to be drawn, in which case they can be passed as invisible.

Example: ArcPolygonExample 

from manim import *

class ArcPolygonExample(Scene):
    def construct(self):
        arc_conf = {"stroke_width": 0}
        poly_conf = {"stroke_width": 10, "stroke_color": BLUE,
              "fill_opacity": 1, "color": PURPLE}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)
Make interactive
The arcpolygon itself can also be hidden so that instead only the contained arcs are drawn. This can be used to easily debug arcs or to highlight them.

Example: ArcPolygonExample2 

from manim import *

class ArcPolygonExample2(Scene):
    def construct(self):
        arc_conf = {"stroke_width": 3, "stroke_color": BLUE,
            "fill_opacity": 0.5, "color": GREEN}
        poly_conf = {"color": None}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*arcs, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
arcs (Arc | ArcBetweenPoints)

Return type:
None

Circle
Qualified name: manim.mobject.geometry.arc.Circle

class Circle(radius=None, color=ManimColor('#FC6255'), **kwargs)[source]
Bases: Arc

A circle.

Parameters:
color (ParsableManimColor) – The color of the shape.

kwargs – Additional arguments to be passed to Arc

radius (float | None)

Examples

Example: CircleExample 

../_images/CircleExample-1.png
from manim import *

class CircleExample(Scene):
    def construct(self):
        circle_1 = Circle(radius=1.0)
        circle_2 = Circle(radius=1.5, color=GREEN)
        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)

        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)
        self.add(circle_group)
Make interactive
Methods

from_three_points

Returns a circle passing through the specified three points.

point_at_angle

Returns the position of a point on the circle.

surround

Modifies a circle so that it surrounds a given mobject.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(radius=None, color=ManimColor('#FC6255'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
radius (float | None)

color (ParsableManimColor)

Return type:
None

static from_three_points(p1, p2, p3, **kwargs)[source]
Returns a circle passing through the specified three points.

Example

Example: CircleFromPointsExample 

../_images/CircleFromPointsExample-1.png
from manim import *

class CircleFromPointsExample(Scene):
    def construct(self):
        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)
        dots = VGroup(
            Dot(LEFT),
            Dot(LEFT + UP),
            Dot(UP * 2),
        )
        self.add(NumberPlane(), circle, dots)
Make interactive
Parameters:
p1 (Point3D)

p2 (Point3D)

p3 (Point3D)

Return type:
Self

point_at_angle(angle)[source]
Returns the position of a point on the circle.

Parameters:
angle (float) – The angle of the point along the circle in radians.

Returns:
The location of the point along the circle’s circumference.

Return type:
numpy.ndarray

Examples

Example: PointAtAngleExample 

../_images/PointAtAngleExample-1.png
from manim import *

class PointAtAngleExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        p1 = circle.point_at_angle(PI/2)
        p2 = circle.point_at_angle(270*DEGREES)

        s1 = Square(side_length=0.25).move_to(p1)
        s2 = Square(side_length=0.25).move_to(p2)
        self.add(circle, s1, s2)
Make interactive
surround(mobject, dim_to_match=0, stretch=False, buffer_factor=1.2)[source]
Modifies a circle so that it surrounds a given mobject.

Parameters:
mobject (Mobject) – The mobject that the circle will be surrounding.

dim_to_match (int)

buffer_factor (float) – Scales the circle with respect to the mobject. A buffer_factor < 1 makes the circle smaller than the mobject.

stretch (bool) – Stretches the circle to fit more tightly around the mobject. Note: Does not work with Line

Return type:
Self

Examples

Example: CircleSurround 

../_images/CircleSurround-1.png
from manim import *

class CircleSurround(Scene):
    def construct(self):
        triangle1 = Triangle()
        circle1 = Circle().surround(triangle1)
        group1 = Group(triangle1,circle1) # treat the two mobjects as one

        line2 = Line()
        circle2 = Circle().surround(line2, buffer_factor=2.0)
        group2 = Group(line2,circle2)

        # buffer_factor < 1, so the circle is smaller than the square
        square3 = Square()
        circle3 = Circle().surround(square3, buffer_factor=0.5)
        group3 = Group(square3, circle3)

        group = Group(group1, group2, group3).arrange(buff=1)
        self.add(group)


CubicBezier
Qualified name: manim.mobject.geometry.arc.CubicBezier

class CubicBezier(start_anchor, start_handle, end_handle, end_anchor, **kwargs)[source]
Bases: VMobject

A cubic Bézier curve.

Example

Example: BezierSplineExample 

../_images/BezierSplineExample-1.png
from manim import *

class BezierSplineExample(Scene):
    def construct(self):
        p1 = np.array([-3, 1, 0])
        p1b = p1 + [1, 0, 0]
        d1 = Dot(point=p1).set_color(BLUE)
        l1 = Line(p1, p1b)
        p2 = np.array([3, -1, 0])
        p2b = p2 - [1, 0, 0]
        d2 = Dot(point=p2).set_color(RED)
        l2 = Line(p2, p2b)
        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)
        self.add(l1, d1, l2, d2, bezier)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
start_anchor (CubicBezierPoints)

start_handle (CubicBezierPoints)

end_handle (CubicBezierPoints)

end_anchor (CubicBezierPoints)

_original__init__(start_anchor, start_handle, end_handle, end_anchor, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
start_anchor (CubicBezierPoints)

start_handle (CubicBezierPoints)

end_handle (CubicBezierPoints)

end_anchor (CubicBezierPoints)

Return type:
None

CurvedArrow
Qualified name: manim.mobject.geometry.arc.CurvedArrow

class CurvedArrow(start_point, end_point, **kwargs)[source]
Bases: ArcBetweenPoints

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
start_point (Point3D)

end_point (Point3D)

_original__init__(start_point, end_point, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
start_point (Point3D)

end_point (Point3D)

Return type:
None

CurvedDoubleArrow
Qualified name: manim.mobject.geometry.arc.CurvedDoubleArrow

class CurvedDoubleArrow(start_point, end_point, **kwargs)[source]
Bases: CurvedArrow

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
start_point (Point3D)

end_point (Point3D)

_original__init__(start_point, end_point, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
start_point (Point3D)

end_point (Point3D)

Return type:
None

Dot
Qualified name: manim.mobject.geometry.arc.Dot

class Dot(point=array([0., 0., 0.]), radius=0.08, stroke_width=0, fill_opacity=1.0, color=ManimColor('#FFFFFF'), **kwargs)[source]
Bases: Circle

A circle with a very small radius.

Parameters:
point (Point3D) – The location of the dot.

radius (float) – The radius of the dot.

stroke_width (float) – The thickness of the outline of the dot.

fill_opacity (float) – The opacity of the dot’s fill_colour

color (ParsableManimColor) – The color of the dot.

kwargs – Additional arguments to be passed to Circle

Examples

Example: DotExample 

../_images/DotExample-1.png
from manim import *

class DotExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT, radius=0.08)
        dot2 = Dot(point=ORIGIN)
        dot3 = Dot(point=RIGHT)
        self.add(dot1,dot2,dot3)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(point=array([0., 0., 0.]), radius=0.08, stroke_width=0, fill_opacity=1.0, color=ManimColor('#FFFFFF'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
point (Point3D)

radius (float)

stroke_width (float)

fill_opacity (float)

color (ParsableManimColor)

Return type:
None

Ellipse
Qualified name: manim.mobject.geometry.arc.Ellipse

class Ellipse(width=2, height=1, **kwargs)[source]
Bases: Circle

A circular shape; oval, circle.

Parameters:
width (float) – The horizontal width of the ellipse.

height (float) – The vertical height of the ellipse.

kwargs – Additional arguments to be passed to Circle.

Examples

Example: EllipseExample 

../_images/EllipseExample-1.png
from manim import *

class EllipseExample(Scene):
    def construct(self):
        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)
        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)
        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)
        self.add(ellipse_group)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(width=2, height=1, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
width (float)

height (float)

Return type:
None

LabeledDot
Qualified name: manim.mobject.geometry.arc.LabeledDot

class LabeledDot(label, radius=None, **kwargs)[source]
Bases: Dot

A Dot containing a label in its center.

Parameters:
label (str | SingleStringMathTex | Text | Tex) – The label of the Dot. This is rendered as MathTex by default (i.e., when passing a str), but other classes representing rendered strings like Text or Tex can be passed as well.

radius (float | None) – The radius of the Dot. If None (the default), the radius is calculated based on the size of the label.

Examples

Example: SeveralLabeledDots 

../_images/SeveralLabeledDots-1.png
from manim import *

class SeveralLabeledDots(Scene):
    def construct(self):
        sq = Square(fill_color=RED, fill_opacity=1)
        self.add(sq)
        dot1 = LabeledDot(Tex("42", color=RED))
        dot2 = LabeledDot(MathTex("a", color=GREEN))
        dot3 = LabeledDot(Text("ii", color=BLUE))
        dot4 = LabeledDot("3")
        dot1.next_to(sq, UL)
        dot2.next_to(sq, UR)
        dot3.next_to(sq, DL)
        dot4.next_to(sq, DR)
        self.add(dot1, dot2, dot3, dot4)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(label, radius=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
label (str | SingleStringMathTex | Text | Tex)

radius (float | None)

Return type:
None

Sector
Qualified name: manim.mobject.geometry.arc.Sector

class Sector(outer_radius=1, inner_radius=0, **kwargs)[source]
Bases: AnnularSector

A sector of a circle.

Examples

Example: ExampleSector 

../_images/ExampleSector-1.png
from manim import *

class ExampleSector(Scene):
    def construct(self):
        sector = Sector(outer_radius=2, inner_radius=1)
        sector2 = Sector(outer_radius=2.5, inner_radius=0.8).move_to([-3, 0, 0])
        sector.set_color(RED)
        sector2.set_color(PINK)
        self.add(sector, sector2)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
outer_radius (float)

inner_radius (float)

_original__init__(outer_radius=1, inner_radius=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
outer_radius (float)

inner_radius (float)

Return type:
None

TipableVMobject
Qualified name: manim.mobject.geometry.arc.TipableVMobject

class TipableVMobject(tip_length=0.35, normal_vector=array([0., 0., 1.]), tip_style={}, **kwargs)[source]
Bases: VMobject

Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:

Adding, Creating, Modifying tips
add_tip calls create_tip, before pushing the new tip
into the TipableVMobject’s list of submobjects

stylistic and positional configuration

Checking for tips
Boolean checks for whether the TipableVMobject has a tip
and a starting tip

Getters
Straightforward accessors, returning information pertaining
to the TipableVMobject instance’s tip(s), its length etc

Methods

add_tip

Adds a tip to the TipableVMobject instance, recognising that the endpoints might need to be switched if it's a 'starting tip' or not.

asign_tip_attr

create_tip

Stylises the tip, positions it spatially, and returns the newly instantiated tip to the caller.

get_default_tip_length

get_end

Returns the point, where the stroke that surrounds the Mobject ends.

get_first_handle

get_last_handle

get_length

get_start

Returns the point, where the stroke that surrounds the Mobject starts.

get_tip

Returns the TipableVMobject instance's (first) tip, otherwise throws an exception.

get_tips

Returns a VGroup (collection of VMobjects) containing the TipableVMObject instance's tips.

get_unpositioned_tip

Returns a tip that has been stylistically configured, but has not yet been given a position in space.

has_start_tip

has_tip

pop_tips

position_tip

reset_endpoints_based_on_tip

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
tip_length (float)

normal_vector (Vector3D)

tip_style (dict)

_original__init__(tip_length=0.35, normal_vector=array([0., 0., 1.]), tip_style={}, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
tip_length (float)

normal_vector (Vector3D)

tip_style (dict)

Return type:
None

add_tip(tip=None, tip_shape=None, tip_length=None, tip_width=None, at_start=False)[source]
Adds a tip to the TipableVMobject instance, recognising that the endpoints might need to be switched if it’s a ‘starting tip’ or not.

Parameters:
tip (tips.ArrowTip | None)

tip_shape (type[tips.ArrowTip] | None)

tip_length (float | None)

tip_width (float | None)

at_start (bool)

Return type:
Self

create_tip(tip_shape=None, tip_length=None, tip_width=None, at_start=False)[source]
Stylises the tip, positions it spatially, and returns the newly instantiated tip to the caller.

Parameters:
tip_shape (type[tips.ArrowTip] | None)

tip_length (float)

tip_width (float)

at_start (bool)

get_end()[source]
Returns the point, where the stroke that surrounds the Mobject ends.

Return type:
Point3D

get_start()[source]
Returns the point, where the stroke that surrounds the Mobject starts.

Return type:
Point3D

get_tip()[source]
Returns the TipableVMobject instance’s (first) tip, otherwise throws an exception.

get_tips()[source]
Returns a VGroup (collection of VMobjects) containing the TipableVMObject instance’s tips.

Return type:
VGroup

get_unpositioned_tip(tip_shape=None, tip_length=None, tip_width=None)[source]
Returns a tip that has been stylistically configured, but has not yet been given a position in space.

Parameters:
tip_shape (type[tips.ArrowTip] | None)

tip_length (float | None)

tip_width (float | None)

boolean_ops
Boolean operations for two-dimensional mobjects.

Classes

Difference

Subtracts one VMobject from another one.

Exclusion

Find the XOR between two VMobject.

Intersection

Find the intersection of two VMobject s.

Union

Union of two or more VMobject s.

Difference
Qualified name: manim.mobject.geometry.boolean\_ops.Difference

class Difference(subject, clip, **kwargs)[source]
Bases: _BooleanOps

Subtracts one VMobject from another one.

Parameters:
subject (VMobject) – The 1st VMobject.

clip (VMobject) – The 2nd VMobject

Example

Example: DifferenceExample 

../_images/DifferenceExample-1.png
from manim import *

class DifferenceExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Difference(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(subject, clip, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
subject (VMobject)

clip (VMobject)

Return type:
None

Exclusion
Qualified name: manim.mobject.geometry.boolean\_ops.Exclusion

class Exclusion(subject, clip, **kwargs)[source]
Bases: _BooleanOps

Find the XOR between two VMobject. This creates a new VMobject consisting of the region covered by exactly one of them.

Parameters:
subject (VMobject) – The 1st VMobject.

clip (VMobject) – The 2nd VMobject

Example

Example: IntersectionExample 

../_images/IntersectionExample-1.png
from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.4, 0])
        self.add(sq, cr, un)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(subject, clip, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
subject (VMobject)

clip (VMobject)

Return type:
None

Intersection
Qualified name: manim.mobject.geometry.boolean\_ops.Intersection

class Intersection(*vmobjects, **kwargs)[source]
Bases: _BooleanOps

Find the intersection of two VMobject s. This keeps the parts covered by both VMobject s.

Parameters:
vmobjects (VMobject) – The VMobject to find the intersection.

Raises:
ValueError – If less the 2 VMobject are passed.

Example

Example: IntersectionExample 

../_images/IntersectionExample-2.png
from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*vmobjects, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmobjects (VMobject)

Return type:
None

Union
Qualified name: manim.mobject.geometry.boolean\_ops.Union

class Union(*vmobjects, **kwargs)[source]
Bases: _BooleanOps

Union of two or more VMobject s. This returns the common region of the VMobject s.

Parameters:
vmobjects (VMobject) – The VMobject s to find the union of.

Raises:
ValueError – If less than 2 VMobject s are passed.

Example

Example: UnionExample 

../_images/UnionExample-1.png
from manim import *

class UnionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Union(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.3, 0])
        self.add(sq, cr, un)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*vmobjects, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmobjects (VMobject)

Return type:
None

labeled
Mobjects that inherit from lines and contain a label along the length.

Classes

LabeledArrow

Constructs an arrow containing a label box somewhere along its length.

LabeledLine

Constructs a line containing a label box somewhere along its length.

LabeledArrow
Qualified name: manim.mobject.geometry.labeled.LabeledArrow

class LabeledArrow(*args, **kwargs)[source]
Bases: LabeledLine, Arrow

Constructs an arrow containing a label box somewhere along its length. This class inherits its label properties from LabeledLine, so the main parameters controlling it are the same.

Parameters:
label (str | Tex | MathTex | Text) – Label that will be displayed on the line.

label_position (float | optional) – A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.

font_size (float | optional) – Control font size for the label. This parameter is only used when label is of type str.

label_color (ParsableManimColor | optional) – The color of the label’s text. This parameter is only used when label is of type str.

label_frame (Bool | optional) – Add a SurroundingRectangle frame to the label box.

frame_fill_color (ParsableManimColor | optional) – Background color to fill the label box. If no value is provided, the background color of the canvas will be used.

frame_fill_opacity (float | optional) – Determine the opacity of the label box by passing a value in the range [0-1], where 0 indicates complete transparency and 1 means full opacity.

See also

LabeledLine

Examples

Example: LabeledArrowExample 

../_images/LabeledArrowExample-1.png
from manim import *

class LabeledArrowExample(Scene):
    def construct(self):
        l_arrow = LabeledArrow("0.5", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)

        self.add(l_arrow)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*args, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Return type:
None

LabeledLine
Qualified name: manim.mobject.geometry.labeled.LabeledLine

class LabeledLine(label, label_position=0.5, font_size=48, label_color=ManimColor('#FFFFFF'), label_frame=True, frame_fill_color=None, frame_fill_opacity=1, *args, **kwargs)[source]
Bases: Line

Constructs a line containing a label box somewhere along its length.

Parameters:
label (str | Tex | MathTex | Text) – Label that will be displayed on the line.

label_position (float | optional) – A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.

font_size (float | optional) – Control font size for the label. This parameter is only used when label is of type str.

label_color (ParsableManimColor | optional) – The color of the label’s text. This parameter is only used when label is of type str.

label_frame (Bool | optional) – Add a SurroundingRectangle frame to the label box.

frame_fill_color (ParsableManimColor | optional) – Background color to fill the label box. If no value is provided, the background color of the canvas will be used.

frame_fill_opacity (float | optional) – Determine the opacity of the label box by passing a value in the range [0-1], where 0 indicates complete transparency and 1 means full opacity.

seealso:: (..) – LabeledArrow

Examples

Example: LabeledLineExample 

../_images/LabeledLineExample-1.png
from manim import *

class LabeledLineExample(Scene):
    def construct(self):
        line = LabeledLine(
            label          = '0.5',
            label_position = 0.8,
            font_size      = 20,
            label_color    = WHITE,
            label_frame    = True,

            start=LEFT+DOWN,
            end=RIGHT+UP)

        line.set_length(line.get_length() * 2)
        self.add(line)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(label, label_position=0.5, font_size=48, label_color=ManimColor('#FFFFFF'), label_frame=True, frame_fill_color=None, frame_fill_opacity=1, *args, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
label (str | Tex | MathTex | Text)

label_position (float)

font_size (float)

label_color (ParsableManimColor)

label_frame (bool)

frame_fill_color (ParsableManimColor)

frame_fill_opacity (float)

Return type:
None

line
Mobjects that are lines or variations of them.

Classes

Angle

A circular arc or elbow-type mobject representing an angle of two lines.

Arrow

An arrow.

DashedLine

A dashed Line.

DoubleArrow

An arrow with tips on both ends.

Elbow

Two lines that create a right angle about each other: L-shape.

Line

RightAngle

An elbow-type mobject representing a right angle between two lines.

TangentLine

Constructs a line tangent to a VMobject at a specific point.

Vector

A vector specialized for use in graphs.

Angle
Qualified name: manim.mobject.geometry.line.Angle

class Angle(line1, line2, radius=None, quadrant=(1, 1), other_angle=False, dot=False, dot_radius=None, dot_distance=0.55, dot_color=ManimColor('#FFFFFF'), elbow=False, **kwargs)[source]
Bases: VMobject

A circular arc or elbow-type mobject representing an angle of two lines.

Parameters:
line1 (Line) – The first line.

line2 (Line) – The second line.

radius (float | None) – The radius of the Arc.

quadrant (Point2D) – A sequence of two int numbers determining which of the 4 quadrants should be used. The first value indicates whether to anchor the arc on the first line closer to the end point (1) or start point (-1), and the second value functions similarly for the end (1) or start (-1) of the second line. Possibilities: (1,1), (-1,1), (1,-1), (-1,-1).

other_angle (bool) – Toggles between the two possible angles defined by two points and an arc center. If set to False (default), the arc will always go counterclockwise from the point on line1 until the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2.

dot (bool) – Allows for a Dot in the arc. Mainly used as an convention to indicate a right angle. The dot can be customized in the next three parameters.

dot_radius (float | None) – The radius of the Dot. If not specified otherwise, this radius will be 1/10 of the arc radius.

dot_distance (float) – Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself.

dot_color (ParsableManimColor) – The color of the Dot.

elbow (bool) – Produces an elbow-type mobject indicating a right angle, see RightAngle for more information and a shorthand.

**kwargs – Further keyword arguments that are passed to the constructor of Arc or Elbow.

Examples

The first example shows some right angles with a dot in the middle while the second example shows all 8 possible angles defined by two lines.

Example: RightArcAngleExample 

../_images/RightArcAngleExample-1.png
from manim import *

class RightArcAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightarcangles = [
            Angle(line1, line2, dot=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
        ]
        plots = VGroup()
        for angle in rightarcangles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)
Make interactive
Example: AngleExample 

../_images/AngleExample-1.png
from manim import *

class AngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )
        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )
        angles = [
            Angle(line1, line2),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),
            Angle(line1, line2, other_angle=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
        ]
        plots = VGroup()
        for angle in angles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))
        plots.arrange_in_grid(rows=2,buff=1)
        self.add(plots)
Make interactive
Example: FilledAngle 

../_images/FilledAngle-1.png
from manim import *

class FilledAngle(Scene):
    def construct(self):
        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)
        l2 = (
            Line(ORIGIN, 2 * UP + RIGHT)
            .set_color(GREEN)
            .rotate(-20 * DEGREES, about_point=ORIGIN)
        )
        norm = l1.get_length()
        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)
        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)
        q1 = a1.points #  save all coordinates of points of angle a1
        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)
        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point
        mfill = VMobject().set_color(ORANGE)
        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)
        self.add(l1, l2)
        self.add(mfill)
Make interactive
Methods

from_three_points

The angle between the lines AB and BC.

get_lines

Get the lines forming an angle of the Angle class.

get_value

Get the value of an angle of the Angle class.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(line1, line2, radius=None, quadrant=(1, 1), other_angle=False, dot=False, dot_radius=None, dot_distance=0.55, dot_color=ManimColor('#FFFFFF'), elbow=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
line1 (Line)

line2 (Line)

radius (float | None)

quadrant (Point2D)

other_angle (bool)

dot (bool)

dot_radius (float | None)

dot_distance (float)

dot_color (ParsableManimColor)

elbow (bool)

Return type:
None

static from_three_points(A, B, C, **kwargs)[source]
The angle between the lines AB and BC.

This constructs the angle 
.

Parameters:
A (Point3D) – The endpoint of the first angle leg

B (Point3D) – The vertex of the angle

C (Point3D) – The endpoint of the second angle leg

**kwargs – Further keyword arguments are passed to Angle

Returns:
Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8), Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),

Return type:
The Angle calculated from the three points

Examples

Example: AngleFromThreePointsExample 

../_images/AngleFromThreePointsExample-1.png
from manim import *

class AngleFromThreePointsExample(Scene):
    def construct(self):
        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)
        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)
        self.add(red_angle, sample_angle)
Make interactive
get_lines()[source]
Get the lines forming an angle of the Angle class.

Returns:
A VGroup containing the lines that form the angle of the Angle class.

Return type:
VGroup

Examples

line_1, line_2 = Line(ORIGIN, RIGHT), Line(ORIGIN, UR)
angle = Angle(line_1, line_2)
angle.get_lines()
VGroup(Line, Line)
get_value(degrees=False)[source]
Get the value of an angle of the Angle class.

Parameters:
degrees (bool) – A boolean to decide the unit (deg/rad) in which the value of the angle is returned.

Returns:
The value in degrees/radians of an angle of the Angle class.

Return type:
float

Examples

Example: GetValueExample 

../_images/GetValueExample-1.png
from manim import *

class GetValueExample(Scene):
    def construct(self):
        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)
        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)

        angle = Angle(line1, line2, radius=0.4)

        value = DecimalNumber(angle.get_value(degrees=True), unit="^{\circ}")
        value.next_to(angle, UR)

        self.add(line1, line2, angle, value)

Arrow
Qualified name: manim.mobject.geometry.line.Arrow

class Arrow(*args, stroke_width=6, buff=0.25, max_tip_length_to_length_ratio=0.25, max_stroke_width_to_length_ratio=5, **kwargs)[source]
Bases: Line

An arrow.

Parameters:
args – Arguments to be passed to Line.

stroke_width (float) – The thickness of the arrow. Influenced by max_stroke_width_to_length_ratio.

buff (float) – The distance of the arrow from its start and end points.

max_tip_length_to_length_ratio (float) – tip_length scales with the length of the arrow. Increasing this ratio raises the max value of tip_length.

max_stroke_width_to_length_ratio (float) – stroke_width scales with the length of the arrow. Increasing this ratio ratios the max value of stroke_width.

kwargs – Additional arguments to be passed to Line.

See also

ArrowTip CurvedArrow

Examples

Example: ArrowExample 

../_images/ArrowExample-1.png
from manim import *

from manim.mobject.geometry.tips import ArrowSquareTip
class ArrowExample(Scene):
    def construct(self):
        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)
        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)
        g1 = Group(arrow_1, arrow_2)

        # the effect of buff
        square = Square(color=MAROON_A)
        arrow_3 = Arrow(start=LEFT, end=RIGHT)
        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)
        g2 = Group(arrow_3, arrow_4, square)

        # a shorter arrow has a shorter tip and smaller stroke width
        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)
        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)
        g3 = Group(arrow_5, arrow_6)

        self.add(Group(g1, g2, g3).arrange(buff=2))
Make interactive
Example: ArrowExample 

../_images/ArrowExample-2.png
from manim import *

class ArrowExample(Scene):
    def construct(self):
        left_group = VGroup()
        # As buff increases, the size of the arrow decreases.
        for buff in np.arange(0, 2.2, 0.45):
            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)
        # Required to arrange arrows.
        left_group.arrange(DOWN)
        left_group.move_to(4 * LEFT)

        middle_group = VGroup()
        # As max_stroke_width_to_length_ratio gets bigger,
        # the width of stroke increases.
        for i in np.arange(0, 5, 0.5):
            middle_group += Arrow(max_stroke_width_to_length_ratio=i)
        middle_group.arrange(DOWN)

        UR_group = VGroup()
        # As max_tip_length_to_length_ratio increases,
        # the length of the tip increases.
        for i in np.arange(0, 0.3, 0.1):
            UR_group += Arrow(max_tip_length_to_length_ratio=i)
        UR_group.arrange(DOWN)
        UR_group.move_to(4 * RIGHT + 2 * UP)

        DR_group = VGroup()
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)
        DR_group.arrange(DOWN)
        DR_group.move_to(4 * RIGHT + 2 * DOWN)

        self.add(left_group, middle_group, UR_group, DR_group)
Make interactive
Methods

get_default_tip_length

Returns the default tip_length of the arrow.

get_normal_vector

Returns the normal of a vector.

reset_normal_vector

Resets the normal of a vector

scale

Scale an arrow, but keep stroke width and arrow tip size fixed.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*args, stroke_width=6, buff=0.25, max_tip_length_to_length_ratio=0.25, max_stroke_width_to_length_ratio=5, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
stroke_width (float)

buff (float)

max_tip_length_to_length_ratio (float)

max_stroke_width_to_length_ratio (float)

Return type:
None

_set_stroke_width_from_length()[source]
Sets stroke width based on length.

Return type:
Self

get_default_tip_length()[source]
Returns the default tip_length of the arrow.

Examples

Arrow().get_default_tip_length()
0.35
Return type:
float

get_normal_vector()[source]
Returns the normal of a vector.

Examples

np.round(Arrow().get_normal_vector()) + 0. # add 0. to avoid negative 0 in output
array([ 0.,  0., -1.])
Return type:
Vector3D

reset_normal_vector()[source]
Resets the normal of a vector

Return type:
Self

scale(factor, scale_tips=False, **kwargs)[source]
Scale an arrow, but keep stroke width and arrow tip size fixed.

See also

scale()

Examples

arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
scaled_arrow = arrow.scale(2)
np.round(scaled_arrow.get_start_and_end(), 8) + 0
array([[-2., -2.,  0.],
       [ 2.,  2.,  0.]])
arrow.tip.length == scaled_arrow.tip.length
True
Manually scaling the object using the default method scale() does not have the same properties:

new_arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
another_scaled_arrow = VMobject.scale(new_arrow, 2)
another_scaled_arrow.tip.length == arrow.tip.length
False
Parameters:
factor (float)

scale_tips (bool)

Return type:
Self

DashedLine
Qualified name: manim.mobject.geometry.line.DashedLine

class DashedLine(*args, dash_length=0.05, dashed_ratio=0.5, **kwargs)[source]
Bases: Line

A dashed Line.

Parameters:
args – Arguments to be passed to Line

dash_length (float) – The length of each individual dash of the line.

dashed_ratio (float) – The ratio of dash space to empty space. Range of 0-1.

kwargs – Additional arguments to be passed to Line

See also

DashedVMobject

Examples

Example: DashedLineExample 

../_images/DashedLineExample-1.png
from manim import *

class DashedLineExample(Scene):
    def construct(self):
        # dash_length increased
        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)
        # normal
        dashed_2 = DashedLine(config.left_side, config.right_side)
        # dashed_ratio decreased
        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)
        self.add(dashed_1, dashed_2, dashed_3)
Make interactive
Methods

get_end

Returns the end point of the line.

get_first_handle

Returns the point of the first handle.

get_last_handle

Returns the point of the last handle.

get_start

Returns the start point of the line.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_calculate_num_dashes()[source]
Returns the number of dashes in the dashed line.

Examples

DashedLine()._calculate_num_dashes()
20
Return type:
int

_original__init__(*args, dash_length=0.05, dashed_ratio=0.5, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
dash_length (float)

dashed_ratio (float)

Return type:
None

get_end()[source]
Returns the end point of the line.

Examples

DashedLine().get_end()
array([1., 0., 0.])
Return type:
Point3D

get_first_handle()[source]
Returns the point of the first handle.

Examples

DashedLine().get_first_handle()
array([-0.98333333,  0.        ,  0.        ])
Return type:
Point3D

get_last_handle()[source]
Returns the point of the last handle.

Examples

DashedLine().get_last_handle()
array([0.98333333, 0.        , 0.        ])
Return type:
Point3D

get_start()[source]
Returns the start point of the line.

Examples

DashedLine().get_start()
array([-1.,  0.,  0.])
Return type:
Point3D

DoubleArrow
Qualified name: manim.mobject.geometry.line.DoubleArrow

class DoubleArrow(*args, **kwargs)[source]
Bases: Arrow

An arrow with tips on both ends.

Parameters:
args – Arguments to be passed to Arrow

kwargs – Additional arguments to be passed to Arrow

See also

ArrowTip CurvedDoubleArrow

Examples

Example: DoubleArrowExample 

../_images/DoubleArrowExample-1.png
from manim import *

from manim.mobject.geometry.tips import ArrowCircleFilledTip
class DoubleArrowExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())
        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)
        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)
        self.add(group)
Make interactive
Example: DoubleArrowExample2 

../_images/DoubleArrowExample2-1.png
from manim import *

class DoubleArrowExample2(Scene):
    def construct(self):
        box = Square()
        p1 = box.get_left()
        p2 = box.get_right()
        d1 = DoubleArrow(p1, p2, buff=0)
        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)
        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)
        Group(d1, d2, d3).arrange(DOWN)
        self.add(box, d1, d2, d3)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*args, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Return type:
None

Elbow
Qualified name: manim.mobject.geometry.line.Elbow

class Elbow(width=0.2, angle=0, **kwargs)[source]
Bases: VMobject

Two lines that create a right angle about each other: L-shape.

Parameters:
width (float) – The length of the elbow’s sides.

angle (float) – The rotation of the elbow.

kwargs – Additional arguments to be passed to VMobject

seealso:: (..) – RightAngle

Examples

Example: ElbowExample 

../_images/ElbowExample-1.png
from manim import *

class ElbowExample(Scene):
    def construct(self):
        elbow_1 = Elbow()
        elbow_2 = Elbow(width=2.0)
        elbow_3 = Elbow(width=2.0, angle=5*PI/4)

        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)
        self.add(elbow_group)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(width=0.2, angle=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
width (float)

angle (float)

Return type:
None

Line
Qualified name: manim.mobject.geometry.line.Line

class Line(start=array([-1., 0., 0.]), end=array([1., 0., 0.]), buff=0, path_arc=None, **kwargs)[source]
Bases: TipableVMobject

Methods

generate_points

Initializes points and therefore the shape.

get_angle

get_projection

Returns the projection of a point onto a line.

get_slope

get_unit_vector

get_vector

init_points

Initializes points and therefore the shape.

put_start_and_end_on

Sets starts and end coordinates of a line.

set_angle

set_length

set_path_arc

set_points_by_ends

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
start (Point3D)

end (Point3D)

buff (float)

path_arc (float | None)

_original__init__(start=array([-1., 0., 0.]), end=array([1., 0., 0.]), buff=0, path_arc=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
start (Point3D)

end (Point3D)

buff (float)

path_arc (float | None)

Return type:
None

_pointify(mob_or_point, direction=None)[source]
Transforms a mobject into its corresponding point. Does nothing if a point is passed.

direction determines the location of the point along its bounding box in that direction.

Parameters:
mob_or_point (Mobject | Point3D) – The mobject or point.

direction (Vector3D | None) – The direction.

Return type:
Point3D

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

get_projection(point)[source]
Returns the projection of a point onto a line.

Parameters:
point (Point3D) – The point to which the line is projected.

Return type:
Vector3D

init_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

put_start_and_end_on(start, end)[source]
Sets starts and end coordinates of a line.

Examples

Example: LineExample 

from manim import *

class LineExample(Scene):
    def construct(self):
        d = VGroup()
        for i in range(0,10):
            d.add(Dot())
        d.arrange_in_grid(buff=1)
        self.add(d)
        l= Line(d[0], d[1])
        self.add(l)
        self.wait()
        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())
        self.wait()
        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())
        self.wait()
Make interactive
Parameters:
start (Point3D)

end (Point3D)

Return type:
Self

RightAngle
Qualified name: manim.mobject.geometry.line.RightAngle

class RightAngle(line1, line2, length=None, **kwargs)[source]
Bases: Angle

An elbow-type mobject representing a right angle between two lines.

Parameters:
line1 (Line) – The first line.

line2 (Line) – The second line.

length (float | None) – The length of the arms.

**kwargs – Further keyword arguments that are passed to the constructor of Angle.

Examples

Example: RightAngleExample 

../_images/RightAngleExample-1.png
from manim import *

class RightAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightangles = [
            RightAngle(line1, line2),
            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),
            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),
            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),
        ]
        plots = VGroup()
        for rightangle in rightangles:
            plot=VGroup(line1.copy(),line2.copy(), rightangle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(line1, line2, length=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
line1 (Line)

line2 (Line)

length (float | None)

Return type:
None

TangentLine
Qualified name: manim.mobject.geometry.line.TangentLine

class TangentLine(vmob, alpha, length=1, d_alpha=1e-06, **kwargs)[source]
Bases: Line

Constructs a line tangent to a VMobject at a specific point.

Parameters:
vmob (VMobject) – The VMobject on which the tangent line is drawn.

alpha (float) – How far along the shape that the line will be constructed. range: 0-1.

length (float) – Length of the tangent line.

d_alpha (float) – The dx value

kwargs – Additional arguments to be passed to Line

See also

point_from_proportion()

Examples

Example: TangentLineExample 

../_images/TangentLineExample-1.png
from manim import *

class TangentLineExample(Scene):
    def construct(self):
        circle = Circle(radius=2)
        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right
        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left
        self.add(circle, line_1, line_2)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(vmob, alpha, length=1, d_alpha=1e-06, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmob (VMobject)

alpha (float)

length (float)

d_alpha (float)

Return type:
None

Vector
Qualified name: manim.mobject.geometry.line.Vector

class Vector(direction=array([1., 0., 0.]), buff=0, **kwargs)[source]
Bases: Arrow

A vector specialized for use in graphs.

Caution

Do not confuse with the Vector2D, Vector3D or VectorND type aliases, which are not Mobjects!

Parameters:
direction (Point2D | Point3D) – The direction of the arrow.

buff (float) – The distance of the vector from its endpoints.

kwargs – Additional arguments to be passed to Arrow

Examples

Example: VectorExample 

../_images/VectorExample-1.png
from manim import *

class VectorExample(Scene):
    def construct(self):
        plane = NumberPlane()
        vector_1 = Vector([1,2])
        vector_2 = Vector([-5,-2])
        self.add(plane, vector_1, vector_2)
Make interactive
Methods

coordinate_label

Creates a label based on the coordinates of the vector.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(direction=array([1., 0., 0.]), buff=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
direction (Point2D | Point3D)

buff (float)

Return type:
None

coordinate_label(integer_labels=True, n_dim=2, color=None, **kwargs)[source]
Creates a label based on the coordinates of the vector.

Parameters:
integer_labels (bool) – Whether or not to round the coordinates to integers.

n_dim (int) – The number of dimensions of the vector.

color (ParsableManimColor | None) – Sets the color of label, optional.

kwargs – Additional arguments to be passed to Matrix.

Returns:
The label.

Return type:
Matrix

Examples

Example: VectorCoordinateLabel 

../_images/VectorCoordinateLabel-1.png
from manim import *

class VectorCoordinateLabel(Scene):
    def construct(self):
        plane = NumberPlane()

        vec_1 = Vector([1, 2])
        vec_2 = Vector([-3, -2])
        label_1 = vec_1.coordinate_label()
        label_2 = vec_2.coordinate_label(color=YELLOW)

        self.add(plane, vec_1, vec_2, label_1, label_2)

polygram
Mobjects that are simple geometric shapes.

Classes

Cutout

A shape with smaller cutouts.

Polygon

A shape consisting of one closed loop of vertices.

Polygram

A generalized Polygon, allowing for disconnected sets of edges.

Rectangle

A quadrilateral with two sets of parallel sides.

RegularPolygon

An n-sided regular Polygon.

RegularPolygram

A Polygram with regularly spaced vertices.

RoundedRectangle

A rectangle with rounded corners.

Square

A rectangle with equal side lengths.

Star

A regular polygram without the intersecting lines.

Triangle

An equilateral triangle.

Cutout
Qualified name: manim.mobject.geometry.polygram.Cutout

class Cutout(main_shape, *mobjects, **kwargs)[source]
Bases: VMobject

A shape with smaller cutouts.

Parameters:
main_shape (VMobject) – The primary shape from which cutouts are made.

mobjects (VMobject) – The smaller shapes which are to be cut out of the main_shape.

kwargs – Further keyword arguments that are passed to the constructor of VMobject.

Warning

Technically, this class behaves similar to a symmetric difference: if parts of the mobjects are not located within the main_shape, these parts will be added to the resulting VMobject.

Examples

Example: CutoutExample 

from manim import *

class CutoutExample(Scene):
    def construct(self):
        s1 = Square().scale(2.5)
        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)
        s3 = Square().shift(UP + RIGHT).scale(0.5)
        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)
        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)
        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)
        self.play(Write(c), run_time=4)
        self.wait()
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(main_shape, *mobjects, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
main_shape (VMobject)

mobjects (VMobject)

Return type:
None

Polygon
Qualified name: manim.mobject.geometry.polygram.Polygon

class Polygon(*vertices, **kwargs)[source]
Bases: Polygram

A shape consisting of one closed loop of vertices.

Parameters:
vertices (Point3D) – The vertices of the Polygon.

kwargs – Forwarded to the parent constructor.

Examples

Example: PolygonExample 

../_images/PolygonExample-1.png
from manim import *

class PolygonExample(Scene):
    def construct(self):
        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])
        position_list = [
            [4, 1, 0],  # middle right
            [4, -2.5, 0],  # bottom right
            [0, -2.5, 0],  # bottom left
            [0, 3, 0],  # top left
            [2, 1, 0],  # middle
            [4, 3, 0],  # top right
        ]
        square_and_triangles = Polygon(*position_list, color=PURPLE_B)
        self.add(isosceles, square_and_triangles)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*vertices, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertices (Point3D)

Return type:
None

Polygram
Qualified name: manim.mobject.geometry.polygram.Polygram

class Polygram(*vertex_groups, color=ManimColor('#58C4DD'), **kwargs)[source]
Bases: VMobject

A generalized Polygon, allowing for disconnected sets of edges.

Parameters:
vertex_groups (Point3D) –

The groups of vertices making up the Polygram.

The first vertex in each group is repeated to close the shape. Each point must be 3-dimensional: [x,y,z]

color (ParsableManimColor) – The color of the Polygram.

kwargs – Forwarded to the parent constructor.

Examples

Example: PolygramExample 

from manim import *

import numpy as np

class PolygramExample(Scene):
    def construct(self):
        hexagram = Polygram(
            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],
            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],
        )
        self.add(hexagram)

        dot = Dot()
        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)
        self.remove(dot)
        self.wait()
Make interactive
Methods

get_vertex_groups

Gets the vertex groups of the Polygram.

get_vertices

Gets the vertices of the Polygram.

round_corners

Rounds off the corners of the Polygram.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*vertex_groups, color=ManimColor('#58C4DD'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertex_groups (Point3D)

color (ParsableManimColor)

get_vertex_groups()[source]
Gets the vertex groups of the Polygram.

Returns:
The vertex groups of the Polygram.

Return type:
numpy.ndarray

Examples

poly = Polygram([ORIGIN, RIGHT, UP], [LEFT, LEFT + UP, 2 * LEFT])
poly.get_vertex_groups()
array([[[ 0.,  0.,  0.],
        [ 1.,  0.,  0.],
        [ 0.,  1.,  0.]],

       [[-1.,  0.,  0.],
        [-1.,  1.,  0.],
        [-2.,  0.,  0.]]])
get_vertices()[source]
Gets the vertices of the Polygram.

Returns:
The vertices of the Polygram.

Return type:
numpy.ndarray

Examples

sq = Square()
sq.get_vertices()
array([[ 1.,  1.,  0.],
       [-1.,  1.,  0.],
       [-1., -1.,  0.],
       [ 1., -1.,  0.]])
round_corners(radius=0.5, evenly_distribute_anchors=False, components_per_rounded_corner=2)[source]
Rounds off the corners of the Polygram.

Parameters:
radius (float | list[float]) – The curvature of the corners of the Polygram.

evenly_distribute_anchors (bool) – Break long line segments into proportionally-sized segments.

components_per_rounded_corner (int) – The number of points used to represent the rounded corner curve.

Return type:
Self

See also

RoundedRectangle

Note

If radius is supplied as a single value, then the same radius will be applied to all corners. If radius is a list, then the individual values will be applied sequentially, with the first corner receiving radius[0], the second corner receiving radius[1], etc. The radius list will be repeated as necessary.

The components_per_rounded_corner value is provided so that the fidelity of the rounded corner may be fine-tuned as needed. 2 is an appropriate value for most shapes, however a larger value may be need if the rounded corner is particularly large. 2 is the minimum number allowed, representing the start and end of the curve. 3 will result in a start, middle, and end point, meaning 2 curves will be generated.

The option to evenly_distribute_anchors is provided so that the line segments (the part part of each line remaining after rounding off the corners) can be subdivided to a density similar to that of the average density of the rounded corners. This may be desirable in situations in which an even distribution of curves is desired for use in later transformation animations. Be aware, though, that enabling this option can result in an an object containing significantly more points than the original, especially when the rounded corner curves are small.

Examples

Example: PolygramRoundCorners 

../_images/PolygramRoundCorners-1.png
from manim import *

class PolygramRoundCorners(Scene):
    def construct(self):
        star = Star(outer_radius=2)

        shapes = VGroup(star)
        shapes.add(star.copy().round_corners(radius=0.1))
        shapes.add(star.copy().round_corners(radius=0.25))

        shapes.arrange(RIGHT)
        self.add(shapes)

Rectangle
Qualified name: manim.mobject.geometry.polygram.Rectangle

class Rectangle(color=ManimColor('#FFFFFF'), height=2.0, width=4.0, grid_xstep=None, grid_ystep=None, mark_paths_closed=True, close_new_points=True, **kwargs)[source]
Bases: Polygon

A quadrilateral with two sets of parallel sides.

Parameters:
color (ParsableManimColor) – The color of the rectangle.

height (float) – The vertical height of the rectangle.

width (float) – The horizontal width of the rectangle.

grid_xstep (float | None) – Space between vertical grid lines.

grid_ystep (float | None) – Space between horizontal grid lines.

mark_paths_closed (bool) – No purpose.

close_new_points (bool) – No purpose.

kwargs – Additional arguments to be passed to Polygon

Examples

Example: RectangleExample 

../_images/RectangleExample-1.png
from manim import *

class RectangleExample(Scene):
    def construct(self):
        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)
        rect2 = Rectangle(width=1.0, height=4.0)
        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)
        rect3.grid_lines.set_stroke(width=1)

        rects = Group(rect1, rect2, rect3).arrange(buff=1)
        self.add(rects)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(color=ManimColor('#FFFFFF'), height=2.0, width=4.0, grid_xstep=None, grid_ystep=None, mark_paths_closed=True, close_new_points=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
color (ParsableManimColor)

height (float)

width (float)

grid_xstep (float | None)

grid_ystep (float | None)

mark_paths_closed (bool)

close_new_points (bool)

RegularPolygon
Qualified name: manim.mobject.geometry.polygram.RegularPolygon

class RegularPolygon(n=6, **kwargs)[source]
Bases: RegularPolygram

An n-sided regular Polygon.

Parameters:
n (int) – The number of sides of the RegularPolygon.

kwargs – Forwarded to the parent constructor.

Examples

Example: RegularPolygonExample 

../_images/RegularPolygonExample-1.png
from manim import *

class RegularPolygonExample(Scene):
    def construct(self):
        poly_1 = RegularPolygon(n=6)
        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)
        poly_3 = RegularPolygon(n=10, color=RED)

        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)
        self.add(poly_group)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(n=6, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
n (int)

Return type:
None

RegularPolygram
Qualified name: manim.mobject.geometry.polygram.RegularPolygram

class RegularPolygram(num_vertices, *, density=2, radius=1, start_angle=None, **kwargs)[source]
Bases: Polygram

A Polygram with regularly spaced vertices.

Parameters:
num_vertices (int) – The number of vertices.

density (int) –

The density of the RegularPolygram.

Can be thought of as how many vertices to hop to draw a line between them. Every density-th vertex is connected.

radius (float) – The radius of the circle that the vertices are placed on.

start_angle (float | None) – The angle the vertices start at; the rotation of the RegularPolygram.

kwargs – Forwarded to the parent constructor.

Examples

Example: RegularPolygramExample 

../_images/RegularPolygramExample-1.png
from manim import *

class RegularPolygramExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        self.add(pentagram)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(num_vertices, *, density=2, radius=1, start_angle=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
num_vertices (int)

density (int)

radius (float)

start_angle (float | None)

Return type:
None

RoundedRectangle
Qualified name: manim.mobject.geometry.polygram.RoundedRectangle

class RoundedRectangle(corner_radius=0.5, **kwargs)[source]
Bases: Rectangle

A rectangle with rounded corners.

Parameters:
corner_radius (float | list[float]) – The curvature of the corners of the rectangle.

kwargs – Additional arguments to be passed to Rectangle

Examples

Example: RoundedRectangleExample 

../_images/RoundedRectangleExample-1.png
from manim import *

class RoundedRectangleExample(Scene):
    def construct(self):
        rect_1 = RoundedRectangle(corner_radius=0.5)
        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)

        rect_group = Group(rect_1, rect_2).arrange(buff=1)
        self.add(rect_group)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(corner_radius=0.5, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
corner_radius (float | list[float])

Square
Qualified name: manim.mobject.geometry.polygram.Square

class Square(side_length=2.0, **kwargs)[source]
Bases: Rectangle

A rectangle with equal side lengths.

Parameters:
side_length (float) – The length of the sides of the square.

kwargs – Additional arguments to be passed to Rectangle.

Examples

Example: SquareExample 

../_images/SquareExample-1.png
from manim import *

class SquareExample(Scene):
    def construct(self):
        square_1 = Square(side_length=2.0).shift(DOWN)
        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)
        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)
        self.add(square_1, square_2, square_3)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(side_length=2.0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
side_length (float)

Return type:
None

Star
Qualified name: manim.mobject.geometry.polygram.Star

class Star(n=5, *, outer_radius=1, inner_radius=None, density=2, start_angle=1.5707963267948966, **kwargs)[source]
Bases: Polygon

A regular polygram without the intersecting lines.

Parameters:
n (int) – How many points on the Star.

outer_radius (float) – The radius of the circle that the outer vertices are placed on.

inner_radius (float | None) –

The radius of the circle that the inner vertices are placed on.

If unspecified, the inner radius will be calculated such that the edges of the Star perfectly follow the edges of its RegularPolygram counterpart.

density (int) –

The density of the Star. Only used if inner_radius is unspecified.

See RegularPolygram for more information.

start_angle (float | None) – The angle the vertices start at; the rotation of the Star.

kwargs – Forwardeds to the parent constructor.

Raises:
ValueError – If inner_radius is unspecified and density is not in the range [1, n/2).

Examples

Example: StarExample 

../_images/StarExample-1.gif
from manim import *

class StarExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        star = Star(outer_radius=2, color=RED)

        self.add(pentagram)
        self.play(Create(star), run_time=3)
        self.play(FadeOut(star), run_time=2)
Make interactive
Example: DifferentDensitiesExample 

../_images/DifferentDensitiesExample-1.png
from manim import *

class DifferentDensitiesExample(Scene):
    def construct(self):
        density_2 = Star(7, outer_radius=2, density=2, color=RED)
        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)

        self.add(VGroup(density_2, density_3).arrange(RIGHT))
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(n=5, *, outer_radius=1, inner_radius=None, density=2, start_angle=1.5707963267948966, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
n (int)

outer_radius (float)

inner_radius (float | None)

density (int)

start_angle (float | None)

Return type:
None

Triangle
Qualified name: manim.mobject.geometry.polygram.Triangle

class Triangle(**kwargs)[source]
Bases: RegularPolygon

An equilateral triangle.

Parameters:
kwargs – Additional arguments to be passed to RegularPolygon

Examples

Example: TriangleExample 

../_images/TriangleExample-1.png
from manim import *

class TriangleExample(Scene):
    def construct(self):
        triangle_1 = Triangle()
        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)
        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)
        self.add(tri_group)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(**kwargs)
Initialize self. See help(type(self)) for accurate signature.

Return type:
None

shape_matchers
Mobjects used to mark and annotate other mobjects.

Classes

BackgroundRectangle

A background rectangle.

Cross

Creates a cross.

SurroundingRectangle

A rectangle surrounding a Mobject

Underline

Creates an underline.

BackgroundRectangle
Qualified name: manim.mobject.geometry.shape\_matchers.BackgroundRectangle

class BackgroundRectangle(mobject, color=None, stroke_width=0, stroke_opacity=0, fill_opacity=0.75, buff=0, **kwargs)[source]
Bases: SurroundingRectangle

A background rectangle. Its default color is the background color of the scene.

Examples

Example: ExampleBackgroundRectangle 

../_images/ExampleBackgroundRectangle-1.png
from manim import *

class ExampleBackgroundRectangle(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        circle.set_stroke(color=GREEN, width=20)
        triangle = Triangle().shift(2 * RIGHT)
        triangle.set_fill(PINK, opacity=0.5)
        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)
        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)
        self.add(backgroundRectangle1)
        self.add(backgroundRectangle2)
        self.add(circle)
        self.add(triangle)
        self.play(Rotate(backgroundRectangle1, PI / 4))
        self.play(Rotate(backgroundRectangle2, PI / 2))
Make interactive
Methods

get_fill_color

If there are multiple colors (for gradient) this returns the first one

pointwise_become_partial

Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject passed as parameter with respect to the bounds.

set_style

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
mobject (Mobject)

color (ParsableManimColor | None)

stroke_width (float)

stroke_opacity (float)

fill_opacity (float)

buff (float)

_original__init__(mobject, color=None, stroke_width=0, stroke_opacity=0, fill_opacity=0.75, buff=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mobject (Mobject)

color (ParsableManimColor | None)

stroke_width (float)

stroke_opacity (float)

fill_opacity (float)

buff (float)

get_fill_color()[source]
If there are multiple colors (for gradient) this returns the first one

Return type:
ManimColor

pointwise_become_partial(mobject, a, b)[source]
Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject passed as parameter with respect to the bounds. Points here stand for control points of the bezier curves (anchors and handles)

Parameters:
vmobject – The vmobject that will serve as a model.

a (Any) – upper-bound.

b (float) – lower-bound

mobject (Mobject)

Returns:
self

Return type:
VMobject

Cross
Qualified name: manim.mobject.geometry.shape\_matchers.Cross

class Cross(mobject=None, stroke_color=ManimColor('#FC6255'), stroke_width=6.0, scale_factor=1.0, **kwargs)[source]
Bases: VGroup

Creates a cross.

Parameters:
mobject (Mobject | None) – The mobject linked to this instance. It fits the mobject when specified. Defaults to None.

stroke_color (ParsableManimColor) – Specifies the color of the cross lines. Defaults to RED.

stroke_width (float) – Specifies the width of the cross lines. Defaults to 6.

scale_factor (float) – Scales the cross to the provided units. Defaults to 1.

Examples

Example: ExampleCross 

../_images/ExampleCross-1.png
from manim import *

class ExampleCross(Scene):
    def construct(self):
        cross = Cross()
        self.add(cross)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(mobject=None, stroke_color=ManimColor('#FC6255'), stroke_width=6.0, scale_factor=1.0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mobject (Mobject | None)

stroke_color (ParsableManimColor)

stroke_width (float)

scale_factor (float)

Return type:
None

SurroundingRectangle
Qualified name: manim.mobject.geometry.shape\_matchers.SurroundingRectangle

class SurroundingRectangle(mobject, color=ManimColor('#FFFF00'), buff=0.1, corner_radius=0.0, **kwargs)[source]
Bases: RoundedRectangle

A rectangle surrounding a Mobject

Examples

Example: SurroundingRectExample 

../_images/SurroundingRectExample-1.png
from manim import *

class SurroundingRectExample(Scene):
    def construct(self):
        title = Title("A Quote from Newton")
        quote = Text(
            "If I have seen further than others, \n"
            "it is by standing upon the shoulders of giants.",
            color=BLUE,
        ).scale(0.75)
        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)

        t2 = Tex(r"Hello World").scale(1.5)
        box2 = SurroundingRectangle(t2, corner_radius=0.2)
        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)
        self.add(title, mobjects)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
mobject (Mobject)

color (ParsableManimColor)

buff (float)

corner_radius (float)

_original__init__(mobject, color=ManimColor('#FFFF00'), buff=0.1, corner_radius=0.0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mobject (Mobject)

color (ParsableManimColor)

buff (float)

corner_radius (float)

Return type:
None

Underline
Qualified name: manim.mobject.geometry.shape\_matchers.Underline

class Underline(mobject, buff=0.1, **kwargs)[source]
Bases: Line

Creates an underline.

Examples

Example: UnderLine 

../_images/UnderLine-1.png
from manim import *

class UnderLine(Scene):
    def construct(self):
        man = Tex("Manim")  # Full Word
        ul = Underline(man)  # Underlining the word
        self.add(man, ul)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
mobject (Mobject)

buff (float)

_original__init__(mobject, buff=0.1, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mobject (Mobject)

buff (float)

Return type:
None

tips
A collection of tip mobjects for use with TipableVMobject.

Classes

ArrowCircleFilledTip

Circular arrow tip with filled tip.

ArrowCircleTip

Circular arrow tip.

ArrowSquareFilledTip

Square arrow tip with filled tip.

ArrowSquareTip

Square arrow tip.

ArrowTip

Base class for arrow tips.

ArrowTriangleFilledTip

Triangular arrow tip with filled tip.

ArrowTriangleTip

Triangular arrow tip.

StealthTip

'Stealth' fighter / kite arrow shape.

ArrowCircleFilledTip
Qualified name: manim.mobject.geometry.tips.ArrowCircleFilledTip

class ArrowCircleFilledTip(fill_opacity=1, stroke_width=0, **kwargs)[source]
Bases: ArrowCircleTip

Circular arrow tip with filled tip.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

_original__init__(fill_opacity=1, stroke_width=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

Return type:
None

ArrowCircleTip
Qualified name: manim.mobject.geometry.tips.ArrowCircleTip

class ArrowCircleTip(fill_opacity=0, stroke_width=3, length=0.35, start_angle=3.141592653589793, **kwargs)[source]
Bases: ArrowTip, Circle

Circular arrow tip.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

start_angle (float)

_original__init__(fill_opacity=0, stroke_width=3, length=0.35, start_angle=3.141592653589793, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

start_angle (float)

Return type:
None

ArrowSquareFilledTip
Qualified name: manim.mobject.geometry.tips.ArrowSquareFilledTip

class ArrowSquareFilledTip(fill_opacity=1, stroke_width=0, **kwargs)[source]
Bases: ArrowSquareTip

Square arrow tip with filled tip.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

_original__init__(fill_opacity=1, stroke_width=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

Return type:
None

ArrowSquareTip
Qualified name: manim.mobject.geometry.tips.ArrowSquareTip

class ArrowSquareTip(fill_opacity=0, stroke_width=3, length=0.35, start_angle=3.141592653589793, **kwargs)[source]
Bases: ArrowTip, Square

Square arrow tip.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

start_angle (float)

_original__init__(fill_opacity=0, stroke_width=3, length=0.35, start_angle=3.141592653589793, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

start_angle (float)

Return type:
None

ArrowTip
Qualified name: manim.mobject.geometry.tips.ArrowTip

class ArrowTip(*args, **kwargs)[source]
Bases: VMobject

Base class for arrow tips.

See also

ArrowTriangleTip ArrowTriangleFilledTip ArrowCircleTip ArrowCircleFilledTip ArrowSquareTip ArrowSquareFilledTip StealthTip

Examples

Cannot be used directly, only intended for inheritance:

tip = ArrowTip()
Traceback (most recent call last):
...
NotImplementedError: Has to be implemented in inheriting subclasses.
Instead, use one of the pre-defined ones, or make a custom one like this:

Example: CustomTipExample 

from manim import *

>>> from manim import RegularPolygon, Arrow
>>> class MyCustomArrowTip(ArrowTip, RegularPolygon):
...     def __init__(self, length=0.35, **kwargs):
...         RegularPolygon.__init__(self, n=5, **kwargs)
...         self.width = length
...         self.stretch_to_fit_height(length)
>>> arr = Arrow(np.array([-2, -2, 0]), np.array([2, 2, 0]),
...             tip_shape=MyCustomArrowTip)
>>> isinstance(arr.tip, RegularPolygon)
True
>>> from manim import Scene, Create
>>> class CustomTipExample(Scene):
...     def construct(self):
...         self.play(Create(arr))
Make interactive
Using a class inherited from ArrowTip to get a non-filled tip is a shorthand to manually specifying the arrow tip style as follows:

arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),
              tip_style={'fill_opacity': 0, 'stroke_width': 3})
The following example illustrates the usage of all of the predefined arrow tips.

Example: ArrowTipsShowcase 

../_images/ArrowTipsShowcase-1.png
from manim import *

class ArrowTipsShowcase(Scene):
    def construct(self):
        tip_names = [
            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',
            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'
        ]

        big_arrows = [
            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),
            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),
            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),
            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),

            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),
            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),
            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),
            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)
        ]

        small_arrows = (
            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows
        )

        labels = (
            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))
        )

        self.add(*big_arrows, *small_arrows, *labels)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

_original__init__(*args, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Return type:
None

property base: Point3D
The base point of the arrow tip.

This is the point connecting to the arrow line.

Examples

from manim import Arrow
arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
arrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output
array([1.65, 0.  , 0.  ])
property length: floating
The length of the arrow tip.

Examples

from manim import Arrow
arrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))
round(arrow.tip.length, 3)
0.35
property tip_angle: float
The angle of the arrow tip.

Examples

from manim import Arrow
arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)
round(arrow.tip.tip_angle, 5) == round(PI/4, 5)
True
property tip_point: Point3D
The tip point of the arrow tip.

Examples

from manim import Arrow
arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
arrow.tip.tip_point.round(2) + 0.
array([2., 0., 0.])
property vector: Vector3D
The vector pointing from the base point to the tip point.

Examples

from manim import Arrow
arrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)
arrow.tip.vector.round(2) + 0.
array([0.25, 0.25, 0.  ])

ArrowTriangleFilledTip
Qualified name: manim.mobject.geometry.tips.ArrowTriangleFilledTip

class ArrowTriangleFilledTip(fill_opacity=1, stroke_width=0, **kwargs)[source]
Bases: ArrowTriangleTip

Triangular arrow tip with filled tip.

This is the default arrow tip shape.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

_original__init__(fill_opacity=1, stroke_width=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

Return type:
None

ArrowTriangleTip
Qualified name: manim.mobject.geometry.tips.ArrowTriangleTip

class ArrowTriangleTip(fill_opacity=0, stroke_width=3, length=0.35, width=0.35, start_angle=3.141592653589793, **kwargs)[source]
Bases: ArrowTip, Triangle

Triangular arrow tip.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

width (float)

start_angle (float)

_original__init__(fill_opacity=0, stroke_width=3, length=0.35, width=0.35, start_angle=3.141592653589793, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_opacity (float)

stroke_width (float)

length (float)

width (float)

start_angle (float)

Return type:
None

StealthTip
Qualified name: manim.mobject.geometry.tips.StealthTip

class StealthTip(fill_opacity=1, stroke_width=3, length=0.175, start_angle=3.141592653589793, **kwargs)[source]
Bases: ArrowTip

‘Stealth’ fighter / kite arrow shape.

Naming is inspired by the corresponding TikZ arrow shape.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

base

The base point of the arrow tip.

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

length

The length of the arrow tip.

n_points_per_curve

sheen_factor

stroke_color

tip_angle

The angle of the arrow tip.

tip_point

The tip point of the arrow tip.

vector

The vector pointing from the base point to the tip point.

width

The width of the mobject.

_original__init__(fill_opacity=1, stroke_width=3, length=0.175, start_angle=3.141592653589793, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

property length
The length of the arrow tip.

In this case, the length is computed as the height of the triangle encompassing the stealth tip (otherwise, the tip is scaled too large).

graph
Mobjects used to represent mathematical graphs (think graph theory, not plotting).

Type Aliases

class NxGraph
nx.classes.graph.Graph | nx.classes.digraph.DiGraph
Classes

DiGraph

A directed graph.

GenericGraph

Abstract base class for graphs (that is, a collection of vertices connected with edges).

Graph

An undirected graph (vertices connected with edges).

LayoutFunction

A protocol for automatic layout functions that compute a layout for a graph to be used in change_layout().

DiGraph
Qualified name: manim.mobject.graph.DiGraph

class DiGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)[source]
Bases: GenericGraph

A directed graph.

Note

In contrast to undirected graphs, the order in which vertices in a given edge are specified is relevant here.

See also

GenericGraph

Parameters:
vertices (list[Hashable]) – A list of vertices. Must be hashable elements.

edges (list[tuple[Hashable, Hashable]]) – A list of edges, specified as tuples (u, v) where both u and v are vertices. The edge is directed from u to v.

labels (bool | dict) – Controls whether or not vertices are labeled. If False (the default), the vertices are not labeled; if True they are labeled using their names (as specified in vertices) via MathTex. Alternatively, custom labels can be specified by passing a dictionary whose keys are the vertices, and whose values are the corresponding vertex labels (rendered via, e.g., Text or Tex).

label_fill_color (str) – Sets the fill color of the default labels generated when labels is set to True. Has no effect for other values of labels.

layout (LayoutName | dict[Hashable, Point3D] | LayoutFunction) – Either one of "spring" (the default), "circular", "kamada_kawai", "planar", "random", "shell", "spectral", "spiral", "tree", and "partite" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value) for each vertex (key) for manual positioning.

layout_config (dict | None) – Only for automatically generated layouts. A dictionary whose entries are passed as keyword arguments to the automatic layout algorithm specified via layout of networkx. The tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary. Passing a tuple (space_x, space_y) as this argument overrides the value of layout_scale and ensures that vertices are arranged in a way such that the centers of siblings in the same layer are at least space_x units apart horizontally, and neighboring layers are spaced space_y units vertically.

layout_scale (float | tuple[float, float, float]) – The scale of automatically generated layouts: the vertices will be arranged such that the coordinates are located within the interval [-scale, scale]. Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x], and the second in [-scale_y, scale_y]. Default: 2.

vertex_type (type[Mobject]) – The mobject class used for displaying vertices in the scene.

vertex_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via vertex_type, or a dictionary whose keys are the vertices, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding vertex.

vertex_mobjects (dict | None) – A dictionary whose keys are the vertices, and whose values are mobjects to be used as vertices. Passing vertices here overrides all other configuration options for a vertex.

edge_type (type[Mobject]) – The mobject class used for displaying edges in the scene.

edge_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via edge_type, or a dictionary whose keys are the edges, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding edge. You can further customize the tip by adding a tip_config dictionary for global styling, or by adding the dict to a specific edge_config.

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

Examples

Example: MovingDiGraph 

from manim import *

class MovingDiGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]

        g = DiGraph(vertices, edges)

        self.add(g)
        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([1, -1, -1]),
            g[4].animate.move_to([-1, -1, 0]),
        )
        self.wait()
Make interactive
You can customize the edges and arrow tips globally or locally.

Example: CustomDiGraph 

from manim import *

class CustomDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            "stroke_width": 2,
            "tip_config": {
                "tip_shape": ArrowSquareTip,
                "tip_length": 0.15,
            },
            (3, 4): {
                "color": RED,
                "tip_config": {"tip_length": 0.25, "tip_width": 0.25}
            },
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout="circular",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()
Make interactive
Since this implementation respects the labels boundary you can also use it for an undirected moving graph with labels.

Example: UndirectedMovingDiGraph 

from manim import *

class UndirectedMovingDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            "stroke_width": 2,
            "tip_config": {"tip_length": 0, "tip_width": 0},
            (3, 4): {"color": RED},
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout="circular",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()

        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([-1.5, -1.5, -1]),
            g[4].animate.move_to([1, -2, -1]),
        )
        self.wait()
Make interactive
Methods

update_edges

Updates the edges to stick at their corresponding vertices.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

static _empty_networkx_graph()[source]
Return an empty networkx graph for the given graph type.

Return type:
DiGraph

_original__init__(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertices (list[Hashable])

edges (list[tuple[Hashable, Hashable]])

labels (bool | dict)

label_fill_color (str)

layout (Literal['circular', 'kamada_kawai', 'partite', 'planar', 'random', 'shell', 'spectral', 'spiral', 'spring', 'tree'] | dict[~typing.Hashable, ~manim.typing.Point3D] | ~manim.mobject.graph.LayoutFunction)

layout_scale (float | tuple[float, float, float])

layout_config (dict | None)

vertex_type (type[Mobject])

vertex_config (dict | None)

vertex_mobjects (dict | None)

edge_type (type[Mobject])

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

edge_config (dict | None)

Return type:
None

_populate_edge_dict(edges, edge_type)[source]
Helper method for populating the edges of the graph.

Parameters:
edges (list[tuple[Hashable, Hashable]])

edge_type (type[Mobject])

update_edges(graph)[source]
Updates the edges to stick at their corresponding vertices.

Arrow tips need to be repositioned since otherwise they can be deformed.

GenericGraph
Qualified name: manim.mobject.graph.GenericGraph

class GenericGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)[source]
Bases: VMobject

Abstract base class for graphs (that is, a collection of vertices connected with edges).

Graphs can be instantiated by passing both a list of (distinct, hashable) vertex names, together with list of edges (as tuples of vertex names). See the examples for concrete implementations of this class for details.

Note

This implementation uses updaters to make the edges move with the vertices.

See also

Graph, DiGraph

Parameters:
vertices (list[Hashable]) – A list of vertices. Must be hashable elements.

edges (list[tuple[Hashable, Hashable]]) – A list of edges, specified as tuples (u, v) where both u and v are vertices.

labels (bool | dict) – Controls whether or not vertices are labeled. If False (the default), the vertices are not labeled; if True they are labeled using their names (as specified in vertices) via MathTex. Alternatively, custom labels can be specified by passing a dictionary whose keys are the vertices, and whose values are the corresponding vertex labels (rendered via, e.g., Text or Tex).

label_fill_color (str) – Sets the fill color of the default labels generated when labels is set to True. Has no effect for other values of labels.

layout (LayoutName | dict[Hashable, Point3D] | LayoutFunction) – Either one of "spring" (the default), "circular", "kamada_kawai", "planar", "random", "shell", "spectral", "spiral", "tree", and "partite" for automatic vertex positioning primarily using networkx (see their documentation for more details), a dictionary specifying a coordinate (value) for each vertex (key) for manual positioning, or a .:class:~.LayoutFunction with a user-defined automatic layout.

layout_config (dict | None) – Only for automatic layouts. A dictionary whose entries are passed as keyword arguments to the named layout or automatic layout function specified via layout. The tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary. Passing a tuple (space_x, space_y) as this argument overrides the value of layout_scale and ensures that vertices are arranged in a way such that the centers of siblings in the same layer are at least space_x units apart horizontally, and neighboring layers are spaced space_y units vertically.

layout_scale (float | tuple[float, float, float]) – The scale of automatically generated layouts: the vertices will be arranged such that the coordinates are located within the interval [-scale, scale]. Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x], and the second in [-scale_y, scale_y]. Default: 2.

vertex_type (type[Mobject]) – The mobject class used for displaying vertices in the scene.

vertex_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via vertex_type, or a dictionary whose keys are the vertices, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding vertex.

vertex_mobjects (dict | None) – A dictionary whose keys are the vertices, and whose values are mobjects to be used as vertices. Passing vertices here overrides all other configuration options for a vertex.

edge_type (type[Mobject]) – The mobject class used for displaying edges in the scene.

edge_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via edge_type, or a dictionary whose keys are the edges, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding edge.

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

Methods

add_edges

Add new edges to the graph.

add_vertices

Add a list of vertices to the graph.

change_layout

Change the layout of this graph.

from_networkx

Build a Graph or DiGraph from a given networkx graph.

remove_edges

Remove several edges from the graph.

remove_vertices

Remove several vertices from the graph.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_add_edge(edge, edge_type=<class 'manim.mobject.geometry.line.Line'>, edge_config=None)[source]
Add a new edge to the graph.

Parameters:
edge (tuple[Hashable, Hashable]) – The edge (as a tuple of vertex identifiers) to be added. If a non-existing vertex is passed, a new vertex with default settings will be created. Create new vertices yourself beforehand to customize them.

edge_type (type[Mobject]) – The mobject class used for displaying edges in the scene.

edge_config (dict | None) – A dictionary containing keyword arguments to be passed to the class specified via edge_type.

Returns:
A group containing all newly added vertices and edges.

Return type:
Group

_add_vertex(vertex, position=None, label=False, label_fill_color=ManimColor('#000000'), vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobject=None)[source]
Add a vertex to the graph.

Parameters:
vertex (Hashable) – A hashable vertex identifier.

position (Point3D | None) – The coordinates where the new vertex should be added. If None, the center of the graph is used.

label (bool) – Controls whether or not the vertex is labeled. If False (the default), the vertex is not labeled; if True it is labeled using its names (as specified in vertex) via MathTex. Alternatively, any Mobject can be passed to be used as the label.

label_fill_color (str) – Sets the fill color of the default labels generated when labels is set to True. Has no effect for other values of label.

vertex_type (type[Mobject]) – The mobject class used for displaying vertices in the scene.

vertex_config (dict | None) – A dictionary containing keyword arguments to be passed to the class specified via vertex_type.

vertex_mobject (dict | None) – The mobject to be used as the vertex. Overrides all other vertex customization options.

Return type:
Mobject

static _empty_networkx_graph()[source]
Return an empty networkx graph for the given graph type.

Return type:
Graph

_original__init__(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertices (list[Hashable])

edges (list[tuple[Hashable, Hashable]])

labels (bool | dict)

label_fill_color (str)

layout (Literal['circular', 'kamada_kawai', 'partite', 'planar', 'random', 'shell', 'spectral', 'spiral', 'spring', 'tree'] | dict[~typing.Hashable, ~manim.typing.Point3D] | ~manim.mobject.graph.LayoutFunction)

layout_scale (float | tuple[float, float, float])

layout_config (dict | None)

vertex_type (type[Mobject])

vertex_config (dict | None)

vertex_mobjects (dict | None)

edge_type (type[Mobject])

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

edge_config (dict | None)

Return type:
None

_populate_edge_dict(edges, edge_type)[source]
Helper method for populating the edges of the graph.

Parameters:
edges (list[tuple[Hashable, Hashable]])

edge_type (type[Mobject])

_remove_edge(edge)[source]
Remove an edge from the graph.

Parameters:
edge (tuple[Hashable]) – The edge (i.e., a tuple of vertex identifiers) to be removed from the graph.

Returns:
The removed edge.

Return type:
Mobject

_remove_vertex(vertex)[source]
Remove a vertex (as well as all incident edges) from the graph.

Parameters:
vertex – The identifier of a vertex to be removed.

Returns:
A mobject containing all removed objects.

Return type:
Group

add_edges(*edges, edge_type=<class 'manim.mobject.geometry.line.Line'>, edge_config=None, **kwargs)[source]
Add new edges to the graph.

Parameters:
edges (tuple[Hashable, Hashable]) – Edges (as tuples of vertex identifiers) to be added. If a non-existing vertex is passed, a new vertex with default settings will be created. Create new vertices yourself beforehand to customize them.

edge_type (type[Mobject]) – The mobject class used for displaying edges in the scene.

edge_config (dict | None) – A dictionary either containing keyword arguments to be passed to the class specified via edge_type, or a dictionary whose keys are the edge tuples, and whose values are dictionaries containing keyword arguments to be passed for the construction of the corresponding edge.

kwargs – Any further keyword arguments are passed to add_vertices() which is used to create new vertices in the passed edges.

Returns:
A group containing all newly added vertices and edges.

Return type:
Group

add_vertices(*vertices, positions=None, labels=False, label_fill_color=ManimColor('#000000'), vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None)[source]
Add a list of vertices to the graph.

Parameters:
vertices (Hashable) – Hashable vertex identifiers.

positions (dict | None) – A dictionary specifying the coordinates where the new vertices should be added. If None, all vertices are created at the center of the graph.

labels (bool) – Controls whether or not the vertex is labeled. If False (the default), the vertex is not labeled; if True it is labeled using its names (as specified in vertex) via MathTex. Alternatively, any Mobject can be passed to be used as the label.

label_fill_color (str) – Sets the fill color of the default labels generated when labels is set to True. Has no effect for other values of labels.

vertex_type (type[Mobject]) – The mobject class used for displaying vertices in the scene.

vertex_config (dict | None) – A dictionary containing keyword arguments to be passed to the class specified via vertex_type.

vertex_mobjects (dict | None) – A dictionary whose keys are the vertex identifiers, and whose values are mobjects that should be used as vertices. Overrides all other vertex customization options.

self (Graph)

change_layout(layout='spring', layout_scale=2, layout_config=None, partitions=None, root_vertex=None)[source]
Change the layout of this graph.

See the documentation of Graph for details about the keyword arguments.

Examples

Example: ChangeGraphLayout 

from manim import *

class ChangeGraphLayout(Scene):
    def construct(self):
        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],
                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],
                          4: [1, 0, 0], 5: [2, 0, 0]}
                  )
        self.play(Create(G))
        self.play(G.animate.change_layout("circular"))
        self.wait()
Make interactive
Parameters:
layout (Literal['circular', 'kamada_kawai', 'partite', 'planar', 'random', 'shell', 'spectral', 'spiral', 'spring', 'tree'] | dict[~typing.Hashable, ~manim.typing.Point3D] | ~manim.mobject.graph.LayoutFunction)

layout_scale (float | tuple[float, float, float])

layout_config (dict[str, Any] | None)

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

Return type:
Graph

classmethod from_networkx(nxgraph, **kwargs)[source]
Build a Graph or DiGraph from a given networkx graph.

Parameters:
nxgraph (Graph | DiGraph) – A networkx graph or digraph.

**kwargs – Keywords to be passed to the constructor of Graph.

Examples

Example: ImportNetworkxGraph 

from manim import *

import networkx as nx

nxgraph = nx.erdos_renyi_graph(14, 0.5)

class ImportNetworkxGraph(Scene):
    def construct(self):
        G = Graph.from_networkx(nxgraph, layout="spring", layout_scale=3.5)
        self.play(Create(G))
        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +
                                         3*UP*np.sin(ind/7 * PI))
                    for ind, v in enumerate(G.vertices)])
        self.play(Uncreate(G))
Make interactive
remove_edges(*edges)[source]
Remove several edges from the graph.

Parameters:
edges (tuple[Hashable]) – Edges to be removed from the graph.

Returns:
A group containing all removed edges.

Return type:
Group

remove_vertices(*vertices)[source]
Remove several vertices from the graph.

Parameters:
vertices – Vertices to be removed from the graph.

Examples

G = Graph([1, 2, 3], [(1, 2), (2, 3)])
removed = G.remove_vertices(2, 3); removed
VGroup(Line, Line, Dot, Dot)
G
Undirected graph on 1 vertices and 0 edges

Graph
Qualified name: manim.mobject.graph.Graph

class Graph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)[source]
Bases: GenericGraph

An undirected graph (vertices connected with edges).

The graph comes with an updater which makes the edges stick to the vertices when moved around. See DiGraph for a version with directed edges.

See also

GenericGraph

Parameters:
vertices (list[Hashable]) – A list of vertices. Must be hashable elements.

edges (list[tuple[Hashable, Hashable]]) – A list of edges, specified as tuples (u, v) where both u and v are vertices. The vertex order is irrelevant.

labels (bool | dict) – Controls whether or not vertices are labeled. If False (the default), the vertices are not labeled; if True they are labeled using their names (as specified in vertices) via MathTex. Alternatively, custom labels can be specified by passing a dictionary whose keys are the vertices, and whose values are the corresponding vertex labels (rendered via, e.g., Text or Tex).

label_fill_color (str) – Sets the fill color of the default labels generated when labels is set to True. Has no effect for other values of labels.

layout (LayoutName | dict[Hashable, Point3D] | LayoutFunction) – Either one of "spring" (the default), "circular", "kamada_kawai", "planar", "random", "shell", "spectral", "spiral", "tree", and "partite" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value) for each vertex (key) for manual positioning.

layout_config (dict | None) – Only for automatically generated layouts. A dictionary whose entries are passed as keyword arguments to the automatic layout algorithm specified via layout of networkx. The tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary. Passing a tuple (space_x, space_y) as this argument overrides the value of layout_scale and ensures that vertices are arranged in a way such that the centers of siblings in the same layer are at least space_x units apart horizontally, and neighboring layers are spaced space_y units vertically.

layout_scale (float | tuple[float, float, float]) – The scale of automatically generated layouts: the vertices will be arranged such that the coordinates are located within the interval [-scale, scale]. Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x], and the second in [-scale_y, scale_y]. Default: 2.

vertex_type (type[Mobject]) – The mobject class used for displaying vertices in the scene.

vertex_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via vertex_type, or a dictionary whose keys are the vertices, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding vertex.

vertex_mobjects (dict | None) – A dictionary whose keys are the vertices, and whose values are mobjects to be used as vertices. Passing vertices here overrides all other configuration options for a vertex.

edge_type (type[Mobject]) – The mobject class used for displaying edges in the scene.

edge_config (dict | None) – Either a dictionary containing keyword arguments to be passed to the class specified via edge_type, or a dictionary whose keys are the edges, and whose values are dictionaries containing keyword arguments for the mobject related to the corresponding edge.

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

Examples

First, we create a small graph and demonstrate that the edges move together with the vertices.

Example: MovingVertices 

from manim import *

class MovingVertices(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
        g = Graph(vertices, edges)
        self.play(Create(g))
        self.wait()
        self.play(g[1].animate.move_to([1, 1, 0]),
                  g[2].animate.move_to([-1, 1, 0]),
                  g[3].animate.move_to([1, -1, 0]),
                  g[4].animate.move_to([-1, -1, 0]))
        self.wait()
Make interactive
There are several automatic positioning algorithms to choose from:

Example: GraphAutoPosition 

../_images/GraphAutoPosition-1.png
from manim import *

class GraphAutoPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        autolayouts = ["spring", "circular", "kamada_kawai",
                       "planar", "random", "shell",
                       "spectral", "spiral"]
        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)
                  for lt in autolayouts]
        r1 = VGroup(*graphs[:3]).arrange()
        r2 = VGroup(*graphs[3:6]).arrange()
        r3 = VGroup(*graphs[6:]).arrange()
        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))
Make interactive
Vertices can also be positioned manually:

Example: GraphManualPosition 

../_images/GraphManualPosition-1.png
from manim import *

class GraphManualPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]
        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}
        G = Graph(vertices, edges, layout=lt)
        self.add(G)
Make interactive
The vertices in graphs can be labeled, and configurations for vertices and edges can be modified both by default and for specific vertices and edges.

Note

In edge_config, edges can be passed in both directions: if (u, v) is an edge in the graph, both (u, v) as well as (v, u) can be used as keys in the dictionary.

Example: LabeledModifiedGraph 

../_images/LabeledModifiedGraph-1.png
from manim import *

class LabeledModifiedGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        g = Graph(vertices, edges, layout="circular", layout_scale=3,
                  labels=True, vertex_config={7: {"fill_color": RED}},
                  edge_config={(1, 7): {"stroke_color": RED},
                               (2, 7): {"stroke_color": RED},
                               (4, 7): {"stroke_color": RED}})
        self.add(g)
Make interactive
You can also lay out a partite graph on columns by specifying a list of the vertices on each side and choosing the partite layout.

Note

All vertices in your graph which are not listed in any of the partitions are collected in their own partition and rendered in the rightmost column.

Example: PartiteGraph 

../_images/PartiteGraph-1.png
from manim import *

import networkx as nx

class PartiteGraph(Scene):
    def construct(self):
        G = nx.Graph()
        G.add_nodes_from([0, 1, 2, 3])
        G.add_edges_from([(0, 2), (0,3), (1, 2)])
        graph = Graph(list(G.nodes), list(G.edges), layout="partite", partitions=[[0, 1]])
        self.play(Create(graph))
Make interactive
The representation of a linear artificial neural network is facilitated by the use of the partite layout and defining partitions for each layer.

Example: LinearNN 

../_images/LinearNN-1.png
from manim import *

class LinearNN(Scene):
    def construct(self):
        edges = []
        partitions = []
        c = 0
        layers = [2, 3, 3, 2]  # the number of neurons in each layer

        for i in layers:
            partitions.append(list(range(c + 1, c + i + 1)))
            c += i
        for i, v in enumerate(layers[1:]):
                last = sum(layers[:i+1])
                for j in range(v):
                    for k in range(last - layers[i], last):
                        edges.append((k + 1, j + last + 1))

        vertices = np.arange(1, sum(layers) + 1)

        graph = Graph(
            vertices,
            edges,
            layout='partite',
            partitions=partitions,
            layout_scale=3,
            vertex_config={'radius': 0.20},
        )
        self.add(graph)
Make interactive
The custom tree layout can be used to show the graph by distance from the root vertex. You must pass the root vertex of the tree.

Example: Tree 

from manim import *

import networkx as nx

class Tree(Scene):
    def construct(self):
        G = nx.Graph()

        G.add_node("ROOT")

        for i in range(5):
            G.add_node("Child_%i" % i)
            G.add_node("Grandchild_%i" % i)
            G.add_node("Greatgrandchild_%i" % i)

            G.add_edge("ROOT", "Child_%i" % i)
            G.add_edge("Child_%i" % i, "Grandchild_%i" % i)
            G.add_edge("Grandchild_%i" % i, "Greatgrandchild_%i" % i)

        self.play(Create(
            Graph(list(G.nodes), list(G.edges), layout="tree", root_vertex="ROOT")))
Make interactive
The following code sample illustrates the use of the vertex_spacing layout parameter specific to the "tree" layout. As mentioned above, setting vertex_spacing overrides the specified value for layout_scale, and as such it is harder to control the size of the mobject. However, we can adjust the captured frame and zoom out by using a MovingCameraScene:

class LargeTreeGeneration(MovingCameraScene):
    DEPTH = 4
    CHILDREN_PER_VERTEX = 3
    LAYOUT_CONFIG = {"vertex_spacing": (0.5, 1)}
    VERTEX_CONF = {"radius": 0.25, "color": BLUE_B, "fill_opacity": 1}

    def expand_vertex(self, g, vertex_id: str, depth: int):
        new_vertices = [f"{vertex_id}/{i}" for i in range(self.CHILDREN_PER_VERTEX)]
        new_edges = [(vertex_id, child_id) for child_id in new_vertices]
        g.add_edges(
            *new_edges,
            vertex_config=self.VERTEX_CONF,
            positions={
                k: g.vertices[vertex_id].get_center() + 0.1 * DOWN for k in new_vertices
            },
        )
        if depth < self.DEPTH:
            for child_id in new_vertices:
                self.expand_vertex(g, child_id, depth + 1)

        return g

    def construct(self):
        g = Graph(["ROOT"], [], vertex_config=self.VERTEX_CONF)
        g = self.expand_vertex(g, "ROOT", 1)
        self.add(g)

        self.play(
            g.animate.change_layout(
                "tree",
                root_vertex="ROOT",
                layout_config=self.LAYOUT_CONFIG,
            )
        )
        self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)
Methods

update_edges

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

static _empty_networkx_graph()[source]
Return an empty networkx graph for the given graph type.

Return type:
Graph

_original__init__(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vertices (list[Hashable])

edges (list[tuple[Hashable, Hashable]])

labels (bool | dict)

label_fill_color (str)

layout (Literal['circular', 'kamada_kawai', 'partite', 'planar', 'random', 'shell', 'spectral', 'spiral', 'spring', 'tree'] | dict[~typing.Hashable, ~manim.typing.Point3D] | ~manim.mobject.graph.LayoutFunction)

layout_scale (float | tuple[float, float, float])

layout_config (dict | None)

vertex_type (type[Mobject])

vertex_config (dict | None)

vertex_mobjects (dict | None)

edge_type (type[Mobject])

partitions (list[list[Hashable]] | None)

root_vertex (Hashable | None)

edge_config (dict | None)

Return type:
None

_populate_edge_dict(edges, edge_type)[source]
Helper method for populating the edges of the graph.

Parameters:
edges (list[tuple[Hashable, Hashable]])

edge_type (type[Mobject])

LayoutFunction
Qualified name: manim.mobject.graph.LayoutFunction

class LayoutFunction(*args, **kwargs)[source]
Bases: Protocol

A protocol for automatic layout functions that compute a layout for a graph to be used in change_layout().

Note

The layout function must be a pure function, i.e., it must not modify the graph passed to it.

Examples

Here is an example that arranges nodes in an n x m grid in sorted order.

Example: CustomLayoutExample 

../_images/CustomLayoutExample-1.png
from manim import *

class CustomLayoutExample(Scene):
    def construct(self):
        import numpy as np
        import networkx as nx

        # create custom layout
        def custom_layout(
            graph: nx.Graph,
            scale: float | tuple[float, float, float] = 2,
            n: int | None = None,
            *args: Any,
            **kwargs: Any,
        ):
            nodes = sorted(list(graph))
            height = len(nodes) // n
            return {
                node: (scale * np.array([
                    (i % n) - (n-1)/2,
                    -(i // n) + height/2,
                    0
                ])) for i, node in enumerate(graph)
            }

        # draw graph
        n = 4
        graph = Graph(
            [i for i in range(4 * 2 - 1)],
            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],
            labels=True,
            layout=custom_layout,
            layout_config={'n': n}
        )
        self.add(graph)
Make interactive
Several automatic layouts are provided by manim, and can be used by passing their name as the layout parameter to change_layout(). Alternatively, a custom layout function can be passed to change_layout() as the layout parameter. Such a function must adhere to the LayoutFunction protocol.

The LayoutFunction s provided by manim are illustrated below:

Circular Layout: places the vertices on a circle

Example: CircularLayout 

../_images/CircularLayout-1.png
from manim import *

class CircularLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="circular",
            labels=True
        )
        self.add(graph)
Make interactive
Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected

Example: KamadaKawaiLayout 

../_images/KamadaKawaiLayout-1.png
from manim import *

class KamadaKawaiLayout(Scene):
    def construct(self):
        from collections import defaultdict
        distances: dict[int, dict[int, float]] = defaultdict(dict)

        # set desired distances
        distances[1][2] = 1  # distance between vertices 1 and 2 is 1
        distances[2][3] = 1  # distance between vertices 2 and 3 is 1
        distances[3][4] = 2  # etc
        distances[4][5] = 3
        distances[5][6] = 5
        distances[6][1] = 8

        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],
            layout="kamada_kawai",
            layout_config={"dist": distances},
            layout_scale=4,
            labels=True
        )
        self.add(graph)
Make interactive
Partite Layout: places vertices into distinct partitions

Example: PartiteLayout 

../_images/PartiteLayout-1.png
from manim import *

class PartiteLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="partite",
            layout_config={"partitions": [[1,2],[3,4],[5,6]]},
            labels=True
        )
        self.add(graph)
Make interactive
Planar Layout: places vertices such that edges do not cross

Example: PlanarLayout 

../_images/PlanarLayout-1.png
from manim import *

class PlanarLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="planar",
            layout_scale=4,
            labels=True
        )
        self.add(graph)
Make interactive
Random Layout: randomly places vertices

Example: RandomLayout 

../_images/RandomLayout-1.png
from manim import *

class RandomLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="random",
            labels=True
        )
        self.add(graph)
Make interactive
Shell Layout: places vertices in concentric circles

Example: ShellLayout 

../_images/ShellLayout-1.png
from manim import *

class ShellLayout(Scene):
    def construct(self):
        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7, 8, 9],
            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],
            layout="shell",
            layout_config={"nlist": nlist},
            labels=True
        )
        self.add(graph)
Make interactive
Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)

Example: SpectralLayout 

../_images/SpectralLayout-1.png
from manim import *

class SpectralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="spectral",
            labels=True
        )
        self.add(graph)
Make interactive
Sprial Layout: places vertices in a spiraling pattern

Example: SpiralLayout 

../_images/SpiralLayout-1.png
from manim import *

class SpiralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="spiral",
            labels=True
        )
        self.add(graph)
Make interactive
Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation)

Example: SpringLayout 

../_images/SpringLayout-1.png
from manim import *

class SpringLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout="spring",
            labels=True
        )
        self.add(graph)
Make interactive
Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)

Example: TreeLayout 

../_images/TreeLayout-1.png
from manim import *

class TreeLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7],
            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],
            layout="tree",
            layout_config={"root_vertex": 1},
            labels=True
        )
        self.add(graph)
Make interactive
Methods

graphing
Coordinate systems and function graphing related mobjects.

Modules
coordinate_systems

Mobjects that represent coordinate systems.

functions

Mobjects representing function graphs.

number_line

Mobject representing a number line.

probability

Mobjects representing objects from probability theory and statistics.

scale

coordinate_systems
Mobjects that represent coordinate systems.

Classes

Axes

Creates a set of axes.

ComplexPlane

A NumberPlane specialized for use with complex numbers.

CoordinateSystem

Abstract base class for Axes and NumberPlane.

NumberPlane

Creates a cartesian plane with background lines.

PolarPlane

Creates a polar plane with background lines.

ThreeDAxes

A 3-dimensional set of axes.

Axes
Qualified name: manim.mobject.graphing.coordinate\_systems.Axes

class Axes(x_range=None, y_range=None, x_length=12, y_length=6, axis_config=None, x_axis_config=None, y_axis_config=None, tips=True, **kwargs)[source]
Bases: VGroup, CoordinateSystem

Creates a set of axes.

Parameters:
x_range (Sequence[float] | None) – The (x_min, x_max, x_step) values of the x-axis.

y_range (Sequence[float] | None) – The (y_min, y_max, y_step) values of the y-axis.

x_length (float | None) – The length of the x-axis.

y_length (float | None) – The length of the y-axis.

axis_config (dict | None) – Arguments to be passed to NumberLine that influences both axes.

x_axis_config (dict | None) – Arguments to be passed to NumberLine that influence the x-axis.

y_axis_config (dict | None) – Arguments to be passed to NumberLine that influence the y-axis.

tips (bool) – Whether or not to include the tips on both axes.

kwargs (Any) – Additional arguments to be passed to CoordinateSystem and VGroup.

Examples

Example: LogScalingExample 

../_images/LogScalingExample-1.png
from manim import *

class LogScalingExample(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 10, 1],
            y_range=[-2, 6, 1],
            tips=False,
            axis_config={"include_numbers": True},
            y_axis_config={"scaling": LogBase(custom_labels=True)},
        )

        # x_min must be > 0 because log is undefined at 0.
        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)
        self.add(ax, graph)
Make interactive
Styling arguments can be passed to the underlying NumberLine mobjects that represent the axes:

Example: AxesWithDifferentTips 

../_images/AxesWithDifferentTips-1.png
from manim import *

class AxesWithDifferentTips(Scene):
    def construct(self):
        ax = Axes(axis_config={'tip_shape': StealthTip})
        self.add(ax)
Make interactive
Methods

coords_to_point

Accepts coordinates from the axes and returns a point with respect to the scene.

get_axes

Gets the axes.

get_axis_labels

Defines labels for the x-axis and y-axis of the graph.

plot_line_graph

Draws a line graph.

point_to_coords

Accepts a point from the scene and returns its coordinates with respect to the axes.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_create_axis(range_terms, axis_config, length)[source]
Creates an axis and dynamically adjusts its position depending on where 0 is located on the line.

Parameters:
range_terms (Sequence[float]) – The range of the the axis : (x_min, x_max, x_step).

axis_config (dict[str, Any]) – Additional parameters that are passed to NumberLine.

length (float) – The length of the axis.

Returns:
Returns a number line based on range_terms.

Return type:
NumberLine

static _origin_shift(axis_range)[source]
Determines how to shift graph mobjects to compensate when 0 is not on the axis.

Parameters:
axis_range (Sequence[float]) – The range of the axis : (x_min, x_max, x_step).

Return type:
float

_original__init__(x_range=None, y_range=None, x_length=12, y_length=6, axis_config=None, x_axis_config=None, y_axis_config=None, tips=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
x_range (Sequence[float] | None)

y_range (Sequence[float] | None)

x_length (float | None)

y_length (float | None)

axis_config (dict | None)

x_axis_config (dict | None)

y_axis_config (dict | None)

tips (bool)

kwargs (Any)

Return type:
None

static _update_default_configs(default_configs, passed_configs)[source]
Takes in two tuples of dicts and return modifies the first such that values from passed_configs overwrite values in default_configs. If a key does not exist in default_configs, it is added to the dict.

This method is useful for having defaults in a class and being able to overwrite them with user-defined input.

Parameters:
default_configs (tuple[dict[Any, Any]]) – The dict that will be updated.

passed_configs (tuple[dict[Any, Any]]) – The dict that will be used to update.

Return type:
None

Examples

To create a tuple with one dictionary, add a comma after the element:

self._update_default_configs(
    (dict_1,)(
        dict_2,
    )
)
coords_to_point(*coords)[source]
Accepts coordinates from the axes and returns a point with respect to the scene.

Parameters:
coords (float | Sequence[float] | Sequence[Sequence[float]] | ndarray) –

The coordinates. Each coord is passed as a separate argument: ax.coords_to_point(1, 2, 3).

Also accepts a list of coordinates

ax.coords_to_point( [x_0, x_1, ...], [y_0, y_1, ...], ... )

ax.coords_to_point( [[x_0, y_0, z_0], [x_1, y_1, z_1]] )

Returns:
A point with respect to the scene’s coordinate system. The shape of the array will be similar to the shape of the input.

Return type:
np.ndarray

Examples

from manim import Axes
import numpy as np
ax = Axes()
np.around(ax.coords_to_point(1, 0, 0), 2)
array([0.86, 0.  , 0.  ])
np.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)
array([[0.  , 0.75, 0.  ],
       [0.86, 0.75, 0.  ],
       [0.86, 0.  , 0.  ]])
np.around(
    ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2
)  # Transposed version of the above
array([[0.  , 0.86, 0.86],
       [0.75, 0.75, 0.  ],
       [0.  , 0.  , 0.  ]])
Example: CoordsToPointExample 

../_images/CoordsToPointExample-1.png
from manim import *

class CoordsToPointExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()

        # a dot with respect to the axes
        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)
        lines = ax.get_lines_to_point(ax.c2p(2,2))

        # a dot with respect to the scene
        # the default plane corresponds to the coordinates of the scene.
        plane = NumberPlane()
        dot_scene = Dot((2,2,0), color=RED)

        self.add(plane, dot_scene, ax, dot_axes, lines)
Make interactive
get_axes()[source]
Gets the axes.

Returns:
A pair of axes.

Return type:
VGroup

get_axis_labels(x_label='x', y_label='y')[source]
Defines labels for the x-axis and y-axis of the graph.

For increased control over the position of the labels, use get_x_axis_label() and get_y_axis_label().

Parameters:
x_label (float | str | Mobject) – The label for the x_axis. Defaults to MathTex for str and float inputs.

y_label (float | str | Mobject) – The label for the y_axis. Defaults to MathTex for str and float inputs.

Returns:
A VGroup of the labels for the x_axis and y_axis.

Return type:
VGroup

See also

get_x_axis_label() get_y_axis_label()

Examples

Example: GetAxisLabelsExample 

../_images/GetAxisLabelsExample-1.png
from manim import *

class GetAxisLabelsExample(Scene):
    def construct(self):
        ax = Axes()
        labels = ax.get_axis_labels(
            Tex("x-axis").scale(0.7), Text("y-axis").scale(0.45)
        )
        self.add(ax, labels)
Make interactive
plot_line_graph(x_values, y_values, z_values=None, line_color=ManimColor('#FFFF00'), add_vertex_dots=True, vertex_dot_radius=0.08, vertex_dot_style=None, **kwargs)[source]
Draws a line graph.

The graph connects the vertices formed from zipping x_values, y_values and z_values. Also adds Dots at the vertices if add_vertex_dots is set to True.

Parameters:
x_values (Iterable[float]) – Iterable of values along the x-axis.

y_values (Iterable[float]) – Iterable of values along the y-axis.

z_values (Iterable[float] | None) – Iterable of values (zeros if z_values is None) along the z-axis.

line_color (ParsableManimColor) – Color for the line graph.

add_vertex_dots (bool) – Whether or not to add Dot at each vertex.

vertex_dot_radius (float) – Radius for the Dot at each vertex.

vertex_dot_style (dict[str, Any] | None) – Style arguments to be passed into Dot at each vertex.

kwargs (Any) – Additional arguments to be passed into VMobject.

Returns:
A VDict containing both the line and dots (if specified). The line can be accessed with: line_graph["line_graph"]. The dots can be accessed with: line_graph["vertex_dots"].

Return type:
VDict

Examples

Example: LineGraphExample 

../_images/LineGraphExample-1.png
from manim import *

class LineGraphExample(Scene):
    def construct(self):
        plane = NumberPlane(
            x_range = (0, 7),
            y_range = (0, 5),
            x_length = 7,
            axis_config={"include_numbers": True},
        )
        plane.center()
        line_graph = plane.plot_line_graph(
            x_values = [0, 1.5, 2, 2.8, 4, 6.25],
            y_values = [1, 3, 2.25, 4, 2.5, 1.75],
            line_color=GOLD_E,
            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),
            stroke_width = 4,
        )
        self.add(plane, line_graph)
Make interactive
point_to_coords(point)[source]
Accepts a point from the scene and returns its coordinates with respect to the axes.

Parameters:
point (Sequence[float]) – The point, i.e. RIGHT or [0, 1, 0]. Also accepts a list of points as [RIGHT, [0, 1, 0]].

Returns:
The coordinates on the axes, i.e. [4.0, 7.0]. Or a list of coordinates if point is a list of points.

Return type:
np.ndarray[float]

Examples

from manim import Axes, RIGHT
import numpy as np
ax = Axes(x_range=[0, 10, 2])
np.around(ax.point_to_coords(RIGHT), 2)
array([5.83, 0.  ])
np.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)
array([[5.  , 0.  ],
       [5.83, 0.  ]])
Example: PointToCoordsExample 

../_images/PointToCoordsExample-1.png
from manim import *

class PointToCoordsExample(Scene):
    def construct(self):
        ax = Axes(x_range=[0, 10, 2]).add_coordinates()
        circ = Circle(radius=0.5).shift(UR * 2)

        # get the coordinates of the circle with respect to the axes
        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)

        label = (
            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)
        )

        self.add(ax, circ, label, Dot(circ.get_right()))
Make interactive

ComplexPlane
Qualified name: manim.mobject.graphing.coordinate\_systems.ComplexPlane

class ComplexPlane(**kwargs)[source]
Bases: NumberPlane

A NumberPlane specialized for use with complex numbers.

Examples

Example: ComplexPlaneExample 

../_images/ComplexPlaneExample-1.png
from manim import *

class ComplexPlaneExample(Scene):
    def construct(self):
        plane = ComplexPlane().add_coordinates()
        self.add(plane)
        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)
        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)
        label1 = MathTex("2+i").next_to(d1, UR, 0.1)
        label2 = MathTex("-3-2i").next_to(d2, UR, 0.1)
        self.add(
            d1,
            label1,
            d2,
            label2,
        )
Make interactive
References: Dot MathTex

Methods

add_coordinates

Adds the labels produced from get_coordinate_labels() to the plane.

get_coordinate_labels

Generates the DecimalNumber mobjects for the coordinates of the plane.

n2p

Abbreviation for number_to_point().

number_to_point

Accepts a float/complex number and returns the equivalent point on the plane.

p2n

Abbreviation for point_to_number().

point_to_number

Accepts a point and returns a complex number equivalent to that point on the plane.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
kwargs (Any)

_get_default_coordinate_values()[source]
Generate a list containing the numerical values of the plane’s labels.

Returns:
A list of floats representing the x-axis and complex numbers representing the y-axis.

Return type:
List[float | complex]

_original__init__(**kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
kwargs (Any)

Return type:
None

add_coordinates(*numbers, **kwargs)[source]
Adds the labels produced from get_coordinate_labels() to the plane.

Parameters:
numbers (Iterable[float | complex]) – An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.

kwargs (Any) – Additional arguments to be passed to get_number_mobject(), i.e. DecimalNumber.

Return type:
Self

get_coordinate_labels(*numbers, **kwargs)[source]
Generates the DecimalNumber mobjects for the coordinates of the plane.

Parameters:
numbers (Iterable[float | complex]) – An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.

kwargs (Any) – Additional arguments to be passed to get_number_mobject(), i.e. DecimalNumber.

Returns:
A VGroup containing the positioned label mobjects.

Return type:
VGroup

n2p(number)[source]
Abbreviation for number_to_point().

Parameters:
number (float | complex)

Return type:
ndarray

number_to_point(number)[source]
Accepts a float/complex number and returns the equivalent point on the plane.

Parameters:
number (float | complex) – The number. Can be a float or a complex number.

Returns:
The point on the plane.

Return type:
np.ndarray

p2n(point)[source]
Abbreviation for point_to_number().

Parameters:
point (Point3D)

Return type:
complex

point_to_number(point)[source]
Accepts a point and returns a complex number equivalent to that point on the plane.

Parameters:
point (Point3D) – The point in manim’s coordinate-system

Returns:
A complex number consisting of real and imaginary components.

Return type:
complex

CoordinateSystem
Qualified name: manim.mobject.graphing.coordinate\_systems.CoordinateSystem

class CoordinateSystem(x_range=None, y_range=None, x_length=None, y_length=None, dimension=2)[source]
Bases: object

Abstract base class for Axes and NumberPlane.

Examples

Example: CoordSysExample 

../_images/CoordSysExample-1.png
from manim import *

class CoordSysExample(Scene):
    def construct(self):
        # the location of the ticks depends on the x_range and y_range.
        grid = Axes(
            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.
            y_range=[0, 1, 0.05],
            x_length=9,
            y_length=5.5,
            axis_config={
                "numbers_to_include": np.arange(0, 1 + 0.1, 0.1),
                "font_size": 24,
            },
            tips=False,
        )

        # Labels for the x-axis and y-axis.
        y_label = grid.get_y_axis_label("y", edge=LEFT, direction=LEFT, buff=0.4)
        x_label = grid.get_x_axis_label("x")
        grid_labels = VGroup(x_label, y_label)

        graphs = VGroup()
        for n in np.arange(1, 20 + 0.5, 0.5):
            graphs += grid.plot(lambda x: x ** n, color=WHITE)
            graphs += grid.plot(
                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False
            )

        # Extra lines and labels for point (1,1)
        graphs += grid.get_horizontal_line(grid.c2p(1, 1, 0), color=BLUE)
        graphs += grid.get_vertical_line(grid.c2p(1, 1, 0), color=BLUE)
        graphs += Dot(point=grid.c2p(1, 1, 0), color=YELLOW)
        graphs += Tex("(1,1)").scale(0.75).next_to(grid.c2p(1, 1, 0))
        title = Title(
            # spaces between braces to prevent SyntaxError
            r"Graphs of $y=x^{ {1}\over{n} }$ and $y=x^n (n=1,2,3,...,20)$",
            include_underline=False,
            font_size=40,
        )

        self.add(title, graphs, grid, grid_labels)
Make interactive
Methods

add_coordinates

Adds labels to the axes.

angle_of_tangent

Returns the angle to the x-axis of the tangent to the plotted curve at a particular x-value.

c2p

Abbreviation for coords_to_point()

coords_to_point

get_T_label

Creates a labelled triangle marker with a vertical line from the x-axis to a curve at a given x-value.

get_area

Returns a Polygon representing the area under the graph passed.

get_axes

get_axis

get_axis_labels

get_graph_label

Creates a properly positioned label for the passed graph, with an optional dot.

get_horizontal_line

A horizontal line from the y-axis to a given point in the scene.

get_line_from_axis_to_point

Returns a straight line from a given axis to a point in the scene.

get_lines_to_point

Generate both horizontal and vertical lines from the axis to a point.

get_origin

Gets the origin of Axes.

get_riemann_rectangles

Generates a VGroup of the Riemann Rectangles for a given curve.

get_secant_slope_group

Creates two lines representing dx and df, the labels for dx and df, and

get_vertical_line

A vertical line from the x-axis to a given point in the scene.

get_vertical_lines_to_graph

Obtains multiple lines from the x-axis to the curve.

get_x_axis

get_x_axis_label

Generate an x-axis label.

get_x_unit_size

get_y_axis

get_y_axis_label

Generate a y-axis label.

get_y_unit_size

get_z_axis

i2gc

Alias for input_to_graph_coords().

i2gp

Alias for input_to_graph_point().

input_to_graph_coords

Returns a tuple of the axis relative coordinates of the point on the graph based on the x-value given.

input_to_graph_point

Returns the coordinates of the point on a graph corresponding to an x value.

p2c

Abbreviation for point_to_coords()

plot

Generates a curve based on a function.

plot_antiderivative_graph

Plots an antiderivative graph.

plot_derivative_graph

Returns the curve of the derivative of the passed graph.

plot_implicit_curve

Creates the curves of an implicit function.

plot_parametric_curve

A parametric curve.

plot_polar_graph

A polar graph.

plot_surface

Generates a surface based on a function.

point_to_coords

point_to_polar

Gets polar coordinates from a point.

polar_to_point

Gets a point from polar coordinates.

pr2pt

Abbreviation for polar_to_point()

pt2pr

Abbreviation for point_to_polar()

slope_of_tangent

Returns the slope of the tangent to the plotted curve at a particular x-value.

Parameters:
x_range (Sequence[float] | None)

y_range (Sequence[float] | None)

x_length (float | None)

y_length (float | None)

dimension (int)

_get_axis_label(label, axis, edge, direction, buff=0.1)[source]
Gets the label for an axis.

Parameters:
label (float | str | Mobject) – The label. Defaults to MathTex for str and float inputs.

axis (Mobject) – The axis to which the label will be added.

edge (Sequence[float]) – The edge of the axes to which the label will be added. RIGHT adds to the right side of the axis

direction (Sequence[float]) – Allows for further positioning of the label.

buff (float) – The distance of the label from the line.

Returns:
The positioned label along the given axis.

Return type:
Mobject

add_coordinates(*axes_numbers, **kwargs)[source]
Adds labels to the axes. Use Axes.coordinate_labels to access the coordinates after creation.

Parameters:
axes_numbers (Iterable[float] | None | dict[float, str | float | Mobject]) – The numbers to be added to the axes. Use None to represent an axis with default labels.

kwargs (Any)

Return type:
Self

Examples

ax = ThreeDAxes()
x_labels = range(-4, 5)
z_labels = range(-4, 4, 2)
ax.add_coordinates(x_labels, None, z_labels)  # default y labels, custom x & z labels
ax.add_coordinates(x_labels)  # only x labels
You can also specifically control the position and value of the labels using a dict.

ax = Axes(x_range=[0, 7])
x_pos = [x for x in range(1, 8)]

# strings are automatically converted into a Tex mobject.
x_vals = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
x_dict = dict(zip(x_pos, x_vals))
ax.add_coordinates(x_dict)
angle_of_tangent(x, graph, dx=1e-08)[source]
Returns the angle to the x-axis of the tangent to the plotted curve at a particular x-value.

Parameters:
x (float) – The x-value at which the tangent must touch the curve.

graph (ParametricFunction) – The ParametricFunction for which to calculate the tangent.

dx (float) – The change in x used to determine the angle of the tangent to the curve.

Returns:
The angle of the tangent to the curve.

Return type:
float

Examples

ax = Axes()
curve = ax.plot(lambda x: x**2)
ax.angle_of_tangent(x=3, graph=curve)
# 1.4056476493802699
c2p(*coords)[source]
Abbreviation for coords_to_point()

Parameters:
coords (float | Sequence[float] | Sequence[Sequence[float]] | ndarray)

Return type:
ndarray

get_T_label(x_val, graph, label=None, label_color=None, triangle_size=0.25, triangle_color=ManimColor('#FFFFFF'), line_func=<class 'manim.mobject.geometry.line.Line'>, line_color=ManimColor('#FFFF00'))[source]
Creates a labelled triangle marker with a vertical line from the x-axis to a curve at a given x-value.

Parameters:
x_val (float) – The position along the curve at which the label, line and triangle will be constructed.

graph (ParametricFunction) – The ParametricFunction for which to construct the label.

label (float | str | Mobject | None) – The label of the vertical line and triangle.

label_color (ParsableManimColor | None) – The color of the label.

triangle_size (float) – The size of the triangle.

triangle_color (ParsableManimColor | None) – The color of the triangle.

line_func (type[Line]) – The function used to construct the vertical line.

line_color (ParsableManimColor) – The color of the vertical line.

Returns:
A VGroup of the label, triangle and vertical line mobjects.

Return type:
VGroup

Examples

Example: TLabelExample 

../_images/TLabelExample-1.png
from manim import *

class TLabelExample(Scene):
    def construct(self):
        # defines the axes and linear function
        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)
        func = axes.plot(lambda x: x, color=BLUE)
        # creates the T_label
        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex("x-value"))
        self.add(axes, func, t_label)
Make interactive
get_area(graph, x_range=None, color=(ManimColor('#58C4DD'), ManimColor('#83C167')), opacity=0.3, bounded_graph=None, **kwargs)[source]
Returns a Polygon representing the area under the graph passed.

Parameters:
graph (ParametricFunction) – The graph/curve for which the area needs to be gotten.

x_range (tuple[float, float] | None) – The range of the minimum and maximum x-values of the area. x_range = [x_min, x_max].

color (ParsableManimColor | Iterable[ParsableManimColor]) – The color of the area. Creates a gradient if a list of colors is provided.

opacity (float) – The opacity of the area.

bounded_graph (ParametricFunction) – If a secondary graph is specified, encloses the area between the two curves.

kwargs (Any) – Additional parameters passed to Polygon.

Returns:
The Polygon representing the area.

Return type:
Polygon

Raises:
ValueError – When x_ranges do not match (either area x_range, graph’s x_range or bounded_graph’s x_range).

Examples

Example: GetAreaExample 

../_images/GetAreaExample-1.png
from manim import *

class GetAreaExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)
        area = ax.get_area(
            curve,
            x_range=(PI / 2, 3 * PI / 2),
            color=(GREEN_B, GREEN_D),
            opacity=1,
        )

        self.add(ax, curve, area)
Make interactive
get_graph_label(graph, label='f(x)', x_val=None, direction=array([1., 0., 0.]), buff=0.25, color=None, dot=False, dot_config=None)[source]
Creates a properly positioned label for the passed graph, with an optional dot.

Parameters:
graph (ParametricFunction) – The curve.

label (float | str | Mobject) – The label for the function’s curve. Defaults to MathTex for str and float inputs.

x_val (float | None) – The x_value along the curve that positions the label.

direction (Sequence[float]) – The cartesian position, relative to the curve that the label will be at –> LEFT, RIGHT.

buff (float) – The distance between the curve and the label.

color (ParsableManimColor | None) – The color of the label. Defaults to the color of the curve.

dot (bool) – Whether to add a dot at the point on the graph.

dot_config (dict[str, Any] | None) – Additional parameters to be passed to Dot.

Returns:
The positioned label and Dot, if applicable.

Return type:
Mobject

Examples

Example: GetGraphLabelExample 

../_images/GetGraphLabelExample-1.png
from manim import *

class GetGraphLabelExample(Scene):
    def construct(self):
        ax = Axes()
        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)
        label = ax.get_graph_label(
            graph=sin,
            label= MathTex(r"\frac{\pi}{2}"),
            x_val=PI / 2,
            dot=True,
            direction=UR,
        )

        self.add(ax, sin, label)
Make interactive
get_horizontal_line(point, **kwargs)[source]
A horizontal line from the y-axis to a given point in the scene.

Parameters:
point (Sequence[float]) – The point to which the horizontal line will be drawn.

kwargs – Additional parameters to be passed to get_line_from_axis_to_point.

Returns:
A horizontal line from the y-axis to the point.

Return type:
Line

Examples

Example: GetHorizontalLineExample 

../_images/GetHorizontalLineExample-1.png
from manim import *

class GetHorizontalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax.c2p(-4, 1.5)

        dot = Dot(point)
        line = ax.get_horizontal_line(point, line_func=Line)

        self.add(ax, line, dot)
Make interactive
get_line_from_axis_to_point(index: int, point: Sequence[float], line_config: dict | None = None, color: ParsableManimColor | None = None, stroke_width: float = 2) → DashedLine[source]
get_line_from_axis_to_point(index: int, point: Sequence[float], line_func: type[LineType], line_config: dict | None = None, color: ParsableManimColor | None = None, stroke_width: float = 2) → LineType
Returns a straight line from a given axis to a point in the scene.

Parameters:
index – Specifies the axis from which to draw the line. 0 = x_axis, 1 = y_axis

point – The point to which the line will be drawn.

line_func – The function of the Line mobject used to construct the line.

line_config – Optional arguments to passed to line_func.

color – The color of the line.

stroke_width – The stroke width of the line.

Returns:
The line from an axis to a point.

Return type:
Line

See also

get_vertical_line() get_horizontal_line()

get_lines_to_point(point, **kwargs)[source]
Generate both horizontal and vertical lines from the axis to a point.

Parameters:
point (Sequence[float]) – A point on the scene.

kwargs – Additional parameters to be passed to get_line_from_axis_to_point()

Returns:
A VGroup of the horizontal and vertical lines.

Return type:
VGroup

See also

get_vertical_line() get_horizontal_line()

Examples

Example: GetLinesToPointExample 

../_images/GetLinesToPointExample-1.png
from manim import *

class GetLinesToPointExample(Scene):
    def construct(self):
        ax = Axes()
        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])

        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)
        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)
        self.add(ax, lines_1, lines_2, circ)
Make interactive
get_origin()[source]
Gets the origin of Axes.

Returns:
The center point.

Return type:
np.ndarray

get_riemann_rectangles(graph, x_range=None, dx=0.1, input_sample_type='left', stroke_width=1, stroke_color=ManimColor('#000000'), fill_opacity=1, color=(ManimColor('#58C4DD'), ManimColor('#83C167')), show_signed_area=True, bounded_graph=None, blend=False, width_scale_factor=1.001)[source]
Generates a VGroup of the Riemann Rectangles for a given curve.

Parameters:
graph (ParametricFunction) – The graph whose area will be approximated by Riemann rectangles.

x_range (Sequence[float] | None) – The minimum and maximum x-values of the rectangles. x_range = [x_min, x_max].

dx (float | None) – The change in x-value that separates each rectangle.

input_sample_type (str) – Can be any of "left", "right" or "center". Refers to where the sample point for the height of each Riemann Rectangle will be inside the segments of the partition.

stroke_width (float) – The stroke_width of the border of the rectangles.

stroke_color (ParsableManimColor) – The color of the border of the rectangle.

fill_opacity (float) – The opacity of the rectangles.

color (Iterable[ParsableManimColor] | ParsableManimColor) – The colors of the rectangles. Creates a balanced gradient if multiple colors are passed.

show_signed_area (bool) – Indicates negative area when the curve dips below the x-axis by inverting its color.

blend (bool) – Sets the stroke_color to fill_color, blending the rectangles without clear separation.

bounded_graph (ParametricFunction) – If a secondary graph is specified, encloses the area between the two curves.

width_scale_factor (float) – The factor by which the width of the rectangles is scaled.

Returns:
A VGroup containing the Riemann Rectangles.

Return type:
VGroup

Examples

Example: GetRiemannRectanglesExample 

../_images/GetRiemannRectanglesExample-1.png
from manim import *

class GetRiemannRectanglesExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-2, 10])
        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)

        # the rectangles are constructed from their top right corner.
        # passing an iterable to `color` produces a gradient
        rects_right = ax.get_riemann_rectangles(
            quadratic,
            x_range=[-4, -3],
            dx=0.25,
            color=(TEAL, BLUE_B, DARK_BLUE),
            input_sample_type="right",
        )

        # the colour of rectangles below the x-axis is inverted
        # due to show_signed_area
        rects_left = ax.get_riemann_rectangles(
            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW
        )

        bounding_line = ax.plot(
            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]
        )
        bounded_rects = ax.get_riemann_rectangles(
            bounding_line,
            bounded_graph=quadratic,
            dx=0.15,
            x_range=[4, 5],
            show_signed_area=False,
            color=(MAROON_A, RED_B, PURPLE_D),
        )

        self.add(
            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects
        )
Make interactive
get_secant_slope_group(x, graph, dx=None, dx_line_color=ManimColor('#FFFF00'), dy_line_color=None, dx_label=None, dy_label=None, include_secant_line=True, secant_line_color=ManimColor('#83C167'), secant_line_length=10)[source]
Creates two lines representing dx and df, the labels for dx and df, and
the secant to the curve at a particular x-value.

Parameters:
x (float) – The x-value at which the secant intersects the graph for the first time.

graph (ParametricFunction) – The curve for which the secant will be found.

dx (float | None) – The change in x after which the secant exits.

dx_line_color (ParsableManimColor) – The color of the line that indicates the change in x.

dy_line_color (ParsableManimColor | None) – The color of the line that indicates the change in y. Defaults to the color of graph.

dx_label (float | str | None) – The label for the dx line. Defaults to MathTex for str and float inputs.

dy_label (float | str | None) – The label for the dy line. Defaults to MathTex for str and float inputs.

include_secant_line (bool) – Whether to include the secant line in the graph, or just the df/dx lines and labels.

secant_line_color (ParsableManimColor) – The color of the secant line.

secant_line_length (float) – The length of the secant line.

Returns:
A group containing the elements: dx_line, df_line, and if applicable also dx_label, df_label, secant_line.

Return type:
VGroup

Examples

Example: GetSecantSlopeGroupExample 

../_images/GetSecantSlopeGroupExample-1.png
from manim import *

class GetSecantSlopeGroupExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-1, 7])
        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)
        slopes = ax.get_secant_slope_group(
            x=2.0,
            graph=graph,
            dx=1.0,
            dx_label=Tex("dx = 1.0"),
            dy_label="dy",
            dx_line_color=GREEN_B,
            secant_line_length=4,
            secant_line_color=RED_D,
        )

        self.add(ax, graph, slopes)
Make interactive
get_vertical_line(point, **kwargs)[source]
A vertical line from the x-axis to a given point in the scene.

Parameters:
point (Sequence[float]) – The point to which the vertical line will be drawn.

kwargs (Any) – Additional parameters to be passed to get_line_from_axis_to_point.

Returns:
A vertical line from the x-axis to the point.

Return type:
Line

Examples

Example: GetVerticalLineExample 

../_images/GetVerticalLineExample-1.png
from manim import *

class GetVerticalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax.coords_to_point(-3.5, 2)

        dot = Dot(point)
        line = ax.get_vertical_line(point, line_config={"dashed_ratio": 0.85})

        self.add(ax, line, dot)
Make interactive
get_vertical_lines_to_graph(graph, x_range=None, num_lines=20, **kwargs)[source]
Obtains multiple lines from the x-axis to the curve.

Parameters:
graph (ParametricFunction) – The graph along which the lines are placed.

x_range (Sequence[float] | None) – A list containing the lower and and upper bounds of the lines: x_range = [x_min, x_max].

num_lines (int) – The number of evenly spaced lines.

kwargs (Any) – Additional arguments to be passed to get_vertical_line().

Returns:
The VGroup of the evenly spaced lines.

Return type:
VGroup

Examples

Example: GetVerticalLinesToGraph 

../_images/GetVerticalLinesToGraph-1.png
from manim import *

class GetVerticalLinesToGraph(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 8.0, 1],
            y_range=[-1, 1, 0.2],
            axis_config={"font_size": 24},
        ).add_coordinates()

        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)

        lines = ax.get_vertical_lines_to_graph(
            curve, x_range=[0, 4], num_lines=30, color=BLUE
        )

        self.add(ax, curve, lines)
Make interactive
get_x_axis_label(label, edge=array([1., 1., 0.]), direction=array([1., 1., 0.]), buff=0.1, **kwargs)[source]
Generate an x-axis label.

Parameters:
label (float | str | Mobject) – The label. Defaults to MathTex for str and float inputs.

edge (Sequence[float]) – The edge of the x-axis to which the label will be added, by default UR.

direction (Sequence[float]) – Allows for further positioning of the label from an edge, by default UR.

buff (float) – The distance of the label from the line.

Returns:
The positioned label.

Return type:
Mobject

Examples

Example: GetXAxisLabelExample 

../_images/GetXAxisLabelExample-1.png
from manim import *

class GetXAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        x_label = ax.get_x_axis_label(
            Tex("$x$-values").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5
        )
        self.add(ax, x_label)
Make interactive
get_y_axis_label(label, edge=array([1., 1., 0.]), direction=array([1., 0.5, 0.]), buff=0.1, **kwargs)[source]
Generate a y-axis label.

Parameters:
label (float | str | Mobject) – The label. Defaults to MathTex for str and float inputs.

edge (Sequence[float]) – The edge of the y-axis to which the label will be added, by default UR.

direction (Sequence[float]) – Allows for further positioning of the label from an edge, by default UR

buff (float) – The distance of the label from the line.

Returns:
The positioned label.

Return type:
Mobject

Examples

Example: GetYAxisLabelExample 

../_images/GetYAxisLabelExample-1.png
from manim import *

class GetYAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        y_label = ax.get_y_axis_label(
            Tex("$y$-values").scale(0.65).rotate(90 * DEGREES),
            edge=LEFT,
            direction=LEFT,
            buff=0.3,
        )
        self.add(ax, y_label)
Make interactive
i2gc(x, graph)[source]
Alias for input_to_graph_coords().

Parameters:
x (float)

graph (ParametricFunction)

Return type:
tuple[float, float]

i2gp(x, graph)[source]
Alias for input_to_graph_point().

Parameters:
x (float)

graph (ParametricFunction)

Return type:
ndarray

input_to_graph_coords(x, graph)[source]
Returns a tuple of the axis relative coordinates of the point on the graph based on the x-value given.

Examples

from manim import Axes
ax = Axes()
parabola = ax.plot(lambda x: x**2)
ax.input_to_graph_coords(x=3, graph=parabola)
(3, 9)
Parameters:
x (float)

graph (ParametricFunction)

Return type:
tuple[float, float]

input_to_graph_point(x, graph)[source]
Returns the coordinates of the point on a graph corresponding to an x value.

Parameters:
x (float) – The x-value of a point on the graph.

graph (ParametricFunction | VMobject) – The ParametricFunction on which the point lies.

Returns:
The coordinates of the point on the graph corresponding to the x value.

Return type:
np.ndarray

Raises:
ValueError – When the target x is not in the range of the line graph.

Examples

Example: InputToGraphPointExample 

../_images/InputToGraphPointExample-1.png
from manim import *

class InputToGraphPointExample(Scene):
    def construct(self):
        ax = Axes()
        curve = ax.plot(lambda x : np.cos(x))

        # move a square to PI on the cosine curve.
        position = ax.input_to_graph_point(x=PI, graph=curve)
        sq = Square(side_length=1, color=YELLOW).move_to(position)

        self.add(ax, curve, sq)
Make interactive
p2c(point)[source]
Abbreviation for point_to_coords()

Parameters:
point (Point3D)

plot(function, x_range=None, use_vectorized=False, **kwargs)[source]
Generates a curve based on a function.

Parameters:
function (Callable[[float], float]) – The function used to construct the ParametricFunction.

x_range (Sequence[float] | None) – The range of the curve along the axes. x_range = [x_min, x_max, x_step].

use_vectorized (bool) – Whether to pass in the generated t value array to the function. Only use this if your function supports it. Output should be a numpy array of shape [y_0, y_1, ...]

kwargs (Any) – Additional parameters to be passed to ParametricFunction.

Returns:
The plotted curve.

Return type:
ParametricFunction

Warning

This method may not produce accurate graphs since Manim currently relies on interpolation between evenly-spaced samples of the curve, instead of intelligent plotting. See the example below for some solutions to this problem.

Examples

Example: PlotExample 

../_images/PlotExample-1.png
from manim import *

class PlotExample(Scene):
    def construct(self):
        # construct the axes
        ax_1 = Axes(
            x_range=[0.001, 6],
            y_range=[-8, 2],
            x_length=5,
            y_length=3,
            tips=False,
        )
        ax_2 = ax_1.copy()
        ax_3 = ax_1.copy()

        # position the axes
        ax_1.to_corner(UL)
        ax_2.to_corner(UR)
        ax_3.to_edge(DOWN)
        axes = VGroup(ax_1, ax_2, ax_3)

        # create the logarithmic curves
        def log_func(x):
            return np.log(x)

        # a curve without adjustments; poor interpolation.
        curve_1 = ax_1.plot(log_func, color=PURE_RED)

        # disabling interpolation makes the graph look choppy as not enough
        # inputs are available
        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)

        # taking more inputs of the curve by specifying a step for the
        # x_range yields expected results, but increases rendering time.
        curve_3 = ax_3.plot(
            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN
        )

        curves = VGroup(curve_1, curve_2, curve_3)

        self.add(axes, curves)
Make interactive
plot_antiderivative_graph(graph, y_intercept=0, samples=50, use_vectorized=False, **kwargs)[source]
Plots an antiderivative graph.

Parameters:
graph (ParametricFunction) – The graph for which the antiderivative will be found.

y_intercept (float) – The y-value at which the graph intercepts the y-axis.

samples (int) – The number of points to take the area under the graph.

use_vectorized (bool) – Whether to use the vectorized version of the antiderivative. This means to pass in the generated t value array to the function. Only use this if your function supports it. Output should be a numpy array of shape [y_0, y_1, ...]

kwargs (Any) – Any valid keyword argument of ParametricFunction.

Returns:
The curve of the antiderivative.

Return type:
ParametricFunction

Note

This graph is plotted from the values of area under the reference graph. The result might not be ideal if the reference graph contains uncalculatable areas from x=0.

Examples

Example: AntiderivativeExample 

../_images/AntiderivativeExample-1.png
from manim import *

class AntiderivativeExample(Scene):
    def construct(self):
        ax = Axes()
        graph1 = ax.plot(
            lambda x: (x ** 2 - 2) / 3,
            color=RED,
        )
        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)
        self.add(ax, graph1, graph2)
Make interactive
plot_derivative_graph(graph, color=ManimColor('#83C167'), **kwargs)[source]
Returns the curve of the derivative of the passed graph.

Parameters:
graph (ParametricFunction) – The graph for which the derivative will be found.

color (ParsableManimColor) – The color of the derivative curve.

kwargs – Any valid keyword argument of ParametricFunction.

Returns:
The curve of the derivative.

Return type:
ParametricFunction

Examples

Example: DerivativeGraphExample 

../_images/DerivativeGraphExample-1.png
from manim import *

class DerivativeGraphExample(Scene):
    def construct(self):
        ax = NumberPlane(y_range=[-1, 7], background_line_style={"stroke_opacity": 0.4})

        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)
        curve_2 = ax.plot_derivative_graph(curve_1)
        curves = VGroup(curve_1, curve_2)

        label_1 = ax.get_graph_label(curve_1, "x^2", x_val=-2, direction=DL)
        label_2 = ax.get_graph_label(curve_2, "2x", x_val=3, direction=RIGHT)
        labels = VGroup(label_1, label_2)

        self.add(ax, curves, labels)
Make interactive
plot_implicit_curve(func, min_depth=5, max_quads=1500, **kwargs)[source]
Creates the curves of an implicit function.

Parameters:
func (Callable[[float, float], float]) – The function to graph, in the form of f(x, y) = 0.

min_depth (int) – The minimum depth of the function to calculate.

max_quads (int) – The maximum number of quads to use.

kwargs (Any) – Additional parameters to pass into ImplicitFunction.

Return type:
ImplicitFunction

Examples

Example: ImplicitExample 

../_images/ImplicitExample-1.png
from manim import *

class ImplicitExample(Scene):
    def construct(self):
        ax = Axes()
        a = ax.plot_implicit_curve(
            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE
        )
        self.add(ax, a)
Make interactive
plot_parametric_curve(function, use_vectorized=False, **kwargs)[source]
A parametric curve.

Parameters:
function (Callable[[float], ndarray]) – A parametric function mapping a number to a point in the coordinate system.

use_vectorized (bool) – Whether to pass in the generated t value array to the function. Only use this if your function supports it.

kwargs (Any) – Any further keyword arguments are passed to ParametricFunction.

Return type:
ParametricFunction

Example

Example: ParametricCurveExample 

../_images/ParametricCurveExample-1.png
from manim import *

class ParametricCurveExample(Scene):
    def construct(self):
        ax = Axes()
        cardioid = ax.plot_parametric_curve(
            lambda t: np.array(
                [
                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),
                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),
                    0,
                ]
            ),
            t_range=[0, 2 * PI],
            color="#0FF1CE",
        )
        self.add(ax, cardioid)
Make interactive
plot_polar_graph(r_func, theta_range=None, **kwargs)[source]
A polar graph.

Parameters:
r_func (Callable[[float], float]) – The function r of theta.

theta_range (Sequence[float] | None) – The range of theta as theta_range = [theta_min, theta_max, theta_step].

kwargs (Any) – Additional parameters passed to ParametricFunction.

Return type:
ParametricFunction

Examples

Example: PolarGraphExample 

../_images/PolarGraphExample-1.png
from manim import *

class PolarGraphExample(Scene):
    def construct(self):
        plane = PolarPlane()
        r = lambda theta: 2 * np.sin(theta * 5)
        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)
        self.add(plane, graph)
Make interactive
References: PolarPlane

plot_surface(function, u_range=None, v_range=None, colorscale=None, colorscale_axis=2, **kwargs)[source]
Generates a surface based on a function.

Parameters:
function (Callable[[float], float]) – The function used to construct the Surface.

u_range (Sequence[float] | None) – The range of the u variable: (u_min, u_max).

v_range (Sequence[float] | None) – The range of the v variable: (v_min, v_max).

colorscale (Sequence[ParsableManimColor] | Sequence[tuple[ParsableManimColor, float]] | None) – Colors of the surface. Passing a list of colors will color the surface by z-value. Passing a list of tuples in the form (color, pivot) allows user-defined pivots where the color transitions.

colorscale_axis (int) – Defines the axis on which the colorscale is applied (0 = x, 1 = y, 2 = z), default is z-axis (2).

kwargs (Any) – Additional parameters to be passed to Surface.

Returns:
The plotted surface.

Return type:
Surface

Examples

Example: PlotSurfaceExample 

../_images/PlotSurfaceExample-1.png
from manim import *

class PlotSurfaceExample(ThreeDScene):
    def construct(self):
        resolution_fa = 16
        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)
        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))
        def param_trig(u, v):
            x = u
            y = v
            z = 2 * np.sin(x) + 2 * np.cos(y)
            return z
        trig_plane = axes.plot_surface(
            param_trig,
            resolution=(resolution_fa, resolution_fa),
            u_range = (-3, 3),
            v_range = (-3, 3),
            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],
            )
        self.add(axes, trig_plane)
Make interactive
point_to_polar(point)[source]
Gets polar coordinates from a point.

Parameters:
point (ndarray) – The point.

Returns:
The coordinate radius (
) and the coordinate azimuth (
).

Return type:
Tuple[float, float]

polar_to_point(radius, azimuth)[source]
Gets a point from polar coordinates.

Parameters:
radius (float) – The coordinate radius (
).

azimuth (float) – The coordinate azimuth (
).

Returns:
The point.

Return type:
numpy.ndarray

Examples

Example: PolarToPointExample 

../_images/PolarToPointExample-1.png
from manim import *

class PolarToPointExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(azimuth_units="PI radians", size=6)
        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))
        self.add(polarplane_pi)
        self.add(polartopoint_vector)
Make interactive
References: PolarPlane Vector

pr2pt(radius, azimuth)[source]
Abbreviation for polar_to_point()

Parameters:
radius (float)

azimuth (float)

Return type:
ndarray

pt2pr(point)[source]
Abbreviation for point_to_polar()

Parameters:
point (ndarray)

Return type:
tuple[float, float]

slope_of_tangent(x, graph, **kwargs)[source]
Returns the slope of the tangent to the plotted curve at a particular x-value.

Parameters:
x (float) – The x-value at which the tangent must touch the curve.

graph (ParametricFunction) – The ParametricFunction for which to calculate the tangent.

kwargs (Any)

Returns:
The slope of the tangent with the x axis.

Return type:
float

Examples

ax = Axes()
curve = ax.plot(lambda x: x**2)
ax.slope_of_tangent(x=-2, graph=curve)
# -3.5000000259052038

NumberPlane
Qualified name: manim.mobject.graphing.coordinate\_systems.NumberPlane

class NumberPlane(x_range=(-7.111111111111111, 7.111111111111111, 1), y_range=(-4.0, 4.0, 1), x_length=None, y_length=None, background_line_style=None, faded_line_style=None, faded_line_ratio=1, make_smooth_after_applying_functions=True, **kwargs)[source]
Bases: Axes

Creates a cartesian plane with background lines.

Parameters:
x_range (Sequence[float] | None) – The [x_min, x_max, x_step] values of the plane in the horizontal direction.

y_range (Sequence[float] | None) – The [y_min, y_max, y_step] values of the plane in the vertical direction.

x_length (float | None) – The width of the plane.

y_length (float | None) – The height of the plane.

background_line_style (dict[str, Any] | None) – Arguments that influence the construction of the background lines of the plane.

faded_line_style (dict[str, Any] | None) – Similar to background_line_style, affects the construction of the scene’s background lines.

faded_line_ratio (int) – Determines the number of boxes within the background lines: 2 = 4 boxes, 3 = 9 boxes.

make_smooth_after_applying_functions (bool) – Currently non-functional.

kwargs (dict[str, Any]) – Additional arguments to be passed to Axes.

Note

If x_length or y_length are not defined, they are automatically calculated such that one unit on each axis is one Manim unit long.

Examples

Example: NumberPlaneExample 

../_images/NumberPlaneExample-1.png
from manim import *

class NumberPlaneExample(Scene):
    def construct(self):
        number_plane = NumberPlane(
            background_line_style={
                "stroke_color": TEAL,
                "stroke_width": 4,
                "stroke_opacity": 0.6
            }
        )
        self.add(number_plane)
Make interactive
Example: NumberPlaneScaled 

../_images/NumberPlaneScaled-1.png
from manim import *

class NumberPlaneScaled(Scene):
    def construct(self):
        number_plane = NumberPlane(
            x_range=(-4, 11, 1),
            y_range=(-3, 3, 1),
            x_length=5,
            y_length=2,
        ).move_to(LEFT*3)

        number_plane_scaled_y = NumberPlane(
            x_range=(-4, 11, 1),
            x_length=5,
            y_length=4,
        ).move_to(RIGHT*3)

        self.add(number_plane)
        self.add(number_plane_scaled_y)
Make interactive
Methods

get_vector

prepare_for_nonlinear_transform

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_get_lines()[source]
Generate all the lines, faded and not faded.
Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.

Returns:
The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.

Return type:
Tuple[VGroup, VGroup]

_get_lines_parallel_to_axis(axis_parallel_to, axis_perpendicular_to, freq, ratio_faded_lines)[source]
Generate a set of lines parallel to an axis.

Parameters:
axis_parallel_to (NumberLine) – The axis with which the lines will be parallel.

axis_perpendicular_to (NumberLine) – The axis with which the lines will be perpendicular.

ratio_faded_lines (int) – The ratio between the space between faded lines and the space between non-faded lines.

freq (float) – Frequency of non-faded lines (number of non-faded lines per graph unit).

Returns:
The first (i.e the non-faded lines parallel to axis_parallel_to) and second
(i.e the faded lines parallel to axis_parallel_to) sets of lines, respectively.

Return type:
Tuple[VGroup, VGroup]

_init_background_lines()[source]
Will init all the lines of NumberPlanes (faded or not)

Return type:
None

_original__init__(x_range=(-7.111111111111111, 7.111111111111111, 1), y_range=(-4.0, 4.0, 1), x_length=None, y_length=None, background_line_style=None, faded_line_style=None, faded_line_ratio=1, make_smooth_after_applying_functions=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
x_range (Sequence[float] | None)

y_range (Sequence[float] | None)

x_length (float | None)

y_length (float | None)

background_line_style (dict[str, Any] | None)

faded_line_style (dict[str, Any] | None)

faded_line_ratio (int)

make_smooth_after_applying_functions (bool)

kwargs (dict[str, Any])

PolarPlane
Qualified name: manim.mobject.graphing.coordinate\_systems.PolarPlane

class PolarPlane(radius_max=4.0, size=None, radius_step=1, azimuth_step=None, azimuth_units='PI radians', azimuth_compact_fraction=True, azimuth_offset=0, azimuth_direction='CCW', azimuth_label_buff=0.1, azimuth_label_font_size=24, radius_config=None, background_line_style=None, faded_line_style=None, faded_line_ratio=1, make_smooth_after_applying_functions=True, **kwargs)[source]
Bases: Axes

Creates a polar plane with background lines.

Parameters:
azimuth_step (float | None) –

The number of divisions in the azimuth (also known as the angular coordinate or polar angle). If None is specified then it will use the default specified by azimuth_units:

"PI radians" or "TAU radians": 20

"degrees": 36

"gradians": 40

None: 1

A non-integer value will result in a partial division at the end of the circle.

size (float | None) – The diameter of the plane.

radius_step (float) – The distance between faded radius lines.

radius_max (float) – The maximum value of the radius.

azimuth_units (str | None) –

Specifies a default labelling system for the azimuth. Choices are:

"PI radians": Fractional labels in the interval 
 with 
 as a constant.

"TAU radians": Fractional labels in the interval 
 (where 
) with 
 as a constant.

"degrees": Decimal labels in the interval 
 with a degree (
) symbol.

"gradians": Decimal labels in the interval 
 with a superscript “g” (
).

None: Decimal labels in the interval 
.

azimuth_compact_fraction (bool) – If the azimuth_units choice has fractional labels, choose whether to combine the constant in a compact form 
 
 as opposed to 
 
, where 
 is the constant.

azimuth_offset (float) – The angle offset of the azimuth, expressed in radians.

azimuth_direction (str) –

The direction of the azimuth.

"CW": Clockwise.

"CCW": Anti-clockwise.

azimuth_label_buff (float) – The buffer for the azimuth labels.

azimuth_label_font_size (float) – The font size of the azimuth labels.

radius_config (dict[str, Any] | None) – The axis config for the radius.

background_line_style (dict[str, Any] | None)

faded_line_style (dict[str, Any] | None)

faded_line_ratio (int)

make_smooth_after_applying_functions (bool)

kwargs (Any)

Examples

Example: PolarPlaneExample 

../_images/PolarPlaneExample-1.png
from manim import *

class PolarPlaneExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(
            azimuth_units="PI radians",
            size=6,
            azimuth_label_font_size=33.6,
            radius_config={"font_size": 33.6},
        ).add_coordinates()
        self.add(polarplane_pi)
Make interactive
References: PolarPlane

Methods

add_coordinates

Adds the coordinates.

get_axes

Gets the axes.

get_coordinate_labels

Gets labels for the coordinates

get_radian_label

get_vector

prepare_for_nonlinear_transform

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_get_lines()[source]
Generate all the lines and circles, faded and not faded.

Returns:
The first (i.e the non faded lines and circles) and second (i.e the faded lines and circles) sets of lines and circles, respectively.

Return type:
Tuple[VGroup, VGroup]

_init_background_lines()[source]
Will init all the lines of NumberPlanes (faded or not)

Return type:
None

_original__init__(radius_max=4.0, size=None, radius_step=1, azimuth_step=None, azimuth_units='PI radians', azimuth_compact_fraction=True, azimuth_offset=0, azimuth_direction='CCW', azimuth_label_buff=0.1, azimuth_label_font_size=24, radius_config=None, background_line_style=None, faded_line_style=None, faded_line_ratio=1, make_smooth_after_applying_functions=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
radius_max (float)

size (float | None)

radius_step (float)

azimuth_step (float | None)

azimuth_units (str | None)

azimuth_compact_fraction (bool)

azimuth_offset (float)

azimuth_direction (str)

azimuth_label_buff (float)

azimuth_label_font_size (float)

radius_config (dict[str, Any] | None)

background_line_style (dict[str, Any] | None)

faded_line_style (dict[str, Any] | None)

faded_line_ratio (int)

make_smooth_after_applying_functions (bool)

kwargs (Any)

Return type:
None

add_coordinates(r_values=None, a_values=None)[source]
Adds the coordinates.

Parameters:
r_values (Iterable[float] | None) – Iterable of values along the radius, by default None.

a_values (Iterable[float] | None) – Iterable of values along the azimuth, by default None.

Return type:
Self

get_axes()[source]
Gets the axes.

Returns:
A pair of axes.

Return type:
VGroup

get_coordinate_labels(r_values=None, a_values=None, **kwargs)[source]
Gets labels for the coordinates

Parameters:
r_values (Iterable[float] | None) – Iterable of values along the radius, by default None.

a_values (Iterable[float] | None) – Iterable of values along the azimuth, by default None.

kwargs (Any)

Returns:
Labels for the radius and azimuth values.

Return type:
VDict

ThreeDAxes
Qualified name: manim.mobject.graphing.coordinate\_systems.ThreeDAxes

class ThreeDAxes(x_range=(-6, 6, 1), y_range=(-5, 5, 1), z_range=(-4, 4, 1), x_length=10.5, y_length=10.5, z_length=6.5, z_axis_config=None, z_normal=array([0., -1., 0.]), num_axis_pieces=20, light_source=array([-7., -9., 10.]), depth=None, gloss=0.5, **kwargs)[source]
Bases: Axes

A 3-dimensional set of axes.

Parameters:
x_range (Sequence[float] | None) – The [x_min, x_max, x_step] values of the x-axis.

y_range (Sequence[float] | None) – The [y_min, y_max, y_step] values of the y-axis.

z_range (Sequence[float] | None) – The [z_min, z_max, z_step] values of the z-axis.

x_length (float | None) – The length of the x-axis.

y_length (float | None) – The length of the y-axis.

z_length (float | None) – The length of the z-axis.

z_axis_config (dict[str, Any] | None) – Arguments to be passed to NumberLine that influence the z-axis.

z_normal (Vector3D) – The direction of the normal.

num_axis_pieces (int) – The number of pieces used to construct the axes.

light_source (Sequence[float]) – The direction of the light source.

depth – Currently non-functional.

gloss – Currently non-functional.

kwargs (dict[str, Any]) – Additional arguments to be passed to Axes.

Methods

get_axis_labels

Defines labels for the x_axis and y_axis of the graph.

get_y_axis_label

Generate a y-axis label.

get_z_axis_label

Generate a z-axis label.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(x_range=(-6, 6, 1), y_range=(-5, 5, 1), z_range=(-4, 4, 1), x_length=10.5, y_length=10.5, z_length=6.5, z_axis_config=None, z_normal=array([0., -1., 0.]), num_axis_pieces=20, light_source=array([-7., -9., 10.]), depth=None, gloss=0.5, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
x_range (Sequence[float] | None)

y_range (Sequence[float] | None)

z_range (Sequence[float] | None)

x_length (float | None)

y_length (float | None)

z_length (float | None)

z_axis_config (dict[str, Any] | None)

z_normal (Vector3D)

num_axis_pieces (int)

light_source (Sequence[float])

kwargs (dict[str, Any])

Return type:
None

get_axis_labels(x_label='x', y_label='y', z_label='z')[source]
Defines labels for the x_axis and y_axis of the graph.

For increased control over the position of the labels, use get_x_axis_label(), get_y_axis_label(), and get_z_axis_label().

Parameters:
x_label (float | str | Mobject) – The label for the x_axis. Defaults to MathTex for str and float inputs.

y_label (float | str | Mobject) – The label for the y_axis. Defaults to MathTex for str and float inputs.

z_label (float | str | Mobject) – The label for the z_axis. Defaults to MathTex for str and float inputs.

Returns:
A VGroup of the labels for the x_axis, y_axis, and z_axis.

Return type:
VGroup

See also

get_x_axis_label() get_y_axis_label() get_z_axis_label()

Examples

Example: GetAxisLabelsExample 

../_images/GetAxisLabelsExample-2.png
from manim import *

class GetAxisLabelsExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        axes = ThreeDAxes()
        labels = axes.get_axis_labels(
            Text("x-axis").scale(0.7), Text("y-axis").scale(0.45), Text("z-axis").scale(0.45)
        )
        self.add(axes, labels)
Make interactive
get_y_axis_label(label, edge=array([1., 1., 0.]), direction=array([1., 1., 0.]), buff=0.1, rotation=1.5707963267948966, rotation_axis=array([0., 0., 1.]), **kwargs)[source]
Generate a y-axis label.

Parameters:
label (float | str | Mobject) – The label. Defaults to MathTex for str and float inputs.

edge (Sequence[float]) – The edge of the y-axis to which the label will be added, by default UR.

direction (Sequence[float]) – Allows for further positioning of the label from an edge, by default UR.

buff (float) – The distance of the label from the line, by default SMALL_BUFF.

rotation (float) – The angle at which to rotate the label, by default PI/2.

rotation_axis (Vector3D) – The axis about which to rotate the label, by default OUT.

Returns:
The positioned label.

Return type:
Mobject

Examples

Example: GetYAxisLabelExample 

../_images/GetYAxisLabelExample-2.png
from manim import *

class GetYAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_y_axis_label(Tex("$y$-label"))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)
Make interactive
get_z_axis_label(label, edge=array([0., 0., 1.]), direction=array([1., 0., 0.]), buff=0.1, rotation=1.5707963267948966, rotation_axis=array([1., 0., 0.]), **kwargs)[source]
Generate a z-axis label.

Parameters:
label (float | str | Mobject) – The label. Defaults to MathTex for str and float inputs.

edge (Vector3D) – The edge of the z-axis to which the label will be added, by default OUT.

direction (Vector3D) – Allows for further positioning of the label from an edge, by default RIGHT.

buff (float) – The distance of the label from the line, by default SMALL_BUFF.

rotation (float) – The angle at which to rotate the label, by default PI/2.

rotation_axis (Vector3D) – The axis about which to rotate the label, by default RIGHT.

kwargs (Any)

Returns:
The positioned label.

Return type:
Mobject

Examples

Example: GetZAxisLabelExample 

../_images/GetZAxisLabelExample-1.png
from manim import *

class GetZAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_z_axis_label(Tex("$z$-label"))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)

functions
Mobjects representing function graphs.

Classes

FunctionGraph

A ParametricFunction that spans the length of the scene by default.

ImplicitFunction

An implicit function.

ParametricFunction

A parametric curve.

FunctionGraph
Qualified name: manim.mobject.graphing.functions.FunctionGraph

class FunctionGraph(function, x_range=None, color=ManimColor('#FFFF00'), **kwargs)[source]
Bases: ParametricFunction

A ParametricFunction that spans the length of the scene by default.

Examples

Example: ExampleFunctionGraph 

../_images/ExampleFunctionGraph-1.png
from manim import *

class ExampleFunctionGraph(Scene):
    def construct(self):
        cos_func = FunctionGraph(
            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),
            color=RED,
        )

        sin_func_1 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            color=BLUE,
        )

        sin_func_2 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            x_range=[-4, 4],
            color=GREEN,
        ).move_to([0, 1, 0])

        self.add(cos_func, sin_func_1, sin_func_2)
Make interactive
Methods

get_function

get_point_from_function

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(function, x_range=None, color=ManimColor('#FFFF00'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

ImplicitFunction
Qualified name: manim.mobject.graphing.functions.ImplicitFunction

class ImplicitFunction(func, x_range=None, y_range=None, min_depth=5, max_quads=1500, use_smoothing=True, **kwargs)[source]
Bases: VMobject

An implicit function.

Parameters:
func (Callable[[float, float], float]) – The implicit function in the form f(x, y) = 0.

x_range (Sequence[float] | None) – The x min and max of the function.

y_range (Sequence[float] | None) – The y min and max of the function.

min_depth (int) – The minimum depth of the function to calculate.

max_quads (int) – The maximum number of quads to use.

use_smoothing (bool) – Whether or not to smoothen the curves.

kwargs – Additional parameters to pass into VMobject

Note

A small min_depth 
 means that some small details might be ignored if they don’t cross an edge of one of the 
 uniform quads.

The value of max_quads strongly corresponds to the quality of the curve, but a higher number of quads may take longer to render.

Examples

Example: ImplicitFunctionExample 

../_images/ImplicitFunctionExample-1.png
from manim import *

class ImplicitFunctionExample(Scene):
    def construct(self):
        graph = ImplicitFunction(
            lambda x, y: x * y ** 2 - x ** 2 * y - 2,
            color=YELLOW
        )
        self.add(NumberPlane(), graph)
Make interactive
Methods

generate_points

Initializes points and therefore the shape.

init_points

Initializes points and therefore the shape.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(func, x_range=None, y_range=None, min_depth=5, max_quads=1500, use_smoothing=True, **kwargs)
An implicit function.

Parameters:
func (Callable[[float, float], float]) – The implicit function in the form f(x, y) = 0.

x_range (Sequence[float] | None) – The x min and max of the function.

y_range (Sequence[float] | None) – The y min and max of the function.

min_depth (int) – The minimum depth of the function to calculate.

max_quads (int) – The maximum number of quads to use.

use_smoothing (bool) – Whether or not to smoothen the curves.

kwargs – Additional parameters to pass into VMobject

Note

A small min_depth 
 means that some small details might be ignored if they don’t cross an edge of one of the 
 uniform quads.

The value of max_quads strongly corresponds to the quality of the curve, but a higher number of quads may take longer to render.

Examples

Example: ImplicitFunctionExample 

../_images/ImplicitFunctionExample-2.png
from manim import *

class ImplicitFunctionExample(Scene):
    def construct(self):
        graph = ImplicitFunction(
            lambda x, y: x * y ** 2 - x ** 2 * y - 2,
            color=YELLOW
        )
        self.add(NumberPlane(), graph)
Make interactive
generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

init_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses

ParametricFunction
Qualified name: manim.mobject.graphing.functions.ParametricFunction

class ParametricFunction(function, t_range=(0, 1), scaling=<manim.mobject.graphing.scale.LinearBase object>, dt=1e-08, discontinuities=None, use_smoothing=True, use_vectorized=False, **kwargs)[source]
Bases: VMobject

A parametric curve.

Parameters:
function (Callable[[float], Point3D]) – The function to be plotted in the form of (lambda t: (x(t), y(t), z(t)))

t_range (Point2D | Point3D) – Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default [0, 1]

scaling (_ScaleBase) – Scaling class applied to the points of the function. Default of LinearBase.

use_smoothing (bool) – Whether to interpolate between the points of the function after they have been created. (Will have odd behaviour with a low number of points)

use_vectorized (bool) – Whether to pass in the generated t value array to the function as [t_0, t_1, ...]. Only use this if your function supports it. Output should be a numpy array of shape [[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]] but z can also be 0 if the Axes is 2D

discontinuities (Iterable[float] | None) – Values of t at which the function experiences discontinuity.

dt (float) – The left and right tolerance for the discontinuities.

Examples

Example: PlotParametricFunction 

../_images/PlotParametricFunction-1.png
from manim import *

class PlotParametricFunction(Scene):
    def func(self, t):
        return (np.sin(2 * t), np.sin(3 * t), 0)

    def construct(self):
        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)
        self.add(func.scale(3))
Make interactive
Example: ThreeDParametricSpring 

../_images/ThreeDParametricSpring-1.png
from manim import *

class ThreeDParametricSpring(ThreeDScene):
    def construct(self):
        curve1 = ParametricFunction(
            lambda u: (
                1.2 * np.cos(u),
                1.2 * np.sin(u),
                u * 0.05
            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)
        ).set_shade_in_3d(True)
        axes = ThreeDAxes()
        self.add(axes, curve1)
        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)
        self.wait()
Make interactive
Attention

If your function has discontinuities, you’ll have to specify the location of the discontinuities manually. See the following example for guidance.

Example: DiscontinuousExample 

../_images/DiscontinuousExample-1.png
from manim import *

class DiscontinuousExample(Scene):
    def construct(self):
        ax1 = NumberPlane((-3, 3), (-4, 4))
        ax2 = NumberPlane((-3, 3), (-4, 4))
        VGroup(ax1, ax2).arrange()
        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)
        incorrect = ax1.plot(discontinuous_function, color=RED)
        correct = ax2.plot(
            discontinuous_function,
            discontinuities=[-2, 2],  # discontinuous points
            dt=0.1,  # left and right tolerance of discontinuity
            color=GREEN,
        )
        self.add(ax1, ax2, incorrect, correct)
Make interactive
Methods

generate_points

Initializes points and therefore the shape.

get_function

get_point_from_function

init_points

Initializes points and therefore the shape.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(function, t_range=(0, 1), scaling=<manim.mobject.graphing.scale.LinearBase object>, dt=1e-08, discontinuities=None, use_smoothing=True, use_vectorized=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
function (Callable[[float], Point3D])

t_range (Point2D | Point3D)

scaling (_ScaleBase)

dt (float)

discontinuities (Iterable[float] | None)

use_smoothing (bool)

use_vectorized (bool)

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

init_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

number_line
Mobject representing a number line.

Classes

NumberLine

Creates a number line with tick marks.

UnitInterval

NumberLine
Qualified name: manim.mobject.graphing.number\_line.NumberLine

class NumberLine(x_range=None, length=None, unit_size=1, include_ticks=True, tick_size=0.1, numbers_with_elongated_ticks=None, longer_tick_multiple=2, exclude_origin_tick=False, rotation=0, stroke_width=2.0, include_tip=False, tip_width=0.35, tip_height=0.35, tip_shape=None, include_numbers=False, font_size=36, label_direction=array([ 0., -1., 0.]), label_constructor=<class 'manim.mobject.text.tex_mobject.MathTex'>, scaling=<manim.mobject.graphing.scale.LinearBase object>, line_to_number_buff=0.25, decimal_number_config=None, numbers_to_exclude=None, numbers_to_include=None, **kwargs)[source]
Bases: Line

Creates a number line with tick marks.

Parameters:
x_range (Sequence[float] | None) – The [x_min, x_max, x_step] values to create the line.

length (float | None) – The length of the number line.

unit_size (float) – The distance between each tick of the line. Overwritten by length, if specified.

include_ticks (bool) – Whether to include ticks on the number line.

tick_size (float) – The length of each tick mark.

numbers_with_elongated_ticks (Iterable[float] | None) – An iterable of specific values with elongated ticks.

longer_tick_multiple (int) – Influences how many times larger elongated ticks are than regular ticks (2 = 2x).

rotation (float) – The angle (in radians) at which the line is rotated.

stroke_width (float) – The thickness of the line.

include_tip (bool) – Whether to add a tip to the end of the line.

tip_width (float) – The width of the tip.

tip_height (float) – The height of the tip.

tip_shape (type[ArrowTip] | None) – The mobject class used to construct the tip, or None (the default) for the default arrow tip. Passed classes have to inherit from ArrowTip.

include_numbers (bool) – Whether to add numbers to the tick marks. The number of decimal places is determined by the step size, this default can be overridden by decimal_number_config.

scaling (_ScaleBase) – The way the x_range is value is scaled, i.e. LogBase for a logarithmic numberline. Defaults to LinearBase.

font_size (float) – The size of the label mobjects. Defaults to 36.

label_direction (Sequence[float]) – The specific position to which label mobjects are added on the line.

label_constructor (VMobject) – Determines the mobject class that will be used to construct the labels of the number line.

line_to_number_buff (float) – The distance between the line and the label mobject.

decimal_number_config (dict | None) – Arguments that can be passed to DecimalNumber to influence number mobjects.

numbers_to_exclude (Iterable[float] | None) – An explicit iterable of numbers to not be added to the number line.

numbers_to_include (Iterable[float] | None) – An explicit iterable of numbers to add to the number line

kwargs – Additional arguments to be passed to Line.

exclude_origin_tick (bool)

Note

Number ranges that include both negative and positive values will be generated from the 0 point, and may not include a tick at the min / max values as the tick locations are dependent on the step size.

Examples

Example: NumberLineExample 

../_images/NumberLineExample-1.png
from manim import *

class NumberLineExample(Scene):
    def construct(self):
        l0 = NumberLine(
            x_range=[-10, 10, 2],
            length=10,
            color=BLUE,
            include_numbers=True,
            label_direction=UP,
        )

        l1 = NumberLine(
            x_range=[-10, 10, 2],
            unit_size=0.5,
            numbers_with_elongated_ticks=[-2, 4],
            include_numbers=True,
            font_size=24,
        )
        num6 = l1.numbers[8]
        num6.set_color(RED)

        l2 = NumberLine(
            x_range=[-2.5, 2.5 + 0.5, 0.5],
            length=12,
            decimal_number_config={"num_decimal_places": 2},
            include_numbers=True,
        )

        l3 = NumberLine(
            x_range=[-5, 5 + 1, 1],
            length=6,
            include_tip=True,
            include_numbers=True,
            rotation=10 * DEGREES,
        )

        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)
        self.add(line_group)
Make interactive
Methods

add_labels

Adds specifically positioned labels to the NumberLine using a dict.

add_numbers

Adds DecimalNumber mobjects representing their position at each tick of the number line.

add_ticks

Adds ticks to the number line.

get_labels

get_number_mobject

Generates a positioned DecimalNumber mobject generated according to label_constructor.

get_number_mobjects

get_tick

Generates a tick and positions it along the number line.

get_tick_marks

get_tick_range

Generates the range of values on which labels are plotted based on the x_range attribute of the number line.

get_unit_size

get_unit_vector

n2p

Abbreviation for number_to_point().

number_to_point

Accepts a value along the number line and returns a point with respect to the scene.

p2n

Abbreviation for point_to_number().

point_to_number

Accepts a point with respect to the scene and returns a float along the number line.

rotate_about_number

rotate_about_zero

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_create_label_tex(label_tex, label_constructor=None, **kwargs)[source]
Checks if the label is a VMobject, otherwise, creates a label by passing label_tex to label_constructor.

Parameters:
label_tex (str | float | VMobject) – The label for which a mobject should be created. If the label already is a mobject, no new mobject is created.

label_constructor (Callable | None) – Optional. A class or function returning a mobject when passing label_tex as an argument. If None is passed (the default), the label constructor from the label_constructor attribute is used.

Returns:
The label.

Return type:
VMobject

_original__init__(x_range=None, length=None, unit_size=1, include_ticks=True, tick_size=0.1, numbers_with_elongated_ticks=None, longer_tick_multiple=2, exclude_origin_tick=False, rotation=0, stroke_width=2.0, include_tip=False, tip_width=0.35, tip_height=0.35, tip_shape=None, include_numbers=False, font_size=36, label_direction=array([ 0., -1., 0.]), label_constructor=<class 'manim.mobject.text.tex_mobject.MathTex'>, scaling=<manim.mobject.graphing.scale.LinearBase object>, line_to_number_buff=0.25, decimal_number_config=None, numbers_to_exclude=None, numbers_to_include=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
x_range (Sequence[float] | None)

length (float | None)

unit_size (float)

include_ticks (bool)

tick_size (float)

numbers_with_elongated_ticks (Iterable[float] | None)

longer_tick_multiple (int)

exclude_origin_tick (bool)

rotation (float)

stroke_width (float)

include_tip (bool)

tip_width (float)

tip_height (float)

tip_shape (type[ArrowTip] | None)

include_numbers (bool)

font_size (float)

label_direction (Sequence[float])

label_constructor (VMobject)

scaling (_ScaleBase)

line_to_number_buff (float)

decimal_number_config (dict | None)

numbers_to_exclude (Iterable[float] | None)

numbers_to_include (Iterable[float] | None)

add_labels(dict_values, direction=None, buff=None, font_size=None, label_constructor=None)[source]
Adds specifically positioned labels to the NumberLine using a dict. The labels can be accessed after creation via self.labels.

Parameters:
dict_values (dict[float, str | float | VMobject]) – A dictionary consisting of the position along the number line and the mobject to be added: {1: Tex("Monday"), 3: Tex("Tuesday")}. label_constructor will be used to construct the labels if the value is not a mobject (str or float).

direction (Sequence[float]) – Determines the direction at which the label is positioned next to the line.

buff (float | None) – The distance of the label from the line.

font_size (float | None) – The font size of the mobject to be positioned.

label_constructor (VMobject | None) – The VMobject class that will be used to construct the label. Defaults to the label_constructor attribute of the number line if not specified.

Raises:
AttributeError – If the label does not have a font_size attribute, an AttributeError is raised.

add_numbers(x_values=None, excluding=None, font_size=None, label_constructor=None, **kwargs)[source]
Adds DecimalNumber mobjects representing their position at each tick of the number line. The numbers can be accessed after creation via self.numbers.

Parameters:
x_values (Iterable[float] | None) – An iterable of the values used to position and create the labels. Defaults to the output produced by get_tick_range()

excluding (Iterable[float] | None) – A list of values to exclude from x_values.

font_size (float | None) – The font size of the labels. Defaults to the font_size attribute of the number line.

label_constructor (VMobject | None) – The VMobject class that will be used to construct the label. Defaults to the label_constructor attribute of the number line if not specified.

add_ticks()[source]
Adds ticks to the number line. Ticks can be accessed after creation via self.ticks.

get_number_mobject(x, direction=None, buff=None, font_size=None, label_constructor=None, **number_config)[source]
Generates a positioned DecimalNumber mobject generated according to label_constructor.

Parameters:
x (float) – The x-value at which the mobject should be positioned.

direction (Sequence[float] | None) – Determines the direction at which the label is positioned next to the line.

buff (float | None) – The distance of the label from the line.

font_size (float | None) – The font size of the label mobject.

label_constructor (VMobject | None) – The VMobject class that will be used to construct the label. Defaults to the label_constructor attribute of the number line if not specified.

Returns:
The positioned mobject.

Return type:
DecimalNumber

get_tick(x, size=None)[source]
Generates a tick and positions it along the number line.

Parameters:
x (float) – The position of the tick.

size (float | None) – The factor by which the tick is scaled.

Returns:
A positioned tick.

Return type:
Line

get_tick_range()[source]
Generates the range of values on which labels are plotted based on the x_range attribute of the number line.

Returns:
A numpy array of floats represnting values along the number line.

Return type:
np.ndarray

n2p(number)[source]
Abbreviation for number_to_point().

Parameters:
number (float | ndarray)

Return type:
ndarray

number_to_point(number)[source]
Accepts a value along the number line and returns a point with respect to the scene.

Parameters:
number (float | ndarray) – The value to be transformed into a coordinate. Or a list of values.

Returns:
A point with respect to the scene’s coordinate system. Or a list of points.

Return type:
np.ndarray

Examples

from manim import NumberLine
number_line = NumberLine()
number_line.number_to_point(0)
array([0., 0., 0.])
number_line.number_to_point(1)
array([1., 0., 0.])
number_line.number_to_point([1,2,3])
array([[1., 0., 0.],
       [2., 0., 0.],
       [3., 0., 0.]])
p2n(point)[source]
Abbreviation for point_to_number().

Parameters:
point (Sequence[float])

Return type:
float

point_to_number(point)[source]
Accepts a point with respect to the scene and returns a float along the number line.

Parameters:
point (Sequence[float]) – A sequence of values consisting of (x_coord, y_coord, z_coord).

Returns:
A float representing a value along the number line.

Return type:
float

Examples

from manim import NumberLine
number_line = NumberLine()
number_line.point_to_number((0,0,0))
0.0
number_line.point_to_number((1,0,0))
1.0
number_line.point_to_number([[0.5,0,0],[1,0,0],[1.5,0,0]])
array([0.5, 1. , 1.5])

UnitInterval
Qualified name: manim.mobject.graphing.number\_line.UnitInterval

class UnitInterval(unit_size=10, numbers_with_elongated_ticks=None, decimal_number_config=None, **kwargs)[source]
Bases: NumberLine

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(unit_size=10, numbers_with_elongated_ticks=None, decimal_number_config=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

probability
Mobjects representing objects from probability theory and statistics.

Classes

BarChart

Creates a bar chart.

SampleSpace

A mobject representing a twodimensional rectangular sampling space.

BarChart
Qualified name: manim.mobject.graphing.probability.BarChart

class BarChart(values, bar_names=None, y_range=None, x_length=None, y_length=None, bar_colors=['#003f5c', '#58508d', '#bc5090', '#ff6361', '#ffa600'], bar_width=0.6, bar_fill_opacity=0.7, bar_stroke_width=3, **kwargs)[source]
Bases: Axes

Creates a bar chart. Inherits from Axes, so it shares its methods and attributes. Each axis inherits from NumberLine, so pass in x_axis_config/y_axis_config to control their attributes.

Parameters:
values (MutableSequence[float]) – A sequence of values that determines the height of each bar. Accepts negative values.

bar_names (Sequence[str] | None) – A sequence of names for each bar. Does not have to match the length of values.

y_range (Sequence[float] | None) – The y_axis range of values. If None, the range will be calculated based on the min/max of values and the step will be calculated based on y_length.

x_length (float | None) – The length of the x-axis. If None, it is automatically calculated based on the number of values and the width of the screen.

y_length (float | None) – The length of the y-axis.

bar_colors (Iterable[str]) – The color for the bars. Accepts a sequence of colors (can contain just one item). If the length of``bar_colors`` does not match that of values, intermediate colors will be automatically determined.

bar_width (float) – The length of a bar. Must be between 0 and 1.

bar_fill_opacity (float) – The fill opacity of the bars.

bar_stroke_width (float) – The stroke width of the bars.

Examples

Example: BarChartExample 

../_images/BarChartExample-1.png
from manim import *

class BarChartExample(Scene):
    def construct(self):
        chart = BarChart(
            values=[-5, 40, -10, 20, -3],
            bar_names=["one", "two", "three", "four", "five"],
            y_range=[-20, 50, 10],
            y_length=6,
            x_length=10,
            x_axis_config={"font_size": 36},
        )

        c_bar_lbls = chart.get_bar_labels(font_size=48)

        self.add(chart, c_bar_lbls)
Make interactive
Methods

change_bar_values

Updates the height of the bars of the chart.

get_bar_labels

Annotates each bar with its corresponding value.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_add_x_axis_labels()[source]
Essentially :meth`:~.NumberLine.add_labels`, but differs in that the direction of the label with respect to the x_axis changes to UP or DOWN depending on the value.

UP for negative values and DOWN for positive values.

_create_bar(bar_number, value)[source]
Creates a positioned bar on the chart.

Parameters:
bar_number (int) – Determines the x-position of the bar.

value (float) – The value that determines the height of the bar.

Returns:
A positioned rectangle representing a bar on the chart.

Return type:
Rectangle

_original__init__(values, bar_names=None, y_range=None, x_length=None, y_length=None, bar_colors=['#003f5c', '#58508d', '#bc5090', '#ff6361', '#ffa600'], bar_width=0.6, bar_fill_opacity=0.7, bar_stroke_width=3, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
values (MutableSequence[float])

bar_names (Sequence[str] | None)

y_range (Sequence[float] | None)

x_length (float | None)

y_length (float | None)

bar_colors (Iterable[str])

bar_width (float)

bar_fill_opacity (float)

bar_stroke_width (float)

_update_colors()[source]
Initialize the colors of the bars of the chart.

Sets the color of self.bars via self.bar_colors.

Primarily used when the bars are initialized with self._add_bars or updated via self.change_bar_values.

change_bar_values(values, update_colors=True)[source]
Updates the height of the bars of the chart.

Parameters:
values (Iterable[float]) – The values that will be used to update the height of the bars. Does not have to match the number of bars.

update_colors (bool) – Whether to re-initalize the colors of the bars based on self.bar_colors.

Examples

Example: ChangeBarValuesExample 

../_images/ChangeBarValuesExample-1.png
from manim import *

class ChangeBarValuesExample(Scene):
    def construct(self):
        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]

        chart = BarChart(
            values,
            y_range=[-10, 10, 2],
            y_axis_config={"font_size": 24},
        )
        self.add(chart)

        chart.change_bar_values(list(reversed(values)))
        self.add(chart.get_bar_labels(font_size=24))
Make interactive
get_bar_labels(color=None, font_size=24, buff=0.25, label_constructor=<class 'manim.mobject.text.tex_mobject.Tex'>)[source]
Annotates each bar with its corresponding value. Use self.bar_labels to access the labels after creation.

Parameters:
color (ParsableManimColor | None) – The color of each label. By default None and is based on the parent’s bar color.

font_size (float) – The font size of each label.

buff (float) – The distance from each label to its bar. By default 0.4.

label_constructor (type[VMobject]) – The Mobject class to construct the labels, by default Tex.

Examples

Example: GetBarLabelsExample 

../_images/GetBarLabelsExample-1.png
from manim import *

class GetBarLabelsExample(Scene):
    def construct(self):
        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])

        c_bar_lbls = chart.get_bar_labels(
            color=WHITE, label_constructor=MathTex, font_size=36
        )

        self.add(chart, c_bar_lbls)

SampleSpace
Qualified name: manim.mobject.graphing.probability.SampleSpace

class SampleSpace(height=3, width=3, fill_color=ManimColor('#444444'), fill_opacity=1, stroke_width=0.5, stroke_color=ManimColor('#BBBBBB'), default_label_scale_val=1)[source]
Bases: Rectangle

A mobject representing a twodimensional rectangular sampling space.

Examples

Example: ExampleSampleSpace 

../_images/ExampleSampleSpace-1.png
from manim import *

class ExampleSampleSpace(Scene):
    def construct(self):
        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)
        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)
        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)
        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)
        poly_group = VGroup(poly1, poly2, poly3).arrange()
        self.add(poly_group)
Make interactive
Methods

add_braces_and_labels

add_label

add_title

complete_p_list

divide_horizontally

divide_vertically

get_bottom_braces_and_labels

get_division_along_dimension

get_horizontal_division

get_side_braces_and_labels

get_subdivision_braces_and_labels

get_top_braces_and_labels

get_vertical_division

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(height=3, width=3, fill_color=ManimColor('#444444'), fill_opacity=1, stroke_width=0.5, stroke_color=ManimColor('#BBBBBB'), default_label_scale_val=1)
Initialize self. See help(type(self)) for accurate signature.

scale
Classes

LinearBase

The default scaling class.

LogBase

Scale for logarithmic graphs/functions.

LinearBase
Qualified name: manim.mobject.graphing.scale.LinearBase

class LinearBase(scale_factor=1.0)[source]
Bases: _ScaleBase

The default scaling class.

Parameters:
scale_factor (float) – The slope of the linear function, by default 1.0

Methods

function

Multiplies the value by the scale factor.

inverse_function

Inverse of function.

function(value)[source]
Multiplies the value by the scale factor.

Parameters:
value (float) – Value to be multiplied by the scale factor.

Return type:
float

inverse_function(value)[source]
Inverse of function. Divides the value by the scale factor.

Parameters:
value (float) – value to be divided by the scale factor.

Return type:
float

LogBase
Qualified name: manim.mobject.graphing.scale.LogBase

class LogBase(base=10, custom_labels=True)[source]
Bases: _ScaleBase

Scale for logarithmic graphs/functions.

Parameters:
base (float) – The base of the log, by default 10.

custom_labels (bool) – For use with Axes: Whether or not to include LaTeX axis labels, by default True.

Examples

func = ParametricFunction(lambda x: x, scaling=LogBase(base=2))
Methods

function

Scales the value to fit it to a logarithmic scale.``self.function(5)==10**5``

get_custom_labels

Produces custom Integer labels in the form of 10^2.

inverse_function

Inverse of function.

function(value)[source]
Scales the value to fit it to a logarithmic scale.``self.function(5)==10**5``

Parameters:
value (float)

Return type:
float

get_custom_labels(val_range, unit_decimal_places=0, **base_config)[source]
Produces custom Integer labels in the form of 10^2.

Parameters:
val_range (Iterable[float]) – The iterable of values used to create the labels. Determines the exponent.

unit_decimal_places (int) – The number of decimal places to include in the exponent

base_config (dict[str, Any]) – Additional arguments to be passed to Integer.

Return type:
list[Mobject]

inverse_function(value)[source]
Inverse of function. The value must be greater than 0

Parameters:
value (float)

Return type:
float

logo
Utilities for Manim’s logo and banner.

Classes

ManimBanner

Convenience class representing Manim's banner.

ManimBanner
Qualified name: manim.mobject.logo.ManimBanner

class ManimBanner(dark_theme=True)[source]
Bases: VGroup

Convenience class representing Manim’s banner.

Can be animated using custom methods.

Parameters:
dark_theme (bool) – If True (the default), the dark theme version of the logo (with light text font) will be rendered. Otherwise, if False, the light theme version (with dark text font) is used.

Examples

Example: DarkThemeBanner 

from manim import *

class DarkThemeBanner(Scene):
    def construct(self):
        banner = ManimBanner()
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))
Make interactive
Example: LightThemeBanner 

from manim import *

class LightThemeBanner(Scene):
    def construct(self):
        self.camera.background_color = "#ece6e2"
        banner = ManimBanner(dark_theme=False)
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))
Make interactive
Methods

create

The creation animation for Manim's logo.

expand

An animation that expands Manim's logo into its banner.

scale

Scale the banner by the specified scale factor.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(dark_theme=True)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
dark_theme (bool)

create(run_time=2)[source]
The creation animation for Manim’s logo.

Parameters:
run_time (float) – The run time of the animation.

Returns:
An animation to be used in a Scene.play() call.

Return type:
AnimationGroup

expand(run_time=1.5, direction='center')[source]
An animation that expands Manim’s logo into its banner.

The returned animation transforms the banner from its initial state (representing Manim’s logo with just the icons) to its expanded state (showing the full name together with the icons).

See the class documentation for how to use this.

Note

Before calling this method, the text “anim” is not a submobject of the banner object. After the expansion, it is added as a submobject so subsequent animations to the banner object apply to the text “anim” as well.

Parameters:
run_time (float) – The run time of the animation.

direction – The direction in which the logo is expanded.

Returns:
An animation to be used in a Scene.play() call.

Return type:
Succession

Examples

Example: ExpandDirections 

from manim import *

class ExpandDirections(Scene):
    def construct(self):
        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]
        self.play(
            banners[0].expand(direction="right"),
            banners[1].expand(direction="center"),
            banners[2].expand(direction="left"),
        )
Make interactive
scale(scale_factor, **kwargs)[source]
Scale the banner by the specified scale factor.

Parameters:
scale_factor (float) – The factor used for scaling the banner.

Returns:
The scaled banner.

Return type:
ManimBanner

matrix
Mobjects representing matrices.

Examples

Example: MatrixExamples 

../_images/MatrixExamples-1.png
from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([["\\pi", 0], [-1, 1]])
        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],
            left_bracket="(",
            right_bracket=")")
        m2 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12.33]],
            element_to_mobject_config={"num_decimal_places": 2},
            left_bracket="\\{",
            right_bracket="\\}")
        m3 = MobjectMatrix(
            [[Circle().scale(0.3), Square().scale(0.3)],
            [MathTex("\\pi").scale(2), Star().scale(0.3)]],
            left_bracket="\\langle",
            right_bracket="\\rangle")
        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)
        self.add(g)
Make interactive
Classes

DecimalMatrix

A mobject that displays a matrix with decimal entries on the screen.

IntegerMatrix

A mobject that displays a matrix with integer entries on the screen.

Matrix

A mobject that displays a matrix on the screen.

MobjectMatrix

A mobject that displays a matrix of mobject entries on the screen.

Functions

get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)[source]
Helper function to create determinant.

Parameters:
matrix (Matrix) – The matrix whose determinant is to be created

determinant (int | str | None) – The value of the determinant of the matrix

background_rect (bool) – The background rectangle

initial_scale_factor (float) – The scale of the text det w.r.t the matrix

Returns:
A VGroup containing the determinant

Return type:
VGroup

Examples

Example: DeterminantOfAMatrix 

../_images/DeterminantOfAMatrix-1.png
from manim import *

class DeterminantOfAMatrix(Scene):
    def construct(self):
        matrix = Matrix([
            [2, 0],
            [-1, 1]
        ])

        # scaling down the `det` string
        det = get_det_text(matrix,
                    determinant=3,
                    initial_scale_factor=1)

        # must add the matrix
        self.add(matrix)
        self.add(det)
Make interactive
matrix_to_mobject(matrix)[source]
matrix_to_tex_string

DecimalMatrix
Qualified name: manim.mobject.matrix.DecimalMatrix

class DecimalMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)[source]
Bases: Matrix

A mobject that displays a matrix with decimal entries on the screen.

Examples

Example: DecimalMatrixExample 

../_images/DecimalMatrixExample-1.png
from manim import *

class DecimalMatrixExample(Scene):
    def construct(self):
        m0 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12]],
            element_to_mobject_config={"num_decimal_places": 2},
            left_bracket="\{",
            right_bracket="\}")
        self.add(m0)
Make interactive
Will round/truncate the decimal places as per the provided config.

Parameters:
matrix (Iterable) – A numpy 2d array or list of lists

element_to_mobject (Mobject) – Mobject to use, by default DecimalNumber

element_to_mobject_config (dict[str, Mobject]) – Config for the desired mobject, by default {“num_decimal_places”: 1}

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)
Will round/truncate the decimal places as per the provided config.

Parameters:
matrix (Iterable) – A numpy 2d array or list of lists

element_to_mobject (Mobject) – Mobject to use, by default DecimalNumber

element_to_mobject_config (dict[str, Mobject]) – Config for the desired mobject, by default {“num_decimal_places”: 1}

IntegerMatrix
Qualified name: manim.mobject.matrix.IntegerMatrix

class IntegerMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)[source]
Bases: Matrix

A mobject that displays a matrix with integer entries on the screen.

Examples

Example: IntegerMatrixExample 

../_images/IntegerMatrixExample-1.png
from manim import *

class IntegerMatrixExample(Scene):
    def construct(self):
        m0 = IntegerMatrix(
            [[3.7, 2], [42.2, 12]],
            left_bracket="(",
            right_bracket=")")
        self.add(m0)
Make interactive
Will round if there are decimal entries in the matrix.

Parameters:
matrix (Iterable) – A numpy 2d array or list of lists

element_to_mobject (Mobject) – Mobject to use, by default Integer

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)
Will round if there are decimal entries in the matrix.

Parameters:
matrix (Iterable) – A numpy 2d array or list of lists

element_to_mobject (Mobject) – Mobject to use, by default Integer

Matrix
Qualified name: manim.mobject.matrix.Matrix

class Matrix(matrix, v_buff=0.8, h_buff=1.3, bracket_h_buff=0.25, bracket_v_buff=0.25, add_background_rectangles_to_entries=False, include_background_rectangle=False, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, element_to_mobject_config={}, element_alignment_corner=array([ 1., -1., 0.]), left_bracket='[', right_bracket=']', stretch_brackets=True, bracket_config={}, **kwargs)[source]
Bases: VMobject

A mobject that displays a matrix on the screen.

Parameters:
matrix (Iterable) – A numpy 2d array or list of lists.

v_buff (float) – Vertical distance between elements, by default 0.8.

h_buff (float) – Horizontal distance between elements, by default 1.3.

bracket_h_buff (float) – Distance of the brackets from the matrix, by default MED_SMALL_BUFF.

bracket_v_buff (float) – Height of the brackets, by default MED_SMALL_BUFF.

add_background_rectangles_to_entries (bool) – True if should add backgraound rectangles to entries, by default False.

include_background_rectangle (bool) – True if should include background rectangle, by default False.

element_to_mobject (type[MathTex]) – The mobject class used to construct the elements, by default MathTex.

element_to_mobject_config (dict) – Additional arguments to be passed to the constructor in element_to_mobject, by default {}.

element_alignment_corner (Sequence[float]) – The corner to which elements are aligned, by default DR.

left_bracket (str) – The left bracket type, by default "[".

right_bracket (str) – The right bracket type, by default "]".

stretch_brackets (bool) – True if should stretch the brackets to fit the height of matrix contents, by default True.

bracket_config (dict) – Additional arguments to be passed to MathTex when constructing the brackets.

Examples

The first example shows a variety of uses of this module while the second example exlpains the use of the options add_background_rectangles_to_entries and include_background_rectangle.

Example: MatrixExamples 

../_images/MatrixExamples-2.png
from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([[2, "\pi"], [-1, 1]])
        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],
            v_buff=1.3,
            h_buff=0.8,
            bracket_h_buff=SMALL_BUFF,
            bracket_v_buff=SMALL_BUFF,
            left_bracket="\{",
            right_bracket="\}")
        m1.add(SurroundingRectangle(m1.get_columns()[1]))
        m2 = Matrix([[2, 1], [-1, 3]],
            element_alignment_corner=UL,
            left_bracket="(",
            right_bracket=")")
        m3 = Matrix([[2, 1], [-1, 3]],
            left_bracket="\\langle",
            right_bracket="\\rangle")
        m4 = Matrix([[2, 1], [-1, 3]],
        ).set_column_colors(RED, GREEN)
        m5 = Matrix([[2, 1], [-1, 3]],
        ).set_row_colors(RED, GREEN)
        g = Group(
            m0,m1,m2,m3,m4,m5
        ).arrange_in_grid(buff=2)
        self.add(g)
Make interactive
Example: BackgroundRectanglesExample 

../_images/BackgroundRectanglesExample-1.png
from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background= Rectangle().scale(3.2)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        m0 = Matrix([[12, -30], [-1, 15]],
            add_background_rectangles_to_entries=True)
        m1 = Matrix([[2, 0], [-1, 1]],
            include_background_rectangle=True)
        m2 = Matrix([[12, -30], [-1, 15]])
        g = Group(m0, m1, m2).arrange(buff=2)
        self.add(g)
Make interactive
Methods

add_background_to_entries

Add a black background rectangle to the matrix, see above for an example.

get_brackets

Return the bracket mobjects.

get_columns

Return columns of the matrix as VGroups.

get_entries

Return the individual entries of the matrix.

get_mob_matrix

Return the underlying mob matrix mobjects.

get_rows

Return rows of the matrix as VGroups.

set_column_colors

Set individual colors for each columns of the matrix.

set_row_colors

Set individual colors for each row of the matrix.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_add_brackets(left='[', right=']', **kwargs)[source]
Adds the brackets to the Matrix mobject.

See Latex document for various bracket types.

Parameters:
left (str) – the left bracket, by default “[”

right (str) – the right bracket, by default “]”

Returns:
The current matrix object (self).

Return type:
Matrix

_original__init__(matrix, v_buff=0.8, h_buff=1.3, bracket_h_buff=0.25, bracket_v_buff=0.25, add_background_rectangles_to_entries=False, include_background_rectangle=False, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, element_to_mobject_config={}, element_alignment_corner=array([ 1., -1., 0.]), left_bracket='[', right_bracket=']', stretch_brackets=True, bracket_config={}, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
matrix (Iterable)

v_buff (float)

h_buff (float)

bracket_h_buff (float)

bracket_v_buff (float)

add_background_rectangles_to_entries (bool)

include_background_rectangle (bool)

element_to_mobject (type[MathTex])

element_to_mobject_config (dict)

element_alignment_corner (Sequence[float])

left_bracket (str)

right_bracket (str)

stretch_brackets (bool)

bracket_config (dict)

add_background_to_entries()[source]
Add a black background rectangle to the matrix, see above for an example.

Returns:
The current matrix object (self).

Return type:
Matrix

get_brackets()[source]
Return the bracket mobjects.

Returns:
Each VGroup contains a bracket

Return type:
List[VGroup]

Examples

Example: GetBracketsExample 

../_images/GetBracketsExample-1.png
from manim import *

class GetBracketsExample(Scene):
    def construct(self):
        m0 = Matrix([["\pi", 3], [1, 5]])
        bra = m0.get_brackets()
        colors = [BLUE, GREEN]
        for k in range(len(colors)):
            bra[k].set_color(colors[k])
        self.add(m0)
Make interactive
get_columns()[source]
Return columns of the matrix as VGroups.

Returns:
Each VGroup contains a column of the matrix.

Return type:
List[VGroup]

Examples

Example: GetColumnsExample 

../_images/GetColumnsExample-1.png
from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        m0 = Matrix([["\pi", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_columns()[1]))
        self.add(m0)
Make interactive
get_entries()[source]
Return the individual entries of the matrix.

Returns:
VGroup containing entries of the matrix.

Return type:
VGroup

Examples

Example: GetEntriesExample 

../_images/GetEntriesExample-1.png
from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        m0 = Matrix([[2, 3], [1, 5]])
        ent = m0.get_entries()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        self.add(m0)
Make interactive
get_mob_matrix()[source]
Return the underlying mob matrix mobjects.

Returns:
Each VGroup contains a row of the matrix.

Return type:
List[VGroup]

get_rows()[source]
Return rows of the matrix as VGroups.

Returns:
Each VGroup contains a row of the matrix.

Return type:
List[VGroup]

Examples

Example: GetRowsExample 

../_images/GetRowsExample-1.png
from manim import *

class GetRowsExample(Scene):
    def construct(self):
        m0 = Matrix([["\pi", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_rows()[1]))
        self.add(m0)
Make interactive
set_column_colors(*colors)[source]
Set individual colors for each columns of the matrix.

Parameters:
colors (str) – The list of colors; each color specified corresponds to a column.

Returns:
The current matrix object (self).

Return type:
Matrix

Examples

Example: SetColumnColorsExample 

../_images/SetColumnColorsExample-1.png
from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        m0 = Matrix([["\pi", 1], [-1, 3]],
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(m0)
Make interactive
set_row_colors(*colors)[source]
Set individual colors for each row of the matrix.

Parameters:
colors (str) – The list of colors; each color specified corresponds to a row.

Returns:
The current matrix object (self).

Return type:
Matrix

Examples

Example: SetRowColorsExample 

../_images/SetRowColorsExample-1.png
from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        m0 = Matrix([["\pi", 1], [-1, 3]],
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(m0)
Make interactive

MobjectMatrix
Qualified name: manim.mobject.matrix.MobjectMatrix

class MobjectMatrix(matrix, element_to_mobject=<function MobjectMatrix.<lambda>>, **kwargs)[source]
Bases: Matrix

A mobject that displays a matrix of mobject entries on the screen.

Examples

Example: MobjectMatrixExample 

../_images/MobjectMatrixExample-1.png
from manim import *

class MobjectMatrixExample(Scene):
    def construct(self):
        a = Circle().scale(0.3)
        b = Square().scale(0.3)
        c = MathTex("\pi").scale(2)
        d = Star().scale(0.3)
        m0 = MobjectMatrix([[a, b], [c, d]])
        self.add(m0)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(matrix, element_to_mobject=<function MobjectMatrix.<lambda>>, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

mobject
Base classes for objects that can be displayed.

Type Aliases

class TimeBasedUpdater
Callable[['Mobject', float], object]
class NonTimeBasedUpdater
Callable[['Mobject'], object]
class Updater
NonTimeBasedUpdater | TimeBasedUpdater
Classes

Group

Groups together multiple Mobjects.

Mobject

Mathematical Object: base class for objects that can be displayed on screen.

Functions

override_animate(method)[source]
Decorator for overriding method animations.

This allows to specify a method (returning an Animation) which is called when the decorated method is used with the .animate syntax for animating the application of a method.

See also

Mobject.animate

Note

Overridden methods cannot be combined with normal or other overridden methods using method chaining with the .animate syntax.

Examples

Example: AnimationOverrideExample 

from manim import *

class CircleWithContent(VGroup):
    def __init__(self, content):
        super().__init__()
        self.circle = Circle()
        self.content = content
        self.add(self.circle, content)
        content.move_to(self.circle.get_center())

    def clear_content(self):
        self.remove(self.content)
        self.content = None

    @override_animate(clear_content)
    def _clear_content_animation(self, anim_args=None):
        if anim_args is None:
            anim_args = {}
        anim = Uncreate(self.content, **anim_args)
        self.clear_content()
        return anim

class AnimationOverrideExample(Scene):
    def construct(self):
        t = Text("hello!")
        my_mobject = CircleWithContent(t)
        self.play(Create(my_mobject))
        self.play(my_mobject.animate.clear_content())
        self.wait()
Make interactive
Return type:
LambdaType

Group
Qualified name: manim.mobject.mobject.Group

class Group(*mobjects, **kwargs)[source]
Bases: Mobject

Groups together multiple Mobjects.

Notes

When adding the same mobject more than once, repetitions are ignored. Use Mobject.copy() to create a separate copy which can then be added to the group.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

depth

The depth of the mobject.

height

The height of the mobject.

width

The width of the mobject.

_original__init__(*mobjects, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Return type:
None

Mobject
Qualified name: manim.mobject.mobject.Mobject

class Mobject(color=ManimColor('#FFFFFF'), name=None, dim=3, target=None, z_index=0)[source]
Bases: object

Mathematical Object: base class for objects that can be displayed on screen.

There is a compatibility layer that allows for getting and setting generic attributes with get_* and set_* methods. See set() for more details.

Parameters:
color (ParsableManimColor | list[ParsableManimColor])

name (str | None)

dim (int)

z_index (float)

submobjects
The contained objects.

Type:
List[Mobject]

points
The points of the objects.

See also

VMobject

Type:
numpy.ndarray

Methods

add

Add mobjects as submobjects.

add_animation_override

Add an animation override.

add_background_rectangle

Add a BackgroundRectangle as submobject.

add_background_rectangle_to_family_members_with_points

add_background_rectangle_to_submobjects

add_n_more_submobjects

add_to_back

Add all passed mobjects to the back of the submobjects.

add_updater

Add an update function to this mobject.

align_data

Aligns the data of this mobject with another mobject.

align_on_border

Direction just needs to be a vector pointing towards side or corner in the 2d plane.

align_points

align_points_with_larger

align_submobjects

align_to

Aligns mobject to another Mobject in a certain direction.

animation_override_for

Returns the function defining a specific animation override for this class.

apply_complex_function

Applies a complex function to a Mobject.

apply_function

apply_function_to_position

apply_function_to_submobject_positions

apply_matrix

apply_over_attr_arrays

apply_points_function_about_point

apply_to_family

Apply a function to self and every submobject with points recursively.

arrange

Sorts Mobject next to each other on screen.

arrange_in_grid

Arrange submobjects in a grid.

arrange_submobjects

Arrange the position of submobjects with a small buffer.

become

Edit points, colors and submobjects to be identical to another Mobject

center

Moves the center of the mobject to the center of the scene.

clear_updaters

Remove every updater.

copy

Create and return an identical copy of the Mobject including all submobjects.

fade

fade_to

family_members_with_points

flip

Flips/Mirrors an mobject about its center.

generate_points

Initializes points and therefore the shape.

generate_target

get_all_points

Return all points from this mobject and all submobjects.

get_array_attrs

get_bottom

Get bottom Point3Ds of a box bounding the Mobject

get_boundary_point

get_center

Get center Point3Ds

get_center_of_mass

get_color

Returns the color of the Mobject

get_coord

Meant to generalize get_x, get_y and get_z

get_corner

Get corner Point3Ds for certain direction.

get_critical_point

Picture a box bounding the Mobject.

get_edge_center

Get edge Point3Ds for certain direction.

get_end

Returns the point, where the stroke that surrounds the Mobject ends.

get_extremum_along_dim

get_family

get_family_updaters

get_group_class

get_image

get_left

Get left Point3Ds of a box bounding the Mobject

get_merged_array

Return all of a given attribute from this mobject and all submobjects.

get_midpoint

Get Point3Ds of the middle of the path that forms the Mobject.

get_mobject_type_class

Return the base class of this mobject type.

get_nadir

Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject.

get_num_points

get_pieces

get_point_mobject

The simplest Mobject to be transformed to or from self.

get_points_defining_boundary

get_right

Get right Point3Ds of a box bounding the Mobject

get_start

Returns the point, where the stroke that surrounds the Mobject starts.

get_start_and_end

Returns starting and ending point of a stroke as a tuple.

get_time_based_updaters

Return all updaters using the dt parameter.

get_top

Get top Point3Ds of a box bounding the Mobject

get_updaters

Return all updaters.

get_x

Returns x Point3D of the center of the Mobject as float

get_y

Returns y Point3D of the center of the Mobject as float

get_z

Returns z Point3D of the center of the Mobject as float

get_z_index_reference_point

get_zenith

Get zenith Point3Ds of a box bounding a 3D Mobject.

has_no_points

Check if Mobject does not contains points.

has_points

Check if Mobject contains points.

has_time_based_updater

Test if self has a time based updater.

init_colors

Initializes the colors.

insert

Inserts a mobject at a specific position into self.submobjects

interpolate

Turns this Mobject into an interpolation between mobject1 and mobject2.

interpolate_color

invert

Inverts the list of submobjects.

is_off_screen

length_over_dim

Measure the length of an Mobject in a certain direction.

match_color

Match the color with the color of another Mobject.

match_coord

Match the Point3Ds with the Point3Ds of another Mobject.

match_depth

Match the depth with the depth of another Mobject.

match_dim_size

Match the specified dimension with the dimension of another Mobject.

match_height

Match the height with the height of another Mobject.

match_points

Edit points, positions, and submobjects to be identical to another Mobject, while keeping the style unchanged.

match_updaters

Match the updaters of the given mobject.

match_width

Match the width with the width of another Mobject.

match_x

Match x coord.

match_y

Match y coord.

match_z

Match z coord.

move_to

Move center of the Mobject to certain Point3D.

next_to

Move this Mobject next to another's Mobject or Point3D.

nonempty_submobjects

null_point_align

If a Mobject with points is being aligned to one without, treat both as groups, and push the one with points into its own submobjects list.

point_from_proportion

pose_at_angle

proportion_from_point

push_self_into_submobjects

put_start_and_end_on

reduce_across_dimension

Find the min or max value from a dimension across all points in this and submobjects.

remove

Remove submobjects.

remove_updater

Remove an updater.

repeat

This can make transition animations nicer

repeat_submobject

replace

rescale_to_fit

reset_points

Sets points to be an empty array.

restore

Restores the state that was previously saved with save_state().

resume_updating

Enable updating from updaters and animations.

reverse_points

rotate

Rotates the Mobject about a certain point.

rotate_about_origin

Rotates the Mobject about the ORIGIN, which is at [0,0,0].

save_image

Saves an image of only this Mobject at its position to a png file.

save_state

Save the current state (position, color & size).

scale

Scale the size by a factor.

scale_to_fit_depth

Scales the Mobject to fit a depth while keeping width/height proportional.

scale_to_fit_height

Scales the Mobject to fit a height while keeping width/depth proportional.

scale_to_fit_width

Scales the Mobject to fit a width while keeping height/depth proportional.

set

Sets attributes.

set_color

Condition is function which takes in one arguments, (x, y, z).

set_color_by_gradient

param colors:
The colors to use for the gradient. Use like set_color_by_gradient(RED, BLUE, GREEN).

set_colors_by_radial_gradient

set_coord

set_default

Sets the default values of keyword arguments.

set_submobject_colors_by_gradient

set_submobject_colors_by_radial_gradient

set_x

Set x value of the center of the Mobject (int or float)

set_y

Set y value of the center of the Mobject (int or float)

set_z

Set z value of the center of the Mobject (int or float)

set_z_index

Sets the Mobject's z_index to the value specified in z_index_value.

set_z_index_by_z_Point3D

Sets the Mobject's z Point3D to the value of z_index.

shift

Shift by the given vectors.

shift_onto_screen

show

shuffle

Shuffles the list of submobjects.

shuffle_submobjects

Shuffles the order of submobjects

sort

Sorts the list of submobjects by a function defined by submob_func.

sort_submobjects

Sort the submobjects

space_out_submobjects

split

stretch

stretch_about_point

stretch_to_fit_depth

Stretches the Mobject to fit a depth, not keeping width/height proportional.

stretch_to_fit_height

Stretches the Mobject to fit a height, not keeping width/depth proportional.

stretch_to_fit_width

Stretches the Mobject to fit a width, not keeping height/depth proportional.

surround

suspend_updating

Disable updating from updaters and animations.

throw_error_if_no_points

to_corner

Moves this Mobject to the given corner of the screen.

to_edge

Moves this Mobject to the given edge of the screen, without affecting its position in the other dimension.

to_original_color

update

Apply all updaters.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

depth

The depth of the mobject.

height

The height of the mobject.

width

The width of the mobject.

classmethod _add_intrinsic_animation_overrides()[source]
Initializes animation overrides marked with the override_animation() decorator.

Return type:
None

add(*mobjects)[source]
Add mobjects as submobjects.

The mobjects are added to submobjects.

Subclasses of mobject may implement + and += dunder methods.

Parameters:
mobjects (Mobject) – The mobjects to add.

Returns:
self

Return type:
Mobject

Raises:
ValueError – When a mobject tries to add itself.

TypeError – When trying to add an object that is not an instance of Mobject.

Notes

A mobject cannot contain itself, and it cannot contain a submobject more than once. If the parent mobject is displayed, the newly-added submobjects will also be displayed (i.e. they are automatically added to the parent Scene).

See also

remove(), add_to_back()

Examples

outer = Mobject()
inner = Mobject()
outer = outer.add(inner)
Duplicates are not added again:

outer = outer.add(inner)
len(outer.submobjects)
1
Adding an object to itself raises an error:

outer.add(outer)
Traceback (most recent call last):
...
ValueError: Mobject cannot contain self
A given mobject cannot be added as a submobject twice to some parent:

parent = Mobject(name="parent")
child = Mobject(name="child")
parent.add(child, child)
[...] WARNING  ...
parent
parent.submobjects
[child]
classmethod add_animation_override(animation_class, override_func)[source]
Add an animation override.

This does not apply to subclasses.

Parameters:
animation_class (type[Animation]) – The animation type to be overridden

override_func (FunctionOverride) – The function returning an animation replacing the default animation. It gets passed the parameters given to the animation constructor.

Raises:
MultiAnimationOverrideException – If the overridden animation was already overridden.

Return type:
None

add_background_rectangle(color=None, opacity=0.75, **kwargs)[source]
Add a BackgroundRectangle as submobject.

The BackgroundRectangle is added behind other submobjects.

This can be used to increase the mobjects visibility in front of a noisy background.

Parameters:
color (ParsableManimColor | None) – The color of the BackgroundRectangle

opacity (float) – The opacity of the BackgroundRectangle

kwargs – Additional keyword arguments passed to the BackgroundRectangle constructor

Returns:
self

Return type:
Mobject

See also

add_to_back(), BackgroundRectangle

add_to_back(*mobjects)[source]
Add all passed mobjects to the back of the submobjects.

If submobjects already contains the given mobjects, they just get moved to the back instead.

Parameters:
mobjects (Mobject) – The mobjects to add.

Returns:
self

Return type:
Mobject

Note

Technically, this is done by adding (or moving) the mobjects to the head of submobjects. The head of this list is rendered first, which places the corresponding mobjects behind the subsequent list members.

Raises:
ValueError – When a mobject tries to add itself.

TypeError – When trying to add an object that is not an instance of Mobject.

Parameters:
mobjects (Mobject)

Return type:
Self

Notes

A mobject cannot contain itself, and it cannot contain a submobject more than once. If the parent mobject is displayed, the newly-added submobjects will also be displayed (i.e. they are automatically added to the parent Scene).

See also

remove(), add()

add_updater(update_function, index=None, call_updater=False)[source]
Add an update function to this mobject.

Update functions, or updaters in short, are functions that are applied to the Mobject in every frame.

Parameters:
update_function (Updater) – The update function to be added. Whenever update() is called, this update function gets called using self as the first parameter. The updater can have a second parameter dt. If it uses this parameter, it gets called using a second value dt, usually representing the time in seconds since the last call of update().

index (int | None) – The index at which the new updater should be added in self.updaters. In case index is None the updater will be added at the end.

call_updater (bool) – Whether or not to call the updater initially. If True, the updater will be called using dt=0.

Returns:
self

Return type:
Mobject

Examples

Example: NextToUpdater 

from manim import *

class NextToUpdater(Scene):
    def construct(self):
        def dot_position(mobject):
            mobject.set_value(dot.get_center()[0])
            mobject.next_to(dot)

        dot = Dot(RIGHT*3)
        label = DecimalNumber()
        label.add_updater(dot_position)
        self.add(dot, label)

        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))
Make interactive
Example: DtUpdater 

from manim import *

class DtUpdater(Scene):
    def construct(self):
        square = Square()

        #Let the square rotate 90° per second
        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))
        self.add(square)
        self.wait(2)
Make interactive
See also

get_updaters(), remove_updater(), UpdateFromFunc

align_data(mobject, skip_point_alignment=False)[source]
Aligns the data of this mobject with another mobject.

Afterwards, the two mobjects will have the same number of submobjects (see align_submobjects()), the same parent structure (see null_point_align()). If skip_point_alignment is false, they will also have the same number of points (see align_points()).

Parameters:
mobject (Mobject) – The other mobject this mobject should be aligned to.

skip_point_alignment (bool) – Controls whether or not the computationally expensive point alignment is skipped (default: False).

Return type:
None

align_on_border(direction, buff=0.5)[source]
Direction just needs to be a vector pointing towards side or corner in the 2d plane.

Parameters:
direction (Vector3D)

buff (float)

Return type:
Self

align_to(mobject_or_point, direction=array([0., 0., 0.]))[source]
Aligns mobject to another Mobject in a certain direction.

Examples: mob1.align_to(mob2, UP) moves mob1 vertically so that its top edge lines ups with mob2’s top edge.

Parameters:
mobject_or_point (Mobject | Point3D)

direction (Vector3D)

Return type:
Self

property animate: _AnimationBuilder | Self
Used to animate the application of any method of self.

Any method called on animate is converted to an animation of applying that method on the mobject itself.

For example, square.set_fill(WHITE) sets the fill color of a square, while square.animate.set_fill(WHITE) animates this action.

Multiple methods can be put in a single animation once via chaining:

self.play(my_mobject.animate.shift(RIGHT).rotate(PI))
Warning

Passing multiple animations for the same Mobject in one call to play() is discouraged and will most likely not work properly. Instead of writing an animation like

self.play(my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI))
make use of method chaining.

Keyword arguments that can be passed to Scene.play() can be passed directly after accessing .animate, like so:

self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))
This is especially useful when animating simultaneous .animate calls that you want to behave differently:

self.play(
    mobject1.animate(run_time=2).rotate(PI),
    mobject2.animate(rate_func=there_and_back).shift(RIGHT),
)
See also

override_animate()

Examples

Example: AnimateExample 

from manim import *

class AnimateExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT))
        self.play(s.animate.scale(2))
        self.play(s.animate.rotate(PI / 2))
        self.play(Uncreate(s))
Make interactive
Example: AnimateChainExample 

from manim import *

class AnimateChainExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
        self.play(Uncreate(s))
Make interactive
Example: AnimateWithArgsExample 

from manim import *

class AnimateWithArgsExample(Scene):
    def construct(self):
        s = Square()
        c = Circle()

        VGroup(s, c).arrange(RIGHT, buff=2)
        self.add(s, c)

        self.play(
            s.animate(run_time=2).rotate(PI / 2),
            c.animate(rate_func=there_and_back).shift(RIGHT),
        )
Make interactive
Warning

.animate
will interpolate the Mobject between its points prior to .animate and its points after applying .animate to it. This may result in unexpected behavior when attempting to interpolate along paths, or rotations. If you want animations to consider the points between, consider using ValueTracker with updaters instead.

classmethod animation_override_for(animation_class)[source]
Returns the function defining a specific animation override for this class.

Parameters:
animation_class (type[Animation]) – The animation class for which the override function should be returned.

Returns:
The function returning the override animation or None if no such animation override is defined.

Return type:
Optional[Callable[[Mobject, …], Animation]]

apply_complex_function(function, **kwargs)[source]
Applies a complex function to a Mobject. The x and y Point3Ds correspond to the real and imaginary parts respectively.

Example

Example: ApplyFuncExample 

from manim import *

class ApplyFuncExample(Scene):
    def construct(self):
        circ = Circle().scale(1.5)
        circ_ref = circ.copy()
        circ.apply_complex_function(
            lambda x: np.exp(x*1j)
        )
        t = ValueTracker(0)
        circ.add_updater(
            lambda x: x.become(circ_ref.copy().apply_complex_function(
                lambda x: np.exp(x+t.get_value()*1j)
            )).set_color(BLUE)
        )
        self.add(circ_ref)
        self.play(TransformFromCopy(circ_ref, circ))
        self.play(t.animate.set_value(TAU), run_time=3)
Make interactive
Parameters:
function (Callable[[complex], complex])

Return type:
Self

apply_to_family(func)[source]
Apply a function to self and every submobject with points recursively.

Parameters:
func (Callable[[Mobject], None]) – The function to apply to each mobject. func gets passed the respective (sub)mobject as parameter.

Returns:
self

Return type:
Mobject

See also

family_members_with_points()

arrange(direction=array([1., 0., 0.]), buff=0.25, center=True, **kwargs)[source]
Sorts Mobject next to each other on screen.

Examples

Example: Example 

../_images/Example-1.png
from manim import *

class Example(Scene):
    def construct(self):
        s1 = Square()
        s2 = Square()
        s3 = Square()
        s4 = Square()
        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
        self.add(x)
Make interactive
Parameters:
direction (Vector3D)

buff (float)

center (bool)

Return type:
Self

arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=array([0., 0., 0.]), row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', **kwargs)[source]
Arrange submobjects in a grid.

Parameters:
rows (int | None) – The number of rows in the grid.

cols (int | None) – The number of columns in the grid.

buff (float | tuple[float, float]) – The gap between grid cells. To specify a different buffer in the horizontal and vertical directions, a tuple of two values can be given - (row, col).

cell_alignment (Vector3D) – The way each submobject is aligned in its grid cell.

row_alignments (str | None) – The vertical alignment for each row (top to bottom). Accepts the following characters: "u" - up, "c" - center, "d" - down.

col_alignments (str | None) – The horizontal alignment for each column (left to right). Accepts the following characters "l" - left, "c" - center, "r" - right.

row_heights (Iterable[float | None] | None) – Defines a list of heights for certain rows (top to bottom). If the list contains None, the corresponding row will fit its height automatically based on the highest element in that row.

col_widths (Iterable[float | None] | None) – Defines a list of widths for certain columns (left to right). If the list contains None, the corresponding column will fit its width automatically based on the widest element in that column.

flow_order (str) – The order in which submobjects fill the grid. Can be one of the following values: “rd”, “dr”, “ld”, “dl”, “ru”, “ur”, “lu”, “ul”. (“rd” -> fill rightwards then downwards)

Returns:
self

Return type:
Mobject

Raises:
ValueError – If rows and cols are too small to fit all submobjects.

ValueError – If cols, col_alignments and col_widths or rows, row_alignments and row_heights have mismatching sizes.

Notes

If only one of cols and rows is set implicitly, the other one will be chosen big enough to fit all submobjects. If neither is set, they will be chosen to be about the same, tending towards cols > rows (simply because videos are wider than they are high).

If both cell_alignment and row_alignments / col_alignments are defined, the latter has higher priority.

Examples

Example: ExampleBoxes 

../_images/ExampleBoxes-1.png
from manim import *

class ExampleBoxes(Scene):
    def construct(self):
        boxes=VGroup(*[Square() for s in range(0,6)])
        boxes.arrange_in_grid(rows=2, buff=0.1)
        self.add(boxes)
Make interactive
Example: ArrangeInGrid 

../_images/ArrangeInGrid-1.png
from manim import *

class ArrangeInGrid(Scene):
    def construct(self):
        boxes = VGroup(*[
            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))
            for i in range(24)
        ])
        self.add(boxes)

        boxes.arrange_in_grid(
            buff=(0.25,0.5),
            col_alignments="lccccr",
            row_alignments="uccd",
            col_widths=[1, *[None]*4, 1],
            row_heights=[1, None, None, 1],
            flow_order="dr"
        )
Make interactive
arrange_submobjects(*args, **kwargs)[source]
Arrange the position of submobjects with a small buffer.

Examples

Example: ArrangeSumobjectsExample 

../_images/ArrangeSumobjectsExample-1.png
from manim import *

class ArrangeSumobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])
        s.shift(UP).set_color(BLUE)
        s2= s.copy().set_color(RED)
        s2.arrange_submobjects()
        s2.shift(DOWN)
        self.add(s,s2)
Make interactive
Return type:
Self

become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)[source]
Edit points, colors and submobjects to be identical to another Mobject

Note

If both match_height and match_width are True then the transformed Mobject will match the height first and then the width.

Parameters:
match_height (bool) – Whether or not to preserve the height of the original Mobject.

match_width (bool) – Whether or not to preserve the width of the original Mobject.

match_depth (bool) – Whether or not to preserve the depth of the original Mobject.

match_center (bool) – Whether or not to preserve the center of the original Mobject.

stretch (bool) – Whether or not to stretch the target mobject to match the the proportions of the original Mobject.

mobject (Mobject)

Return type:
Self

Examples

Example: BecomeScene 

from manim import *

class BecomeScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        circ.become(square)
        self.wait(0.5)
Make interactive
The following examples illustrate how mobject measurements change when using the match_... and stretch arguments. We start with a rectangle that is 2 units high and 4 units wide, which we want to turn into a circle of radius 3:

from manim import Rectangle, Circle
import numpy as np
rect = Rectangle(height=2, width=4)
circ = Circle(radius=3)
With stretch=True, the target circle is deformed to match the proportions of the rectangle, which results in the target mobject being an ellipse with height 2 and width 4. We can check that the resulting points satisfy the ellipse equation 
 with 
 and 
 being the semi-axes:

result = rect.copy().become(circ, stretch=True)
result.height, result.width
(2.0, 4.0)
ellipse_points = np.array(result.get_anchors())
ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)
np.allclose(ellipse_eq, 1)
True
With match_height=True and match_width=True the circle is scaled such that the height or the width of the rectangle will be preserved, respectively. The points of the resulting mobject satisfy the circle equation 
 for the corresponding radius 
:

result = rect.copy().become(circ, match_height=True)
result.height, result.width
(2.0, 2.0)
circle_points = np.array(result.get_anchors())
circle_eq = np.sum(circle_points**2, axis=1)
np.allclose(circle_eq, 1)
True
result = rect.copy().become(circ, match_width=True)
result.height, result.width
(4.0, 4.0)
circle_points = np.array(result.get_anchors())
circle_eq = np.sum(circle_points**2, axis=1)
np.allclose(circle_eq, 2**2)
True
With match_center=True, the resulting mobject is moved such that its center is the same as the center of the original mobject:

rect = rect.shift(np.array([0, 1, 0]))
np.allclose(rect.get_center(), circ.get_center())
False
result = rect.copy().become(circ, match_center=True)
np.allclose(rect.get_center(), result.get_center())
True
center()[source]
Moves the center of the mobject to the center of the scene.

Returns:
The centered mobject.

Return type:
Mobject

clear_updaters(recursive=True)[source]
Remove every updater.

Parameters:
recursive (bool) – Whether to recursively call clear_updaters on all submobjects.

Returns:
self

Return type:
Mobject

See also

remove_updater(), add_updater(), get_updaters()

copy()[source]
Create and return an identical copy of the Mobject including all submobjects.

Returns:
The copy.

Return type:
Mobject

Note

The clone is initially not visible in the Scene, even if the original was.

property depth: float
The depth of the mobject.

Return type:
float

See also

length_over_dim()

flip(axis=array([0., 1., 0.]), **kwargs)[source]
Flips/Mirrors an mobject about its center.

Examples

Example: FlipExample 

../_images/FlipExample-1.png
from manim import *

class FlipExample(Scene):
    def construct(self):
        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
        self.add(s)
        s2= s.copy().flip()
        self.add(s2)
Make interactive
Parameters:
axis (Vector3D)

Return type:
Self

generate_points()[source]
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

get_all_points()[source]
Return all points from this mobject and all submobjects.

May contain duplicates; the order is in a depth-first (pre-order) traversal of the submobjects.

Return type:
Point3D_Array

get_bottom()[source]
Get bottom Point3Ds of a box bounding the Mobject

Return type:
Point3D

get_center()[source]
Get center Point3Ds

Return type:
Point3D

get_color()[source]
Returns the color of the Mobject

Examples

from manim import Square, RED
Square(color=RED).get_color() == RED
True
Return type:
ManimColor

get_coord(dim, direction=array([0., 0., 0.]))[source]
Meant to generalize get_x, get_y and get_z

Parameters:
dim (int)

direction (Vector3D)

get_corner(direction)[source]
Get corner Point3Ds for certain direction.

Parameters:
direction (Vector3D)

Return type:
Point3D

get_critical_point(direction)[source]
Picture a box bounding the Mobject. Such a box has 9 ‘critical points’: 4 corners, 4 edge center, the center. This returns one of them, along the given direction.

sample = Arc(start_angle=PI/7, angle = PI/5)

# These are all equivalent
max_y_1 = sample.get_top()[1]
max_y_2 = sample.get_critical_point(UP)[1]
max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)
Parameters:
direction (Vector3D)

Return type:
Point3D

get_edge_center(direction)[source]
Get edge Point3Ds for certain direction.

Parameters:
direction (Vector3D)

Return type:
Point3D

get_end()[source]
Returns the point, where the stroke that surrounds the Mobject ends.

Return type:
Point3D

get_left()[source]
Get left Point3Ds of a box bounding the Mobject

Return type:
Point3D

get_merged_array(array_attr)[source]
Return all of a given attribute from this mobject and all submobjects.

May contain duplicates; the order is in a depth-first (pre-order) traversal of the submobjects.

Parameters:
array_attr (str)

Return type:
ndarray

get_midpoint()[source]
Get Point3Ds of the middle of the path that forms the Mobject.

Examples

Example: AngleMidPoint 

../_images/AngleMidPoint-1.png
from manim import *

class AngleMidPoint(Scene):
    def construct(self):
        line1 = Line(ORIGIN, 2*RIGHT)
        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)

        a = Angle(line1, line2, radius=1.5, other_angle=False)
        d = Dot(a.get_midpoint()).set_color(RED)

        self.add(line1, line2, a, d)
        self.wait()
Make interactive
Return type:
Point3D

static get_mobject_type_class()[source]
Return the base class of this mobject type.

Return type:
type[Mobject]

get_nadir()[source]
Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject.

Return type:
Point3D

get_point_mobject(center=None)[source]
The simplest Mobject to be transformed to or from self. Should by a point of the appropriate type

get_right()[source]
Get right Point3Ds of a box bounding the Mobject

Return type:
Point3D

get_start()[source]
Returns the point, where the stroke that surrounds the Mobject starts.

Return type:
Point3D

get_start_and_end()[source]
Returns starting and ending point of a stroke as a tuple.

Return type:
tuple[Point3D, Point3D]

get_time_based_updaters()[source]
Return all updaters using the dt parameter.

The updaters use this parameter as the input for difference in time.

Returns:
The list of time based updaters.

Return type:
List[Callable]

See also

get_updaters(), has_time_based_updater()

get_top()[source]
Get top Point3Ds of a box bounding the Mobject

Return type:
Point3D

get_updaters()[source]
Return all updaters.

Returns:
The list of updaters.

Return type:
List[Callable]

See also

add_updater(), get_time_based_updaters()

get_x(direction=array([0., 0., 0.]))[source]
Returns x Point3D of the center of the Mobject as float

Parameters:
direction (Vector3D)

Return type:
ManimFloat

get_y(direction=array([0., 0., 0.]))[source]
Returns y Point3D of the center of the Mobject as float

Parameters:
direction (Vector3D)

Return type:
ManimFloat

get_z(direction=array([0., 0., 0.]))[source]
Returns z Point3D of the center of the Mobject as float

Parameters:
direction (Vector3D)

Return type:
ManimFloat

get_zenith()[source]
Get zenith Point3Ds of a box bounding a 3D Mobject.

Return type:
Point3D

has_no_points()[source]
Check if Mobject does not contains points.

Return type:
bool

has_points()[source]
Check if Mobject contains points.

Return type:
bool

has_time_based_updater()[source]
Test if self has a time based updater.

Returns:
True if at least one updater uses the dt parameter, False otherwise.

Return type:
bool

See also

get_time_based_updaters()

property height: float
The height of the mobject.

Return type:
float

Examples

Example: HeightExample 

from manim import *

class HeightExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.height))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(height=5))
        self.wait()
Make interactive
See also

length_over_dim()

init_colors()[source]
Initializes the colors.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

insert(index, mobject)[source]
Inserts a mobject at a specific position into self.submobjects

Effectively just calls self.submobjects.insert(index, mobject), where self.submobjects is a list.

Highly adapted from Mobject.add.

Parameters:
index (int) – The index at which

mobject (Mobject) – The mobject to be inserted.

Return type:
None

interpolate(mobject1, mobject2, alpha, path_func=<function interpolate>)[source]
Turns this Mobject into an interpolation between mobject1 and mobject2.

Examples

Example: DotInterpolation 

../_images/DotInterpolation-1.png
from manim import *

class DotInterpolation(Scene):
    def construct(self):
        dotR = Dot(color=DARK_GREY)
        dotR.shift(2 * RIGHT)
        dotL = Dot(color=WHITE)
        dotL.shift(2 * LEFT)

        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)

        self.add(dotL, dotR, dotMiddle)
Make interactive
Parameters:
mobject1 (Mobject)

mobject2 (Mobject)

alpha (float)

path_func (PathFuncType)

Return type:
Self

invert(recursive=False)[source]
Inverts the list of submobjects.

Parameters:
recursive (bool) – If True, all submobject lists of this mobject’s family are inverted.

Return type:
None

Examples

Example: InvertSumobjectsExample 

from manim import *

class InvertSumobjectsExample(Scene):
    def construct(self):
        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2 = s.copy()
        s2.invert()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))
Make interactive
length_over_dim(dim)[source]
Measure the length of an Mobject in a certain direction.

Parameters:
dim (int)

Return type:
float

match_color(mobject)[source]
Match the color with the color of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_coord(mobject, dim, direction=array([0., 0., 0.]))[source]
Match the Point3Ds with the Point3Ds of another Mobject.

Parameters:
mobject (Mobject)

dim (int)

direction (Vector3D)

Return type:
Self

match_depth(mobject, **kwargs)[source]
Match the depth with the depth of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_dim_size(mobject, dim, **kwargs)[source]
Match the specified dimension with the dimension of another Mobject.

Parameters:
mobject (Mobject)

dim (int)

Return type:
Self

match_height(mobject, **kwargs)[source]
Match the height with the height of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_points(mobject, copy_submobjects=True)[source]
Edit points, positions, and submobjects to be identical to another Mobject, while keeping the style unchanged.

Examples

Example: MatchPointsScene 

from manim import *

class MatchPointsScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        self.play(circ.animate.match_points(square))
        self.wait(0.5)
Make interactive
Parameters:
mobject (Mobject)

copy_submobjects (bool)

Return type:
Self

match_updaters(mobject)[source]
Match the updaters of the given mobject.

Parameters:
mobject (Mobject) – The mobject whose updaters get matched.

Returns:
self

Return type:
Mobject

Note

All updaters from submobjects are removed, but only updaters of the given mobject are matched, not those of it’s submobjects.

See also

add_updater(), clear_updaters()

match_width(mobject, **kwargs)[source]
Match the width with the width of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_x(mobject, direction=array([0., 0., 0.]))[source]
Match x coord. to the x coord. of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_y(mobject, direction=array([0., 0., 0.]))[source]
Match y coord. to the x coord. of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

match_z(mobject, direction=array([0., 0., 0.]))[source]
Match z coord. to the x coord. of another Mobject.

Parameters:
mobject (Mobject)

Return type:
Self

move_to(point_or_mobject, aligned_edge=array([0., 0., 0.]), coor_mask=array([1, 1, 1]))[source]
Move center of the Mobject to certain Point3D.

Parameters:
point_or_mobject (Point3D | Mobject)

aligned_edge (Vector3D)

coor_mask (Vector3D)

Return type:
Self

next_to(mobject_or_point, direction=array([1., 0., 0.]), buff=0.25, aligned_edge=array([0., 0., 0.]), submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=array([1, 1, 1]))[source]
Move this Mobject next to another’s Mobject or Point3D.

Examples

Example: GeometricShapes 

../_images/GeometricShapes-1.png
from manim import *

class GeometricShapes(Scene):
    def construct(self):
        d = Dot()
        c = Circle()
        s = Square()
        t = Triangle()
        d.next_to(c, RIGHT)
        s.next_to(c, LEFT)
        t.next_to(c, DOWN)
        self.add(d, c, s, t)
Make interactive
Parameters:
mobject_or_point (Mobject | Point3D)

direction (Vector3D)

buff (float)

aligned_edge (Vector3D)

submobject_to_align (Mobject | None)

index_of_submobject_to_align (int | None)

coor_mask (Vector3D)

Return type:
Self

null_point_align(mobject)[source]
If a Mobject with points is being aligned to one without, treat both as groups, and push the one with points into its own submobjects list.

Returns:
self

Return type:
Mobject

Parameters:
mobject (Mobject)

reduce_across_dimension(reduce_func, dim)[source]
Find the min or max value from a dimension across all points in this and submobjects.

Parameters:
reduce_func (Callable)

dim (int)

remove(*mobjects)[source]
Remove submobjects.

The mobjects are removed from submobjects, if they exist.

Subclasses of mobject may implement - and -= dunder methods.

Parameters:
mobjects (Mobject) – The mobjects to remove.

Returns:
self

Return type:
Mobject

See also

add()

remove_updater(update_function)[source]
Remove an updater.

If the same updater is applied multiple times, every instance gets removed.

Parameters:
update_function (Updater) – The update function to be removed.

Returns:
self

Return type:
Mobject

See also

clear_updaters(), add_updater(), get_updaters()

repeat(count)[source]
This can make transition animations nicer

Parameters:
count (int)

Return type:
Self

reset_points()[source]
Sets points to be an empty array.

Return type:
None

restore()[source]
Restores the state that was previously saved with save_state().

Return type:
Self

resume_updating(recursive=True)[source]
Enable updating from updaters and animations.

Parameters:
recursive (bool) – Whether to recursively enable updating on all submobjects.

Returns:
self

Return type:
Mobject

See also

suspend_updating(), add_updater()

rotate(angle, axis=array([0., 0., 1.]), about_point=None, **kwargs)[source]
Rotates the Mobject about a certain point.

Parameters:
angle (float)

axis (Vector3D)

about_point (Point3D | None)

Return type:
Self

rotate_about_origin(angle, axis=array([0., 0., 1.]), axes=[])[source]
Rotates the Mobject about the ORIGIN, which is at [0,0,0].

Parameters:
angle (float)

axis (Vector3D)

Return type:
Self

save_image(name=None)[source]
Saves an image of only this Mobject at its position to a png file.

Parameters:
name (str | None)

Return type:
None

save_state()[source]
Save the current state (position, color & size). Can be restored with restore().

Return type:
Self

scale(scale_factor, **kwargs)[source]
Scale the size by a factor.

Default behavior is to scale about the center of the mobject.

Parameters:
scale_factor (float) – The scaling factor 
. If 
, the mobject will shrink, and for 
 it will grow. Furthermore, if 
, the mobject is also flipped.

kwargs – Additional keyword arguments passed to apply_points_function_about_point().

Returns:
self

Return type:
Mobject

Examples

Example: MobjectScaleExample 

../_images/MobjectScaleExample-1.png
from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        f1 = Text("F")
        f2 = Text("F").scale(2)
        f3 = Text("F").scale(0.5)
        f4 = Text("F").scale(-1)

        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
        self.add(vgroup)
Make interactive
See also

move_to()

scale_to_fit_depth(depth, **kwargs)[source]
Scales the Mobject to fit a depth while keeping width/height proportional.

Parameters:
depth (float)

Return type:
Self

scale_to_fit_height(height, **kwargs)[source]
Scales the Mobject to fit a height while keeping width/depth proportional.

Returns:
self

Return type:
Mobject

Parameters:
height (float)

Examples

from manim import *
sq = Square()
sq.width
2.0
sq.scale_to_fit_height(5)
Square
sq.height
5.0
sq.width
5.0
scale_to_fit_width(width, **kwargs)[source]
Scales the Mobject to fit a width while keeping height/depth proportional.

Returns:
self

Return type:
Mobject

Parameters:
width (float)

Examples

from manim import *
sq = Square()
sq.height
2.0
sq.scale_to_fit_width(5)
Square
sq.width
5.0
sq.height
5.0
set(**kwargs)[source]
Sets attributes.

I.e. my_mobject.set(foo=1) applies my_mobject.foo = 1.

This is a convenience to be used along with animate to animate setting attributes.

In addition to this method, there is a compatibility layer that allows get_* and set_* methods to get and set generic attributes. For instance:

mob = Mobject()
mob.set_foo(0)
Mobject
mob.get_foo()
0
mob.foo
0
This compatibility layer does not interfere with any get_* or set_* methods that are explicitly defined.

Warning

This compatibility layer is for backwards compatibility and is not guaranteed to stay around. Where applicable, please prefer getting/setting attributes normally or with the set() method.

Parameters:
**kwargs – The attributes and corresponding values to set.

Returns:
self

Return type:
Mobject

Examples

mob = Mobject()
mob.set(foo=0)
Mobject
mob.foo
0
set_color(color=ManimColor('#FFFF00'), family=True)[source]
Condition is function which takes in one arguments, (x, y, z). Here it just recurses to submobjects, but in subclasses this should be further implemented based on the the inner workings of color

Parameters:
color (ParsableManimColor)

family (bool)

Return type:
Self

set_color_by_gradient(*colors)[source]
Parameters:
colors (ParsableManimColor) – The colors to use for the gradient. Use like set_color_by_gradient(RED, BLUE, GREEN).

ManimColor.parse(color) (self.color =)

self (return)

Return type:
Self

classmethod set_default(**kwargs)[source]
Sets the default values of keyword arguments.

If this method is called without any additional keyword arguments, the original default values of the initialization method of this class are restored.

Parameters:
kwargs – Passing any keyword argument will update the default values of the keyword arguments of the initialization function of this class.

Return type:
None

Examples

from manim import Square, GREEN
Square.set_default(color=GREEN, fill_opacity=0.25)
s = Square(); s.color, s.fill_opacity
(ManimColor('#83C167'), 0.25)
Square.set_default()
s = Square(); s.color, s.fill_opacity
(ManimColor('#FFFFFF'), 0.0)
Example: ChangedDefaultTextcolor 

../_images/ChangedDefaultTextcolor-1.png
from manim import *

config.background_color = WHITE

class ChangedDefaultTextcolor(Scene):
    def construct(self):
        Text.set_default(color=BLACK)
        self.add(Text("Changing default values is easy!"))

        # we revert the colour back to the default to prevent a bug in the docs.
        Text.set_default(color=WHITE)
Make interactive
set_x(x, direction=array([0., 0., 0.]))[source]
Set x value of the center of the Mobject (int or float)

Parameters:
x (float)

direction (Vector3D)

Return type:
Self

set_y(y, direction=array([0., 0., 0.]))[source]
Set y value of the center of the Mobject (int or float)

Parameters:
y (float)

direction (Vector3D)

Return type:
Self

set_z(z, direction=array([0., 0., 0.]))[source]
Set z value of the center of the Mobject (int or float)

Parameters:
z (float)

direction (Vector3D)

Return type:
Self

set_z_index(z_index_value, family=True)[source]
Sets the Mobject’s z_index to the value specified in z_index_value.

Parameters:
z_index_value (float) – The new value of z_index set.

family (bool) – If True, the z_index value of all submobjects is also set.

Returns:
The Mobject itself, after z_index is set. For chaining purposes. (Returns self.)

Return type:
Mobject

Examples

Example: SetZIndex 

../_images/SetZIndex-1.png
from manim import *

class SetZIndex(Scene):
    def construct(self):
        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)
        square = Square(2, fill_opacity=1).set_z_index(2)
        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)
        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0

        # Displaying order is now defined by z_index values
        self.add(text)
        self.add(square)
        self.add(tex)
        self.add(circle)
Make interactive
set_z_index_by_z_Point3D()[source]
Sets the Mobject’s z Point3D to the value of z_index.

Returns:
The Mobject itself, after z_index is set. (Returns self.)

Return type:
Mobject

shift(*vectors)[source]
Shift by the given vectors.

Parameters:
vectors (Vector3D) – Vectors to shift by. If multiple vectors are given, they are added together.

Returns:
self

Return type:
Mobject

See also

move_to()

shuffle(recursive=False)[source]
Shuffles the list of submobjects.

Parameters:
recursive (bool)

Return type:
None

shuffle_submobjects(*args, **kwargs)[source]
Shuffles the order of submobjects

Examples

Example: ShuffleSubmobjectsExample 

from manim import *

class ShuffleSubmobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2= s.copy()
        s2.shuffle_submobjects()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))
Make interactive
Return type:
None

sort(point_to_num_func=<function Mobject.<lambda>>, submob_func=None)[source]
Sorts the list of submobjects by a function defined by submob_func.

Parameters:
point_to_num_func (Callable[[Point3D], ManimInt])

submob_func (Callable[[Mobject], ManimInt] | None)

Return type:
Self

sort_submobjects(*args, **kwargs)[source]
Sort the submobjects

Return type:
Self

stretch_to_fit_depth(depth, **kwargs)[source]
Stretches the Mobject to fit a depth, not keeping width/height proportional.

Parameters:
depth (float)

Return type:
Self

stretch_to_fit_height(height, **kwargs)[source]
Stretches the Mobject to fit a height, not keeping width/depth proportional.

Returns:
self

Return type:
Mobject

Parameters:
height (float)

Examples

from manim import *
sq = Square()
sq.width
2.0
sq.stretch_to_fit_height(5)
Square
sq.height
5.0
sq.width
2.0
stretch_to_fit_width(width, **kwargs)[source]
Stretches the Mobject to fit a width, not keeping height/depth proportional.

Returns:
self

Return type:
Mobject

Parameters:
width (float)

Examples

from manim import *
sq = Square()
sq.height
2.0
sq.stretch_to_fit_width(5)
Square
sq.width
5.0
sq.height
2.0
suspend_updating(recursive=True)[source]
Disable updating from updaters and animations.

Parameters:
recursive (bool) – Whether to recursively suspend updating on all submobjects.

Returns:
self

Return type:
Mobject

See also

resume_updating(), add_updater()

to_corner(corner=array([-1., -1., 0.]), buff=0.5)[source]
Moves this Mobject to the given corner of the screen.

Returns:
The newly positioned mobject.

Return type:
Mobject

Parameters:
corner (Vector3D)

buff (float)

Examples

Example: ToCornerExample 

../_images/ToCornerExample-1.png
from manim import *

class ToCornerExample(Scene):
    def construct(self):
        c = Circle()
        c.to_corner(UR)
        t = Tex("To the corner!")
        t2 = MathTex("x^3").shift(DOWN)
        self.add(c,t,t2)
        t.to_corner(DL, buff=0)
        t2.to_corner(UL, buff=1.5)
Make interactive
to_edge(edge=array([-1., 0., 0.]), buff=0.5)[source]
Moves this Mobject to the given edge of the screen, without affecting its position in the other dimension.

Returns:
The newly positioned mobject.

Return type:
Mobject

Parameters:
edge (Vector3D)

buff (float)

Examples

Example: ToEdgeExample 

../_images/ToEdgeExample-1.png
from manim import *

class ToEdgeExample(Scene):
    def construct(self):
        tex_top = Tex("I am at the top!")
        tex_top.to_edge(UP)
        tex_side = Tex("I am moving to the side!")
        c = Circle().shift(2*DOWN)
        self.add(tex_top, tex_side)
        tex_side.to_edge(LEFT)
        c.to_edge(RIGHT, buff=0)
Make interactive
update(dt=0, recursive=True)[source]
Apply all updaters.

Does nothing if updating is suspended.

Parameters:
dt (float) – The parameter dt to pass to the update functions. Usually this is the time in seconds since the last call of update.

recursive (bool) – Whether to recursively update all submobjects.

Returns:
self

Return type:
Mobject

See also

add_updater(), get_updaters()

property width: float
The width of the mobject.

Return type:
float

Examples

Example: WidthExample 

from manim import *

class WidthExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.width))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(width=7))
        self.wait()
Make interactive
See also

length_over_dim()

svg
Mobjects related to SVG images.

Modules
brace

Mobject representing curly braces.

svg_mobject

Mobjects generated from an SVG file.

brace
Mobject representing curly braces.

Classes

ArcBrace

Creates a Brace that wraps around an Arc.

Brace

Takes a mobject and draws a brace adjacent to it.

BraceBetweenPoints

Similar to Brace, but instead of taking a mobject it uses 2 points to place the brace.

BraceLabel

Create a brace with a label attached.

BraceText

ArcBrace
Qualified name: manim.mobject.svg.brace.ArcBrace

class ArcBrace(arc=None, direction=array([1., 0., 0.]), **kwargs)[source]
Bases: Brace

Creates a Brace that wraps around an Arc.

The direction parameter allows the brace to be applied from outside or inside the arc.

Warning

The ArcBrace is smaller for arcs with smaller radii.

Note

The ArcBrace is initially a vertical Brace defined by the length of the Arc, but is scaled down to match the start and end angles. An exponential function is then applied after it is shifted based on the radius of the arc.

The scaling effect is not applied for arcs with radii smaller than 1 to prevent over-scaling.

Parameters:
arc (Arc | None) – The Arc that wraps around the Brace mobject.

direction (Sequence[float]) – The direction from which the brace faces the arc. LEFT for inside the arc, and RIGHT for the outside.

Example

Example: ArcBraceExample 

../_images/ArcBraceExample-1.png
from manim import *

class ArcBraceExample(Scene):
    def construct(self):
        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)
        brace_1 = ArcBrace(arc_1,LEFT)
        group_1 = VGroup(arc_1,brace_1)

        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)
        brace_2 = ArcBrace(arc_2)
        group_2 = VGroup(arc_2,brace_2)

        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)
        brace_3 = ArcBrace(arc_3)
        group_3 = VGroup(arc_3,brace_3)

        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)
        brace_4 = ArcBrace(arc_4)
        group_4 = VGroup(arc_4,brace_4)

        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)
        self.add(arc_group.center())
Make interactive
References: Arc

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(arc=None, direction=array([1., 0., 0.]), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
arc (Arc | None)

direction (Sequence[float])

Brace
Qualified name: manim.mobject.svg.brace.Brace

class Brace(mobject, direction=array([0., -1., 0.]), buff=0.2, sharpness=2, stroke_width=0, fill_opacity=1.0, background_stroke_width=0, background_stroke_color=ManimColor('#000000'), **kwargs)[source]
Bases: VMobjectFromSVGPath

Takes a mobject and draws a brace adjacent to it.

Passing a direction vector determines the direction from which the brace is drawn. By default it is drawn from below.

Parameters:
mobject (Mobject) – The mobject adjacent to which the brace is placed.

direction (Sequence[float] | None) – The direction from which the brace faces the mobject.

See also

BraceBetweenPoints

Examples

Example: BraceExample 

../_images/BraceExample-1.png
from manim import *

class BraceExample(Scene):
    def construct(self):
        s = Square()
        self.add(s)
        for i in np.linspace(0.1,1.0,4):
            br = Brace(s, sharpness=i)
            t = Text(f"sharpness= {i}").next_to(br, RIGHT)
            self.add(t)
            self.add(br)
        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)
Make interactive
Methods

get_direction

Uses shoelace_direction() to calculate the direction.

get_tex

get_text

get_tip

put_at_tip

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(mobject, direction=array([0., -1., 0.]), buff=0.2, sharpness=2, stroke_width=0, fill_opacity=1.0, background_stroke_width=0, background_stroke_color=ManimColor('#000000'), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mobject (Mobject)

direction (Sequence[float] | None)

get_direction()[source]
Uses shoelace_direction() to calculate the direction. The direction of points determines in which direction the object is drawn, clockwise or counterclockwise.

Examples

The default direction of a Circle is counterclockwise:

from manim import Circle
Circle().get_direction()
'CCW'
Returns:
Either "CW" or "CCW".

Return type:
str

BraceBetweenPoints
Qualified name: manim.mobject.svg.brace.BraceBetweenPoints

class BraceBetweenPoints(point_1, point_2, direction=array([0., 0., 0.]), **kwargs)[source]
Bases: Brace

Similar to Brace, but instead of taking a mobject it uses 2 points to place the brace.

A fitting direction for the brace is computed, but it still can be manually overridden. If the points go from left to right, the brace is drawn from below. Swapping the points places the brace on the opposite side.

Parameters:
point_1 (Sequence[float] | None) – The first point.

point_2 (Sequence[float] | None) – The second point.

direction (Sequence[float] | None) – The direction from which the brace faces towards the points.

Examples

Example: BraceBPExample 

from manim import *

class BraceBPExample(Scene):
    def construct(self):
        p1 = [0,0,0]
        p2 = [1,2,0]
        brace = BraceBetweenPoints(p1,p2)
        self.play(Create(NumberPlane()))
        self.play(Create(brace))
        self.wait(2)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(point_1, point_2, direction=array([0., 0., 0.]), **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
point_1 (Sequence[float] | None)

point_2 (Sequence[float] | None)

direction (Sequence[float] | None)

BraceLabel
Qualified name: manim.mobject.svg.brace.BraceLabel

class BraceLabel(obj, text, brace_direction=array([ 0., -1., 0.]), label_constructor=<class 'manim.mobject.text.tex_mobject.MathTex'>, font_size=48, buff=0.2, brace_config=None, **kwargs)[source]
Bases: VMobject

Create a brace with a label attached.

Parameters:
obj (Mobject) – The mobject adjacent to which the brace is placed.

text (str) – The label text.

brace_direction (np.ndarray) – The direction of the brace. By default DOWN.

label_constructor (type) – A class or function used to construct a mobject representing the label. By default MathTex.

font_size (float) – The font size of the label, passed to the label_constructor.

buff (float) – The buffer between the mobject and the brace.

brace_config (dict | None) – Arguments to be passed to Brace.

kwargs – Additional arguments to be passed to VMobject.

Methods

change_brace_label

change_label

creation_anim

shift_brace

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(obj, text, brace_direction=array([ 0., -1., 0.]), label_constructor=<class 'manim.mobject.text.tex_mobject.MathTex'>, font_size=48, buff=0.2, brace_config=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
obj (Mobject)

text (str)

brace_direction (ndarray)

label_constructor (type)

font_size (float)

buff (float)

brace_config (dict | None)

BraceText
Qualified name: manim.mobject.svg.brace.BraceText

class BraceText(obj, text, label_constructor=<class 'manim.mobject.text.tex_mobject.Tex'>, **kwargs)[source]
Bases: BraceLabel

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(obj, text, label_constructor=<class 'manim.mobject.text.tex_mobject.Tex'>, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

svg_mobject
Mobjects generated from an SVG file.

Classes

SVGMobject

A vectorized mobject created from importing an SVG file.

VMobjectFromSVGPath

A vectorized mobject representing an SVG path.

SVGMobject
Qualified name: manim.mobject.svg.svg\_mobject.SVGMobject

class SVGMobject(file_name=None, should_center=True, height=2, width=None, color=None, opacity=None, fill_color=None, fill_opacity=None, stroke_color=None, stroke_opacity=None, stroke_width=None, svg_default=None, path_string_config=None, use_svg_cache=True, **kwargs)[source]
Bases: VMobject

A vectorized mobject created from importing an SVG file.

Parameters:
file_name (str | os.PathLike | None) – The path to the SVG file.

should_center (bool) – Whether or not the mobject should be centered after being imported.

height (float | None) – The target height of the mobject, set to 2 Manim units by default. If the height and width are both set to None, the mobject is imported without being scaled.

width (float | None) – The target width of the mobject, set to None by default. If the height and the width are both set to None, the mobject is imported without being scaled.

color (str | None) – The color (both fill and stroke color) of the mobject. If None (the default), the colors set in the SVG file are used.

opacity (float | None) – The opacity (both fill and stroke opacity) of the mobject. If None (the default), the opacity set in the SVG file is used.

fill_color (str | None) – The fill color of the mobject. If None (the default), the fill colors set in the SVG file are used.

fill_opacity (float | None) – The fill opacity of the mobject. If None (the default), the fill opacities set in the SVG file are used.

stroke_color (str | None) – The stroke color of the mobject. If None (the default), the stroke colors set in the SVG file are used.

stroke_opacity (float | None) – The stroke opacity of the mobject. If None (the default), the stroke opacities set in the SVG file are used.

stroke_width (float | None) – The stroke width of the mobject. If None (the default), the stroke width values set in the SVG file are used.

svg_default (dict | None) – A dictionary in which fallback values for unspecified properties of elements in the SVG file are defined. If None (the default), color, opacity, fill_color fill_opacity, stroke_color, and stroke_opacity are set to None, and stroke_width is set to 0.

path_string_config (dict | None) – A dictionary with keyword arguments passed to VMobjectFromSVGPath used for importing path elements. If None (the default), no additional arguments are passed.

use_svg_cache (bool) – If True (default), the svg inputs (e.g. file_name, settings) will be used as a key and a copy of the created mobject will be saved using that key to be quickly retrieved if the same inputs need be processed later. For large SVGs which are used only once, this can be omitted to improve performance.

kwargs – Further arguments passed to the parent class.

Methods

apply_style_to_mobject

Apply SVG style information to the converted mobject.

ellipse_to_mobject

Convert an ellipse or circle element to a vectorized mobject.

generate_config_style_dict

Generate a dictionary holding the default style information.

generate_mobject

Parse the SVG and translate its elements to submobjects.

get_file_path

Search for an existing file based on the specified file name.

get_mobjects_from

Convert the elements of the SVG to a list of mobjects.

handle_transform

Apply SVG transformations to the converted mobject.

init_svg_mobject

Checks whether the SVG has already been imported and generates it if not.

line_to_mobject

Convert a line element to a vectorized mobject.

modify_xml_tree

Modifies the SVG element tree to include default style information.

move_into_position

Scale and move the generated mobject into position.

path_to_mobject

Convert a path element to a vectorized mobject.

polygon_to_mobject

Convert a polygon element to a vectorized mobject.

polyline_to_mobject

Convert a polyline element to a vectorized mobject.

rect_to_mobject

Convert a rectangle element to a vectorized mobject.

text_to_mobject

Convert a text element to a vectorized mobject.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(file_name=None, should_center=True, height=2, width=None, color=None, opacity=None, fill_color=None, fill_opacity=None, stroke_color=None, stroke_opacity=None, stroke_width=None, svg_default=None, path_string_config=None, use_svg_cache=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
file_name (str | PathLike | None)

should_center (bool)

height (float | None)

width (float | None)

color (str | None)

opacity (float | None)

fill_color (str | None)

fill_opacity (float | None)

stroke_color (str | None)

stroke_opacity (float | None)

stroke_width (float | None)

svg_default (dict | None)

path_string_config (dict | None)

use_svg_cache (bool)

static apply_style_to_mobject(mob, shape)[source]
Apply SVG style information to the converted mobject.

Parameters:
mob (VMobject) – The converted mobject.

shape (GraphicObject) – The parsed SVG element.

Return type:
VMobject

static ellipse_to_mobject(ellipse)[source]
Convert an ellipse or circle element to a vectorized mobject.

Parameters:
ellipse (Ellipse | Circle) – The parsed SVG ellipse or circle.

Return type:
Circle

generate_config_style_dict()[source]
Generate a dictionary holding the default style information.

Return type:
dict[str, str]

generate_mobject()[source]
Parse the SVG and translate its elements to submobjects.

Return type:
None

get_file_path()[source]
Search for an existing file based on the specified file name.

Return type:
Path

get_mobjects_from(svg)[source]
Convert the elements of the SVG to a list of mobjects.

Parameters:
svg (SVG) – The parsed SVG file.

Return type:
list[VMobject]

static handle_transform(mob, matrix)[source]
Apply SVG transformations to the converted mobject.

Parameters:
mob (VMobject) – The converted mobject.

matrix (Matrix) – The transformation matrix determined from the SVG transformation.

Return type:
VMobject

property hash_seed: tuple
A unique hash representing the result of the generated mobject points.

Used as keys in the SVG_HASH_TO_MOB_MAP caching dictionary.

init_svg_mobject(use_svg_cache)[source]
Checks whether the SVG has already been imported and generates it if not.

See also

SVGMobject.generate_mobject()

Parameters:
use_svg_cache (bool)

Return type:
None

static line_to_mobject(line)[source]
Convert a line element to a vectorized mobject.

Parameters:
line (Line) – The parsed SVG line.

Return type:
Line

modify_xml_tree(element_tree)[source]
Modifies the SVG element tree to include default style information.

Parameters:
element_tree (ElementTree) – The parsed element tree from the SVG file.

Return type:
ElementTree

move_into_position()[source]
Scale and move the generated mobject into position.

Return type:
None

path_to_mobject(path)[source]
Convert a path element to a vectorized mobject.

Parameters:
path (Path) – The parsed SVG path.

Return type:
VMobjectFromSVGPath

static polygon_to_mobject(polygon)[source]
Convert a polygon element to a vectorized mobject.

Parameters:
polygon (Polygon) – The parsed SVG polygon.

Return type:
Polygon

polyline_to_mobject(polyline)[source]
Convert a polyline element to a vectorized mobject.

Parameters:
polyline (Polyline) – The parsed SVG polyline.

Return type:
VMobject

static rect_to_mobject(rect)[source]
Convert a rectangle element to a vectorized mobject.

Parameters:
rect (Rect) – The parsed SVG rectangle.

Return type:
Rectangle

static text_to_mobject(text)[source]
Convert a text element to a vectorized mobject.

Warning

Not yet implemented.

Parameters:
text (Text) – The parsed SVG text.

VMobjectFromSVGPath
Qualified name: manim.mobject.svg.svg\_mobject.VMobjectFromSVGPath

class VMobjectFromSVGPath(path_obj, long_lines=False, should_subdivide_sharp_curves=False, should_remove_null_curves=False, **kwargs)[source]
Bases: VMobject

A vectorized mobject representing an SVG path.

Note

The long_lines, should_subdivide_sharp_curves, and should_remove_null_curves keyword arguments are only respected with the OpenGL renderer.

Parameters:
path_obj (se.Path) – A parsed SVG path object.

long_lines (bool) – Whether or not straight lines in the vectorized mobject are drawn in one or two segments.

should_subdivide_sharp_curves (bool) – Whether or not to subdivide subcurves further in case two segments meet at an angle that is sharper than a given threshold.

should_remove_null_curves (bool) – Whether or not to remove subcurves of length 0.

kwargs – Further keyword arguments are passed to the parent class.

Methods

generate_points

Initializes points and therefore the shape.

handle_commands

init_points

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(path_obj, long_lines=False, should_subdivide_sharp_curves=False, should_remove_null_curves=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
path_obj (Path)

long_lines (bool)

should_subdivide_sharp_curves (bool)

should_remove_null_curves (bool)

generate_points()
Initializes points and therefore the shape.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Return type:
None

table
Mobjects representing tables.

Examples

Example: TableExamples 

../_images/TableExamples-1.png
from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")],
            top_left_entry=Text("TOP"))
        t0.add_highlighted_cell((2,2), color=GREEN)
        x_vals = np.linspace(-2,2,5)
        y_vals = np.exp(x_vals)
        t1 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex("x"), MathTex("f(x)")],
            include_outer_lines=True)
        t1.add(t1.get_cell((2,2), color=RED))
        t2 = MathTable(
            [["+", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        t2.get_horizontal_lines()[:3].set_color(BLUE)
        t2.get_vertical_lines()[:3].set_color(BLUE)
        t2.get_horizontal_lines()[:3].set_z_index(1)
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT))
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t3 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]])
        t3.add(Line(
            t3.get_corner(DL), t3.get_corner(UR)
        ).set_color(RED))
        vals = np.arange(1,21).reshape(5,4)
        t4 = IntegerTable(
            vals,
            include_outer_lines=True
        )
        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)
        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)
        self.add(g1, g2)
Make interactive
Classes

DecimalTable

A specialized Table mobject for use with DecimalNumber to display decimal entries.

IntegerTable

A specialized Table mobject for use with Integer.

MathTable

A specialized Table mobject for use with LaTeX.

MobjectTable

A specialized Table mobject for use with Mobject.

Table

A mobject that displays a table on the screen.

DecimalTable
Qualified name: manim.mobject.table.DecimalTable

class DecimalTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)[source]
Bases: Table

A specialized Table mobject for use with DecimalNumber to display decimal entries.

Examples

Example: DecimalTableExample 

../_images/DecimalTableExample-1.png
from manim import *

class DecimalTableExample(Scene):
    def construct(self):
        x_vals = [-2,-1,0,1,2]
        y_vals = np.exp(x_vals)
        t0 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex("x"), MathTex("f(x)=e^{x}")],
            h_buff=1,
            element_to_mobject_config={"num_decimal_places": 2})
        self.add(t0)
Make interactive
Special case of Table with element_to_mobject set to DecimalNumber. By default, num_decimal_places is set to 1. Will round/truncate the decimal places based on the provided element_to_mobject_config.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2D array, or a list of lists. Content of the table must be valid input for DecimalNumber.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as DecimalNumber.

element_to_mobject_config (dict) – Element to mobject config, here set as {“num_decimal_places”: 1}.

kwargs – Additional arguments to be passed to Table.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(table, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)
Special case of Table with element_to_mobject set to DecimalNumber. By default, num_decimal_places is set to 1. Will round/truncate the decimal places based on the provided element_to_mobject_config.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2D array, or a list of lists. Content of the table must be valid input for DecimalNumber.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as DecimalNumber.

element_to_mobject_config (dict) – Element to mobject config, here set as {“num_decimal_places”: 1}.

kwargs – Additional arguments to be passed to Table.

IntegerTable
Qualified name: manim.mobject.table.IntegerTable

class IntegerTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)[source]
Bases: Table

A specialized Table mobject for use with Integer.

Examples

Example: IntegerTableExample 

../_images/IntegerTableExample-1.png
from manim import *

class IntegerTableExample(Scene):
    def construct(self):
        t0 = IntegerTable(
            [[0,30,45,60,90],
            [90,60,45,30,0]],
            col_labels=[
                MathTex("\\frac{\sqrt{0}}{2}"),
                MathTex("\\frac{\sqrt{1}}{2}"),
                MathTex("\\frac{\sqrt{2}}{2}"),
                MathTex("\\frac{\sqrt{3}}{2}"),
                MathTex("\\frac{\sqrt{4}}{2}")],
            row_labels=[MathTex("\sin"), MathTex("\cos")],
            h_buff=1,
            element_to_mobject_config={"unit": "^{\circ}"})
        self.add(t0)
Make interactive
Special case of Table with element_to_mobject set to Integer. Will round if there are decimal entries in the table.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2d array or list of lists. Content of the table has to be valid input for Integer.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as Integer.

kwargs – Additional arguments to be passed to Table.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(table, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)
Special case of Table with element_to_mobject set to Integer. Will round if there are decimal entries in the table.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2d array or list of lists. Content of the table has to be valid input for Integer.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as Integer.

kwargs – Additional arguments to be passed to Table.

MathTable
Qualified name: manim.mobject.table.MathTable

class MathTable(table, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, **kwargs)[source]
Bases: Table

A specialized Table mobject for use with LaTeX.

Examples

Example: MathTableExample 

../_images/MathTableExample-1.png
from manim import *

class MathTableExample(Scene):
    def construct(self):
        t0 = MathTable(
            [["+", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        self.add(t0)
Make interactive
Special case of Table with element_to_mobject set to MathTex. Every entry in table is set in a Latex align environment.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2d array or list of lists. Content of the table have to be valid input for MathTex.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as MathTex.

kwargs – Additional arguments to be passed to Table.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(table, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, **kwargs)
Special case of Table with element_to_mobject set to MathTex. Every entry in table is set in a Latex align environment.

Parameters:
table (Iterable[Iterable[float | str]]) – A 2d array or list of lists. Content of the table have to be valid input for MathTex.

element_to_mobject (Callable[[float | str], VMobject]) – The Mobject class applied to the table entries. Set as MathTex.

kwargs – Additional arguments to be passed to Table.

MobjectTable
Qualified name: manim.mobject.table.MobjectTable

class MobjectTable(table, element_to_mobject=<function MobjectTable.<lambda>>, **kwargs)[source]
Bases: Table

A specialized Table mobject for use with Mobject.

Examples

Example: MobjectTableExample 

../_images/MobjectTableExample-1.png
from manim import *

class MobjectTableExample(Scene):
    def construct(self):
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT),
        )
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t0 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]]
        )
        line = Line(
            t0.get_corner(DL), t0.get_corner(UR)
        ).set_color(RED)
        self.add(t0, line)
Make interactive
Special case of Table with element_to_mobject set to an identity function. Here, every item in table must already be of type Mobject.

Parameters:
table (Iterable[Iterable[VMobject]]) – A 2D array or list of lists. Content of the table must be of type Mobject.

element_to_mobject (Callable[[VMobject], VMobject]) – The Mobject class applied to the table entries. Set as lambda m : m to return itself.

kwargs – Additional arguments to be passed to Table.

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(table, element_to_mobject=<function MobjectTable.<lambda>>, **kwargs)
Special case of Table with element_to_mobject set to an identity function. Here, every item in table must already be of type Mobject.

Parameters:
table (Iterable[Iterable[VMobject]]) – A 2D array or list of lists. Content of the table must be of type Mobject.

element_to_mobject (Callable[[VMobject], VMobject]) – The Mobject class applied to the table entries. Set as lambda m : m to return itself.

kwargs – Additional arguments to be passed to Table.

Table
Qualified name: manim.mobject.table.Table

class Table(table, row_labels=None, col_labels=None, top_left_entry=None, v_buff=0.8, h_buff=1.3, include_outer_lines=False, add_background_rectangles_to_entries=False, entries_background_color=ManimColor('#000000'), include_background_rectangle=False, background_rectangle_color=ManimColor('#000000'), element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'>, element_to_mobject_config={}, arrange_in_grid_config={}, line_config={}, **kwargs)[source]
Bases: VGroup

A mobject that displays a table on the screen.

Parameters:
table (Iterable[Iterable[float | str | VMobject]]) – A 2D array or list of lists. Content of the table has to be a valid input for the callable set in element_to_mobject.

row_labels (Iterable[VMobject] | None) – List of VMobject representing the labels of each row.

col_labels (Iterable[VMobject] | None) – List of VMobject representing the labels of each column.

top_left_entry (VMobject | None) – The top-left entry of the table, can only be specified if row and column labels are given.

v_buff (float) – Vertical buffer passed to arrange_in_grid(), by default 0.8.

h_buff (float) – Horizontal buffer passed to arrange_in_grid(), by default 1.3.

include_outer_lines (bool) – True if the table should include outer lines, by default False.

add_background_rectangles_to_entries (bool) – True if background rectangles should be added to entries, by default False.

entries_background_color (ParsableManimColor) – Background color of entries if add_background_rectangles_to_entries is True.

include_background_rectangle (bool) – True if the table should have a background rectangle, by default False.

background_rectangle_color (ParsableManimColor) – Background color of table if include_background_rectangle is True.

element_to_mobject (Callable[[float | str | VMobject], VMobject]) – The Mobject class applied to the table entries. by default Paragraph. For common choices, see text_mobject/tex_mobject.

element_to_mobject_config (dict) – Custom configuration passed to element_to_mobject, by default {}.

arrange_in_grid_config (dict) – Dict passed to arrange_in_grid(), customizes the arrangement of the table.

line_config (dict) – Dict passed to Line, customizes the lines of the table.

kwargs – Additional arguments to be passed to VGroup.

Examples

Example: TableExamples 

../_images/TableExamples-2.png
from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [["This", "is a"],
            ["simple", "Table in \n Manim."]])
        t1 = Table(
            [["This", "is a"],
            ["simple", "Table."]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        t1.add_highlighted_cell((2,2), color=YELLOW)
        t2 = Table(
            [["This", "is a"],
            ["simple", "Table."]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            arrange_in_grid_config={"cell_alignment": RIGHT})
        t2.add(t2.get_cell((2,2), color=RED))
        t3 = Table(
            [["This", "is a"],
            ["simple", "Table."]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            line_config={"stroke_width": 1, "color": YELLOW})
        t3.remove(*t3.get_vertical_lines())
        g = Group(
            t0,t1,t2,t3
        ).scale(0.7).arrange_in_grid(buff=1)
        self.add(g)
Make interactive
Example: BackgroundRectanglesExample 

../_images/BackgroundRectanglesExample-2.png
from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background = Rectangle(height=6.5, width=13)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        t0 = Table(
            [["This", "is a"],
            ["simple", "Table."]],
            add_background_rectangles_to_entries=True)
        t1 = Table(
            [["This", "is a"],
            ["simple", "Table."]],
            include_background_rectangle=True)
        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)
        self.add(g)
Make interactive
Methods

add_background_to_entries

Adds a black BackgroundRectangle to each entry of the table.

add_highlighted_cell

Highlights one cell at a specific position on the table by adding a BackgroundRectangle.

create

Customized create-type function for tables.

get_cell

Returns one specific cell as a rectangular Polygon without the entry.

get_col_labels

Return the column labels of the table.

get_columns

Return columns of the table as a VGroup of VGroup.

get_entries

Return the individual entries of the table (including labels) or one specific entry if the parameter, pos, is set.

get_entries_without_labels

Return the individual entries of the table (without labels) or one specific entry if the parameter, pos, is set.

get_highlighted_cell

Returns a BackgroundRectangle of the cell at the given position.

get_horizontal_lines

Return the horizontal lines of the table.

get_labels

Returns the labels of the table.

get_row_labels

Return the row labels of the table.

get_rows

Return the rows of the table as a VGroup of VGroup.

get_vertical_lines

Return the vertical lines of the table.

scale

Scale the size by a factor.

set_column_colors

Set individual colors for each column of the table.

set_row_colors

Set individual colors for each row of the table.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_add_horizontal_lines()[source]
Adds the horizontal lines to the table.

Return type:
Table

_add_labels(mob_table)[source]
Adds labels to an in a grid arranged VGroup.

Parameters:
mob_table (VGroup) – An in a grid organized class:~.VGroup.

Returns:
Returns the mob_table with added labels.

Return type:
VGroup

_add_vertical_lines()[source]
Adds the vertical lines to the table

Return type:
Table

_organize_mob_table(table)[source]
Arranges the VMobject of table in a grid.

Parameters:
table (Iterable[Iterable[VMobject]]) – A 2D iterable object with VMobject entries.

Returns:
The VMobject of the table in a VGroup already arranged in a table-like grid.

Return type:
VGroup

_original__init__(table, row_labels=None, col_labels=None, top_left_entry=None, v_buff=0.8, h_buff=1.3, include_outer_lines=False, add_background_rectangles_to_entries=False, entries_background_color=ManimColor('#000000'), include_background_rectangle=False, background_rectangle_color=ManimColor('#000000'), element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'>, element_to_mobject_config={}, arrange_in_grid_config={}, line_config={}, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
table (Iterable[Iterable[float | str | VMobject]])

row_labels (Iterable[VMobject] | None)

col_labels (Iterable[VMobject] | None)

top_left_entry (VMobject | None)

v_buff (float)

h_buff (float)

include_outer_lines (bool)

add_background_rectangles_to_entries (bool)

entries_background_color (ParsableManimColor)

include_background_rectangle (bool)

background_rectangle_color (ParsableManimColor)

element_to_mobject (Callable[[float | str | VMobject], VMobject])

element_to_mobject_config (dict)

arrange_in_grid_config (dict)

line_config (dict)

_table_to_mob_table(table)[source]
Initilaizes the entries of table as VMobject.

Parameters:
table (Iterable[Iterable[float | str | VMobject]]) – A 2D array or list of lists. Content of the table has to be a valid input for the callable set in element_to_mobject.

Returns:
List of VMobject from the entries of table.

Return type:
List

add_background_to_entries(color=ManimColor('#000000'))[source]
Adds a black BackgroundRectangle to each entry of the table.

Parameters:
color (ParsableManimColor)

Return type:
Table

add_highlighted_cell(pos=(1, 1), color=ManimColor('#FFFF00'), **kwargs)[source]
Highlights one cell at a specific position on the table by adding a BackgroundRectangle.

Parameters:
pos (Sequence[int]) – The position of a specific entry on the table. (1,1) being the top left entry of the table.

color (ParsableManimColor) – The color used to highlight the cell.

kwargs – Additional arguments to be passed to BackgroundRectangle.

Return type:
Table

Examples

Example: AddHighlightedCellExample 

../_images/AddHighlightedCellExample-1.png
from manim import *

class AddHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        table.add_highlighted_cell((2,2), color=GREEN)
        self.add(table)
Make interactive
create(lag_ratio=1, line_animation=<class 'manim.animation.creation.Create'>, label_animation=<class 'manim.animation.creation.Write'>, element_animation=<class 'manim.animation.creation.Create'>, entry_animation=<class 'manim.animation.fading.FadeIn'>, **kwargs)[source]
Customized create-type function for tables.

Parameters:
lag_ratio (float) – The lag ratio of the animation.

line_animation (Callable[[VMobject | VGroup], Animation]) – The animation style of the table lines, see creation for examples.

label_animation (Callable[[VMobject | VGroup], Animation]) – The animation style of the table labels, see creation for examples.

element_animation (Callable[[VMobject | VGroup], Animation]) – The animation style of the table elements, see creation for examples.

entry_animation (Callable[[VMobject | VGroup], Animation]) – The entry animation of the table background, see creation for examples.

kwargs – Further arguments passed to the creation animations.

Returns:
AnimationGroup containing creation of the lines and of the elements.

Return type:
AnimationGroup

Examples

Example: CreateTableExample 

from manim import *

class CreateTableExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")],
            include_outer_lines=True)
        self.play(table.create())
        self.wait()
Make interactive
get_cell(pos=(1, 1), **kwargs)[source]
Returns one specific cell as a rectangular Polygon without the entry.

Parameters:
pos (Sequence[int]) – The position of a specific entry on the table. (1,1) being the top left entry of the table.

kwargs – Additional arguments to be passed to Polygon.

Returns:
Polygon mimicking one specific cell of the Table.

Return type:
Polygon

Examples

Example: GetCellExample 

../_images/GetCellExample-1.png
from manim import *

class GetCellExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        cell = table.get_cell((2,2), color=RED)
        self.add(table, cell)
Make interactive
get_col_labels()[source]
Return the column labels of the table.

Returns:
VGroup containing the column labels of the table.

Return type:
VGroup

Examples

Example: GetColLabelsExample 

../_images/GetColLabelsExample-1.png
from manim import *

class GetColLabelsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        lab = table.get_col_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)
Make interactive
get_columns()[source]
Return columns of the table as a VGroup of VGroup.

Returns:
VGroup containing each column in a VGroup.

Return type:
VGroup

Examples

Example: GetColumnsExample 

../_images/GetColumnsExample-2.png
from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        table.add(SurroundingRectangle(table.get_columns()[1]))
        self.add(table)
Make interactive
get_entries(pos=None)[source]
Return the individual entries of the table (including labels) or one specific entry if the parameter, pos, is set.

Parameters:
pos (Sequence[int] | None) – The position of a specific entry on the table. (1,1) being the top left entry of the table.

Returns:
VGroup containing all entries of the table (including labels) or the VMobject at the given position if pos is set.

Return type:
Union[VMobject, VGroup]

Examples

Example: GetEntriesExample 

../_images/GetEntriesExample-2.png
from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        ent = table.get_entries()
        for item in ent:
            item.set_color(random_bright_color())
        table.get_entries((2,2)).rotate(PI)
        self.add(table)
Make interactive
get_entries_without_labels(pos=None)[source]
Return the individual entries of the table (without labels) or one specific entry if the parameter, pos, is set.

Parameters:
pos (Sequence[int] | None) – The position of a specific entry on the table. (1,1) being the top left entry of the table (without labels).

Returns:
VGroup containing all entries of the table (without labels) or the VMobject at the given position if pos is set.

Return type:
Union[VMobject, VGroup]

Examples

Example: GetEntriesWithoutLabelsExample 

../_images/GetEntriesWithoutLabelsExample-1.png
from manim import *

class GetEntriesWithoutLabelsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        ent = table.get_entries_without_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        table.get_entries_without_labels((2,2)).rotate(PI)
        self.add(table)
Make interactive
get_highlighted_cell(pos=(1, 1), color=ManimColor('#FFFF00'), **kwargs)[source]
Returns a BackgroundRectangle of the cell at the given position.

Parameters:
pos (Sequence[int]) – The position of a specific entry on the table. (1,1) being the top left entry of the table.

color (ParsableManimColor) – The color used to highlight the cell.

kwargs – Additional arguments to be passed to BackgroundRectangle.

Return type:
BackgroundRectangle

Examples

Example: GetHighlightedCellExample 

../_images/GetHighlightedCellExample-1.png
from manim import *

class GetHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        highlight = table.get_highlighted_cell((2,2), color=GREEN)
        table.add_to_back(highlight)
        self.add(table)
Make interactive
get_horizontal_lines()[source]
Return the horizontal lines of the table.

Returns:
VGroup containing all the horizontal lines of the table.

Return type:
VGroup

Examples

Example: GetHorizontalLinesExample 

../_images/GetHorizontalLinesExample-1.png
from manim import *

class GetHorizontalLinesExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        table.get_horizontal_lines().set_color(RED)
        self.add(table)
Make interactive
get_labels()[source]
Returns the labels of the table.

Returns:
VGroup containing all the labels of the table.

Return type:
VGroup

Examples

Example: GetLabelsExample 

../_images/GetLabelsExample-1.png
from manim import *

class GetLabelsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        lab = table.get_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            lab[k].set_color(colors[k])
        self.add(table)
Make interactive
get_row_labels()[source]
Return the row labels of the table.

Returns:
VGroup containing the row labels of the table.

Return type:
VGroup

Examples

Example: GetRowLabelsExample 

../_images/GetRowLabelsExample-1.png
from manim import *

class GetRowLabelsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        lab = table.get_row_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)
Make interactive
get_rows()[source]
Return the rows of the table as a VGroup of VGroup.

Returns:
VGroup containing each row in a VGroup.

Return type:
VGroup

Examples

Example: GetRowsExample 

../_images/GetRowsExample-2.png
from manim import *

class GetRowsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        table.add(SurroundingRectangle(table.get_rows()[1]))
        self.add(table)
Make interactive
get_vertical_lines()[source]
Return the vertical lines of the table.

Returns:
VGroup containing all the vertical lines of the table.

Return type:
VGroup

Examples

Example: GetVerticalLinesExample 

../_images/GetVerticalLinesExample-1.png
from manim import *

class GetVerticalLinesExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")])
        table.get_vertical_lines()[0].set_color(RED)
        self.add(table)
Make interactive
scale(scale_factor, **kwargs)[source]
Scale the size by a factor.

Default behavior is to scale about the center of the mobject.

Parameters:
scale_factor (float) – The scaling factor 
. If 
, the mobject will shrink, and for 
 it will grow. Furthermore, if 
, the mobject is also flipped.

kwargs – Additional keyword arguments passed to apply_points_function_about_point().

Returns:
self

Return type:
Mobject

Examples

Example: MobjectScaleExample 

../_images/MobjectScaleExample-2.png
from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        f1 = Text("F")
        f2 = Text("F").scale(2)
        f3 = Text("F").scale(0.5)
        f4 = Text("F").scale(-1)

        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
        self.add(vgroup)
Make interactive
See also

move_to()

set_column_colors(*colors)[source]
Set individual colors for each column of the table.

Parameters:
colors (Iterable[ParsableManimColor]) – An iterable of colors; each color corresponds to a column.

Return type:
Table

Examples

Example: SetColumnColorsExample 

../_images/SetColumnColorsExample-2.png
from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")]
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(table)
Make interactive
set_row_colors(*colors)[source]
Set individual colors for each row of the table.

Parameters:
colors (Iterable[ParsableManimColor]) – An iterable of colors; each color corresponds to a row.

Return type:
Table

Examples

Example: SetRowColorsExample 

../_images/SetRowColorsExample-2.png
from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        table = Table(
            [["First", "Second"],
            ["Third","Fourth"]],
            row_labels=[Text("R1"), Text("R2")],
            col_labels=[Text("C1"), Text("C2")]
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(table)
Make interactive

text
Mobjects used to display Text using Pango or LaTeX.

Modules
code_mobject

Mobject representing highlighted source code listings.

numbers

Mobjects representing numbers.

tex_mobject

Mobjects representing text rendered using LaTeX.

text_mobject

Mobjects used for displaying (non-LaTeX) text.

code_mobject
Mobject representing highlighted source code listings.

Classes

Code

A highlighted source code listing.

Code
Qualified name: manim.mobject.text.code\_mobject.Code

class Code(file_name=None, code=None, tab_width=3, line_spacing=0.3, font_size=24, font='Monospace', stroke_width=0, margin=0.3, indentation_chars='    ', background='rectangle', background_stroke_width=1, background_stroke_color=ManimColor('#FFFFFF'), corner_radius=0.2, insert_line_no=True, line_no_from=1, line_no_buff=0.4, style='vim', language=None, generate_html_file=False, warn_missing_font=True, **kwargs)[source]
Bases: VGroup

A highlighted source code listing.

An object listing of Code is a VGroup consisting of three objects:

The background, listing.background_mobject. This is either a Rectangle (if the listing has been initialized with background="rectangle", the default option) or a VGroup resembling a window (if background="window" has been passed).

The line numbers, listing.line_numbers (a Paragraph object).

The highlighted code itself, listing.code (a Paragraph object).

Warning

Using a Transform on text with leading whitespace (and in this particular case: code) can look weird. Consider using remove_invisible_chars() to resolve this issue.

Examples

Normal usage:

listing = Code(
    "helloworldcpp.cpp",
    tab_width=4,
    background_stroke_width=1,
    background_stroke_color=WHITE,
    insert_line_no=True,
    style=Code.styles_list[15],
    background="window",
    language="cpp",
)
We can also render code passed as a string (but note that the language has to be specified in this case):

Example: CodeFromString 

../_images/CodeFromString-1.png
from manim import *

class CodeFromString(Scene):
    def construct(self):
        code = '''from manim import Scene, Square

class FadeInSquare(Scene):
    def construct(self):
        s = Square()
        self.play(FadeIn(s))
        self.play(s.animate.scale(2))
        self.wait()
'''
        rendered_code = Code(code=code, tab_width=4, background="window",
                            language="Python", font="Monospace")
        self.add(rendered_code)
Make interactive
Parameters:
file_name (str | os.PathLike | None) – Name of the code file to display.

code (str | None) – If file_name is not specified, a code string can be passed directly.

tab_width (int) – Number of space characters corresponding to a tab character. Defaults to 3.

line_spacing (float) – Amount of space between lines in relation to font size. Defaults to 0.3, which means 30% of font size.

font_size (float) – A number which scales displayed code. Defaults to 24.

font (str) – The name of the text font to be used. Defaults to "Monospace". This is either a system font or one loaded with text.register_font(). Note that font family names may be different across operating systems.

stroke_width (float) – Stroke width for text. 0 is recommended, and the default.

margin (float) – Inner margin of text from the background. Defaults to 0.3.

indentation_chars (str) – “Indentation chars” refers to the spaces/tabs at the beginning of a given code line. Defaults to "    " (spaces).

background (str) – Defines the background’s type. Currently supports only "rectangle" (default) and "window".

background_stroke_width (float) – Defines the stroke width of the background. Defaults to 1.

background_stroke_color (str) – Defines the stroke color for the background. Defaults to WHITE.

corner_radius (float) – Defines the corner radius for the background. Defaults to 0.2.

insert_line_no (bool) – Defines whether line numbers should be inserted in displayed code. Defaults to True.

line_no_from (int) – Defines the first line’s number in the line count. Defaults to 1.

line_no_buff (float) – Defines the spacing between line numbers and displayed code. Defaults to 0.4.

style (str) – Defines the style type of displayed code. You can see possible names of styles in with styles_list. Defaults to "vim".

language (str | None) – Specifies the programming language the given code was written in. If None (the default), the language will be automatically detected. For the list of possible options, visit https://pygments.org/docs/lexers/ and look for ‘aliases or short names’.

generate_html_file (bool) – Defines whether to generate highlighted html code to the folder assets/codes/generated_html_files. Defaults to False.

warn_missing_font (bool) – If True (default), Manim will issue a warning if the font does not exist in the (case-sensitive) list of fonts returned from manimpango.list_fonts().

background_mobject
The background of the code listing.

Type:
VGroup

line_numbers
The line numbers for the code listing. Empty, if insert_line_no=False has been specified.

Type:
Paragraph

code
The highlighted code.

Type:
Paragraph

Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

styles_list

width

The width of the mobject.

_correct_non_span(line_str)[source]
Function put text color to those strings that don’t have one according to background_color of displayed code.

Parameters:
line_str (str) – Takes a html element’s string to put color to it according to background_color of displayed code.

Returns:
The generated html element’s string with having color attributes.

Return type:
str

_ensure_valid_file()[source]
Function to validate file.

_gen_code_json()[source]
Function to background_color, generate code_json and tab_spaces from html_string. background_color is just background color of displayed code. code_json is 2d array with rows as line numbers and columns as a array with length 2 having text and text’s color value. tab_spaces is 2d array with rows as line numbers and columns as corresponding number of indentation_chars in front of that line in code.

_gen_colored_lines()[source]
Function to generate code.

Returns:
The generated code according to parameters.

Return type:
Paragraph

_gen_html_string()[source]
Function to generate html string with code highlighted and stores in variable html_string.

_gen_line_numbers()[source]
Function to generate line_numbers.

Returns:
The generated line_numbers according to parameters.

Return type:
Paragraph

_original__init__(file_name=None, code=None, tab_width=3, line_spacing=0.3, font_size=24, font='Monospace', stroke_width=0, margin=0.3, indentation_chars='    ', background='rectangle', background_stroke_width=1, background_stroke_color=ManimColor('#FFFFFF'), corner_radius=0.2, insert_line_no=True, line_no_from=1, line_no_buff=0.4, style='vim', language=None, generate_html_file=False, warn_missing_font=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
file_name (str | PathLike | None)

code (str | None)

tab_width (int)

line_spacing (float)

font_size (float)

font (str)

stroke_width (float)

margin (float)

indentation_chars (str)

background (str)

background_stroke_width (float)

background_stroke_color (str)

corner_radius (float)

insert_line_no (bool)

line_no_from (int)

line_no_buff (float)

style (str)

language (str | None)

generate_html_file (bool)

warn_missing_font (bool)

numbers
Mobjects representing numbers.

Classes

DecimalNumber

An mobject representing a decimal number.

Integer

A class for displaying Integers.

Variable

A class for displaying text that shows "label = value" with the value continuously updated from a ValueTracker.

DecimalNumber
Qualified name: manim.mobject.text.numbers.DecimalNumber

class DecimalNumber(number=0, num_decimal_places=2, mob_class=<class 'manim.mobject.text.tex_mobject.MathTex'>, include_sign=False, group_with_commas=True, digit_buff_per_font_unit=0.001, show_ellipsis=False, unit=None, unit_buff_per_font_unit=0, include_background_rectangle=False, edge_to_fix=array([-1., 0., 0.]), font_size=48, stroke_width=0, fill_opacity=1.0, **kwargs)[source]
Bases: VMobject

An mobject representing a decimal number.

Parameters:
number (float) – The numeric value to be displayed. It can later be modified using set_value().

num_decimal_places (int) – The number of decimal places after the decimal separator. Values are automatically rounded.

mob_class (VMobject) – The class for rendering digits and units, by default MathTex.

include_sign (bool) – Set to True to include a sign for positive numbers and zero.

group_with_commas (bool) – When True thousands groups are separated by commas for readability.

digit_buff_per_font_unit (float) – Additional spacing between digits. Scales with font size.

show_ellipsis (bool) – When a number has been truncated by rounding, indicate with an ellipsis (...).

unit (str | None) – A unit string which can be placed to the right of the numerical values.

unit_buff_per_font_unit (float) – An additional spacing between the numerical values and the unit. A value of unit_buff_per_font_unit=0.003 gives a decent spacing. Scales with font size.

include_background_rectangle (bool) – Adds a background rectangle to increase contrast on busy scenes.

edge_to_fix (Sequence[float]) – Assuring right- or left-alignment of the full object.

font_size (float) – Size of the font.

stroke_width (float)

fill_opacity (float)

Examples

Example: MovingSquareWithUpdaters 

from manim import *

class MovingSquareWithUpdaters(Scene):
    def construct(self):
        decimal = DecimalNumber(
            0,
            show_ellipsis=True,
            num_decimal_places=3,
            include_sign=True,
            unit=r"     ext{M-Units}",
            unit_buff_per_font_unit=0.003
        )
        square = Square().to_edge(UP)

        decimal.add_updater(lambda d: d.next_to(square, RIGHT))
        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))
        self.add(square, decimal)
        self.play(
            square.animate.to_edge(DOWN),
            rate_func=there_and_back,
            run_time=5,
        )
        self.wait()
Make interactive
Methods

get_value

increment_value

set_value

Set the value of the DecimalNumber to a new number.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_get_formatter(**kwargs)[source]
Configuration is based first off instance attributes, but overwritten by any kew word argument. Relevant key words: - include_sign - group_with_commas - num_decimal_places - field_name (e.g. 0 or 0.real)

_original__init__(number=0, num_decimal_places=2, mob_class=<class 'manim.mobject.text.tex_mobject.MathTex'>, include_sign=False, group_with_commas=True, digit_buff_per_font_unit=0.001, show_ellipsis=False, unit=None, unit_buff_per_font_unit=0, include_background_rectangle=False, edge_to_fix=array([-1., 0., 0.]), font_size=48, stroke_width=0, fill_opacity=1.0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
number (float)

num_decimal_places (int)

mob_class (VMobject)

include_sign (bool)

group_with_commas (bool)

digit_buff_per_font_unit (float)

show_ellipsis (bool)

unit (str | None)

unit_buff_per_font_unit (float)

include_background_rectangle (bool)

edge_to_fix (Sequence[float])

font_size (float)

stroke_width (float)

fill_opacity (float)

property font_size
The font size of the tex mobject.

set_value(number)[source]
Set the value of the DecimalNumber to a new number.

Parameters:
number (float) – The value that will overwrite the current number of the DecimalNumber.

Integer
Qualified name: manim.mobject.text.numbers.Integer

class Integer(number=0, num_decimal_places=0, **kwargs)[source]
Bases: DecimalNumber

A class for displaying Integers.

Examples

Example: IntegerExample 

../_images/IntegerExample-1.png
from manim import *

class IntegerExample(Scene):
    def construct(self):
        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))
        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))
        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))
        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))
Make interactive
Methods

get_value

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(number=0, num_decimal_places=0, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Variable
Qualified name: manim.mobject.text.numbers.Variable

class Variable(var, label, var_type=<class 'manim.mobject.text.numbers.DecimalNumber'>, num_decimal_places=2, **kwargs)[source]
Bases: VMobject

A class for displaying text that shows “label = value” with the value continuously updated from a ValueTracker.

Parameters:
var (float) – The initial value you need to keep track of and display.

label (str | Tex | MathTex | Text | SingleStringMathTex) – The label for your variable. Raw strings are convertex to MathTex objects.

var_type (DecimalNumber | Integer) – The class used for displaying the number. Defaults to DecimalNumber.

num_decimal_places (int) – The number of decimal places to display in your variable. Defaults to 2. If var_type is an Integer, this parameter is ignored.

kwargs – Other arguments to be passed to ~.Mobject.

label
The label for your variable, for example x = ....

Type:
Union[str, Tex, MathTex, Text, SingleStringMathTex]

tracker
Useful in updating the value of your variable on-screen.

Type:
ValueTracker

value
The tex for the value of your variable.

Type:
Union[DecimalNumber, Integer]

Examples

Normal usage:

# DecimalNumber type
var = 0.5
on_screen_var = Variable(var, Text("var"), num_decimal_places=3)
# Integer type
int_var = 0
on_screen_int_var = Variable(int_var, Text("int_var"), var_type=Integer)
# Using math mode for the label
on_screen_int_var = Variable(int_var, "{a}_{i}", var_type=Integer)
Example: VariablesWithValueTracker 

from manim import *

class VariablesWithValueTracker(Scene):
    def construct(self):
        var = 0.5
        on_screen_var = Variable(var, Text("var"), num_decimal_places=3)

        # You can also change the colours for the label and value
        on_screen_var.label.set_color(RED)
        on_screen_var.value.set_color(GREEN)

        self.play(Write(on_screen_var))
        # The above line will just display the variable with
        # its initial value on the screen. If you also wish to
        # update it, you can do so by accessing the `tracker` attribute
        self.wait()
        var_tracker = on_screen_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        int_var = 0
        on_screen_int_var = Variable(
            int_var, Text("int_var"), var_type=Integer
        ).next_to(on_screen_var, DOWN)
        on_screen_int_var.label.set_color(RED)
        on_screen_int_var.value.set_color(GREEN)

        self.play(Write(on_screen_int_var))
        self.wait()
        var_tracker = on_screen_int_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        # If you wish to have a somewhat more complicated label for your
        # variable with subscripts, superscripts, etc. the default class
        # for the label is MathTex
        subscript_label_var = 10
        on_screen_subscript_var = Variable(subscript_label_var, "{a}_{i}").next_to(
            on_screen_int_var, DOWN
        )
        self.play(Write(on_screen_subscript_var))
        self.wait()
Make interactive
Example: VariableExample 

from manim import *

class VariableExample(Scene):
    def construct(self):
        start = 2.0

        x_var = Variable(start, 'x', num_decimal_places=3)
        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)
        Group(x_var, sqr_var).arrange(DOWN)

        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))

        self.add(x_var, sqr_var)
        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)
        self.wait(0.1)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(var, label, var_type=<class 'manim.mobject.text.numbers.DecimalNumber'>, num_decimal_places=2, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
var (float)

label (str | Tex | MathTex | Text | SingleStringMathTex)

var_type (DecimalNumber | Integer)

num_decimal_places (int)

tex_mobject
Mobjects representing text rendered using LaTeX.

Important

See the corresponding tutorial Text With LaTeX

Note

Just as you can use Text (from the module text_mobject) to add text to your videos, you can use Tex and MathTex to insert LaTeX.

Classes

BulletedList

A bulleted list.

MathTex

A string compiled with LaTeX in math mode.

SingleStringMathTex

Elementary building block for rendering text with LaTeX.

Tex

A string compiled with LaTeX in normal mode.

Title

A mobject representing an underlined title.

BulletedList
Qualified name: manim.mobject.text.tex\_mobject.BulletedList

class BulletedList(*items, buff=0.5, dot_scale_factor=2, tex_environment=None, **kwargs)[source]
Bases: Tex

A bulleted list.

Examples

Example: BulletedListExample 

../_images/BulletedListExample-1.png
from manim import *

class BulletedListExample(Scene):
    def construct(self):
        blist = BulletedList("Item 1", "Item 2", "Item 3", height=2, width=2)
        blist.set_color_by_tex("Item 1", RED)
        blist.set_color_by_tex("Item 2", GREEN)
        blist.set_color_by_tex("Item 3", BLUE)
        self.add(blist)
Make interactive
Methods

fade_all_but

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*items, buff=0.5, dot_scale_factor=2, tex_environment=None, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

MathTex
Qualified name: manim.mobject.text.tex\_mobject.MathTex

class MathTex(*tex_strings, arg_separator=' ', substrings_to_isolate=None, tex_to_color_map=None, tex_environment='align*', **kwargs)[source]
Bases: SingleStringMathTex

A string compiled with LaTeX in math mode.

Examples

Example: Formula 

../_images/Formula-1.png
from manim import *

class Formula(Scene):
    def construct(self):
        t = MathTex(r"\int_a^b f'(x) dx = f(b)- f(a)")
        self.add(t)
Make interactive
Tests

Check that creating a MathTex works:

MathTex('a^2 + b^2 = c^2') 
MathTex('a^2 + b^2 = c^2')
Check that double brace group splitting works correctly:

t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') 
len(t1.submobjects) 
5
t2 = MathTex(r"\frac{1}{a+b\sqrt{2}}") 
len(t2.submobjects) 
1
Methods

get_part_by_tex

get_parts_by_tex

index_of_part

index_of_part_by_tex

set_color_by_tex

set_color_by_tex_to_color_map

set_opacity_by_tex

Sets the opacity of the tex specified.

sort_alphabetically

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
arg_separator (str)

substrings_to_isolate (Iterable[str] | None)

tex_to_color_map (dict[str, ManimColor])

tex_environment (str)

_break_up_by_substrings()[source]
Reorganize existing submobjects one layer deeper based on the structure of tex_strings (as a list of tex_strings)

_original__init__(*tex_strings, arg_separator=' ', substrings_to_isolate=None, tex_to_color_map=None, tex_environment='align*', **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
arg_separator (str)

substrings_to_isolate (Iterable[str] | None)

tex_to_color_map (dict[str, ManimColor])

tex_environment (str)

set_opacity_by_tex(tex, opacity=0.5, remaining_opacity=None, **kwargs)[source]
Sets the opacity of the tex specified. If ‘remaining_opacity’ is specified, then the remaining tex will be set to that opacity.

Parameters:
tex (str) – The tex to set the opacity of.

opacity (float) – Default 0.5. The opacity to set the tex to

remaining_opacity (float) – Default None. The opacity to set the remaining tex to. If None, then the remaining tex will not be changed

SingleStringMathTex
Qualified name: manim.mobject.text.tex\_mobject.SingleStringMathTex

class SingleStringMathTex(tex_string, stroke_width=0, should_center=True, height=None, organize_left_to_right=False, tex_environment='align*', tex_template=None, font_size=48, **kwargs)[source]
Bases: SVGMobject

Elementary building block for rendering text with LaTeX.

Tests

Check that creating a SingleStringMathTex object works:

SingleStringMathTex('Test') 
SingleStringMathTex('Test')
Methods

get_tex_string

init_colors

Initializes the colors.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
tex_string (str)

stroke_width (float)

should_center (bool)

height (float | None)

organize_left_to_right (bool)

tex_environment (str)

tex_template (TexTemplate | None)

font_size (float)

_original__init__(tex_string, stroke_width=0, should_center=True, height=None, organize_left_to_right=False, tex_environment='align*', tex_template=None, font_size=48, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
tex_string (str)

stroke_width (float)

should_center (bool)

height (float | None)

organize_left_to_right (bool)

tex_environment (str)

tex_template (TexTemplate | None)

font_size (float)

_remove_stray_braces(tex)[source]
Makes MathTex resilient to unmatched braces.

This is important when the braces in the TeX code are spread over multiple arguments as in, e.g., MathTex(r"e^{i", r"\tau} = 1").

property font_size
The font size of the tex mobject.

init_colors(propagate_colors=True)[source]
Initializes the colors.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Tex
Qualified name: manim.mobject.text.tex\_mobject.Tex

class Tex(*tex_strings, arg_separator='', tex_environment='center', **kwargs)[source]
Bases: MathTex

A string compiled with LaTeX in normal mode.

Tests

Check whether writing a LaTeX string works:

Tex('The horse does not eat cucumber salad.') 
Tex('The horse does not eat cucumber salad.')
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*tex_strings, arg_separator='', tex_environment='center', **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Title
Qualified name: manim.mobject.text.tex\_mobject.Title

class Title(*text_parts, include_underline=True, match_underline_width_to_text=False, underline_buff=0.25, **kwargs)[source]
Bases: Tex

A mobject representing an underlined title.

Examples

Example: TitleExample 

../_images/TitleExample-1.png
from manim import *

import manim

class TitleExample(Scene):
    def construct(self):
        banner = ManimBanner()
        title = Title(f"Manim version {manim.__version__}")
        self.add(banner, title)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

The font size of the tex mobject.

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(*text_parts, include_underline=True, match_underline_width_to_text=False, underline_buff=0.25, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

text_mobject
Mobjects used for displaying (non-LaTeX) text.

Note

Just as you can use Tex and MathTex (from the module tex_mobject) to insert LaTeX to your videos, you can use Text to to add normal text.

Important

See the corresponding tutorial Text Without LaTeX, especially for information about fonts.

The simplest way to add text to your animations is to use the Text class. It uses the Pango library to render text. With Pango, you are also able to render non-English alphabets like 你好 or こんにちは or 안녕하세요 or مرحبا بالعالم.

Examples

Example: HelloWorld 

../_images/HelloWorld-2.png
from manim import *

class HelloWorld(Scene):
    def construct(self):
        text = Text('Hello world').scale(3)
        self.add(text)
Make interactive
Example: TextAlignment 

../_images/TextAlignment-1.png
from manim import *

class TextAlignment(Scene):
    def construct(self):
        title = Text("K-means clustering and Logistic Regression", color=WHITE)
        title.scale(0.75)
        self.add(title.to_edge(UP))

        t1 = Text("1. Measuring").set_color(WHITE)

        t2 = Text("2. Clustering").set_color(WHITE)

        t3 = Text("3. Regression").set_color(WHITE)

        t4 = Text("4. Prediction").set_color(WHITE)

        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)
        x.set_opacity(0.5)
        x.submobjects[1].set_opacity(1)
        self.add(x)
Make interactive
Classes

MarkupText

Display (non-LaTeX) text rendered using Pango.

Paragraph

Display a paragraph of text.

Text

Display (non-LaTeX) text rendered using Pango.

Functions

register_font(font_file)[source]
Temporarily add a font file to Pango’s search path.

This searches for the font_file at various places. The order it searches it described below.

Absolute path.

In assets/fonts folder.

In font/ folder.

In the same directory.

Parameters:
font_file (str | Path) – The font file to add.

Examples

Use with register_font(...) to add a font file to search path.

with register_font("path/to/font_file.ttf"):
    a = Text("Hello", font="Custom Font Name")
Raises:
FileNotFoundError: – If the font doesn’t exists.

AttributeError: – If this method is used on macOS.

.. important :: – This method is available for macOS for ManimPango>=v0.2.3. Using this method with previous releases will raise an AttributeError on macOS.

Parameters:
font_file (str | Path)

remove_invisible_chars(mobject)[source]
Function to remove unwanted invisible characters from some mobjects.

Parameters:
mobject (SVGMobject) – Any SVGMobject from which we want to remove unwanted invisible characters.

Returns:
The SVGMobject without unwanted invisible characters.

Return type:
SVGMobject

MarkupText
Qualified name: manim.mobject.text.text\_mobject.MarkupText

class MarkupText(text, fill_opacity=1, stroke_width=0, color=None, font_size=48, line_spacing=-1, font='', slant='NORMAL', weight='NORMAL', justify=False, gradient=None, tab_width=4, height=None, width=None, should_center=True, disable_ligatures=False, warn_missing_font=True, **kwargs)[source]
Bases: SVGMobject

Display (non-LaTeX) text rendered using Pango.

Text objects behave like a VGroup-like iterable of all characters in the given text. In particular, slicing is possible.

What is PangoMarkup?

PangoMarkup is a small markup language like html and it helps you avoid using “range of characters” while coloring or styling a piece a Text. You can use this language with MarkupText.

A simple example of a marked-up string might be:

<span foreground="blue" size="x-large">Blue text</span> is <i>cool</i>!"
and it can be used with MarkupText as

Example: MarkupExample 

../_images/MarkupExample-1.png
from manim import *

class MarkupExample(Scene):
    def construct(self):
        text = MarkupText('<span foreground="blue" size="x-large">Blue text</span> is <i>cool</i>!"')
        self.add(text)
Make interactive
A more elaborate example would be:

Example: MarkupElaborateExample 

../_images/MarkupElaborateExample-1.png
from manim import *

class MarkupElaborateExample(Scene):
    def construct(self):
        text = MarkupText(
            '<span foreground="purple">ا</span><span foreground="red">َ</span>'
            'ل<span foreground="blue">ْ</span>ع<span foreground="red">َ</span>ر'
            '<span foreground="red">َ</span>ب<span foreground="red">ِ</span>ي'
            '<span foreground="green">ّ</span><span foreground="red">َ</span>ة'
            '<span foreground="blue">ُ</span>'
        )
        self.add(text)
Make interactive
PangoMarkup can also contain XML features such as numeric character entities such as &#169; for © can be used too.

The most general markup tag is <span>, then there are some convenience tags.

Here is a list of supported tags:

<b>bold</b>, <i>italic</i> and <b><i>bold+italic</i></b>

<ul>underline</ul> and <s>strike through</s>

<tt>typewriter font</tt>

<big>bigger font</big> and <small>smaller font</small>

<sup>superscript</sup> and <sub>subscript</sub>

<span underline="double" underline_color="green">double underline</span>

<span underline="error">error underline</span>

<span overline="single" overline_color="green">overline</span>

<span strikethrough="true" strikethrough_color="red">strikethrough</span>

<span font_family="sans">temporary change of font</span>

<span foreground="red">temporary change of color</span>

<span fgcolor="red">temporary change of color</span>

<gradient from="YELLOW" to="RED">temporary gradient</gradient>

For <span> markup, colors can be specified either as hex triples like #aabbcc or as named CSS colors like AliceBlue. The <gradient> tag is handled by Manim rather than Pango, and supports hex triplets or Manim constants like RED or RED_A. If you want to use Manim constants like RED_A together with <span>, you will need to use Python’s f-String syntax as follows:

MarkupText(f'<span foreground="{RED_A}">here you go</span>')
If your text contains ligatures, the MarkupText class may incorrectly determine the first and last letter when creating the gradient. This is due to the fact that fl are two separate characters, but might be set as one single glyph - a ligature. If your language does not depend on ligatures, consider setting disable_ligatures to True. If you must use ligatures, the gradient tag supports an optional attribute offset which can be used to compensate for that error.

For example:

<gradient from="RED" to="YELLOW" offset="1">example</gradient> to start the gradient one letter earlier

<gradient from="RED" to="YELLOW" offset=",1">example</gradient> to end the gradient one letter earlier

<gradient from="RED" to="YELLOW" offset="2,1">example</gradient> to start the gradient two letters earlier and end it one letter earlier

Specifying a second offset may be necessary if the text to be colored does itself contain ligatures. The same can happen when using HTML entities for special chars.

When using underline, overline or strikethrough together with <gradient> tags, you will also need to use the offset, because underlines are additional paths in the final SVGMobject. Check out the following example.

Escaping of special characters: > should be written as &gt; whereas < and & must be written as &lt; and &amp;.

You can find more information about Pango markup formatting at the corresponding documentation page: Pango Markup. Please be aware that not all features are supported by this class and that the <gradient> tag mentioned above is not supported by Pango.

Parameters:
text (str) – The text that needs to be created as mobject.

fill_opacity (float) – The fill opacity, with 1 meaning opaque and 0 meaning transparent.

stroke_width (float) – Stroke width.

font_size (float) – Font size.

line_spacing (int) – Line spacing.

font (str) – Global font setting for the entire text. Local overrides are possible.

slant (str) – Global slant setting, e.g. NORMAL or ITALIC. Local overrides are possible.

weight (str) – Global weight setting, e.g. NORMAL or BOLD. Local overrides are possible.

gradient (tuple) – Global gradient setting. Local overrides are possible.

warn_missing_font (bool) – If True (default), Manim will issue a warning if the font does not exist in the (case-sensitive) list of fonts returned from manimpango.list_fonts().

color (ParsableManimColor | None)

justify (bool)

tab_width (int)

height (int)

width (int)

should_center (bool)

disable_ligatures (bool)

Returns:
The text displayed in form of a VGroup-like mobject.

Return type:
MarkupText

Examples

Example: BasicMarkupExample 

../_images/BasicMarkupExample-1.png
from manim import *

class BasicMarkupExample(Scene):
    def construct(self):
        text1 = MarkupText("<b>foo</b> <i>bar</i> <b><i>foobar</i></b>")
        text2 = MarkupText("<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>")
        text3 = MarkupText("H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>")
        text4 = MarkupText("type <tt>help</tt> for help")
        text5 = MarkupText(
            '<span underline="double">foo</span> <span underline="error">bar</span>'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)
Make interactive
Example: ColorExample 

../_images/ColorExample-1.png
from manim import *

class ColorExample(Scene):
    def construct(self):
        text1 = MarkupText(
            f'all in red <span fgcolor="{YELLOW}">except this</span>', color=RED
        )
        text2 = MarkupText("nice gradient", gradient=(BLUE, GREEN))
        text3 = MarkupText(
            'nice <gradient from="RED" to="YELLOW">intermediate</gradient> gradient',
            gradient=(BLUE, GREEN),
        )
        text4 = MarkupText(
            'fl ligature <gradient from="RED" to="YELLOW">causing trouble</gradient> here'
        )
        text5 = MarkupText(
            'fl ligature <gradient from="RED" to="YELLOW" offset="1">defeated</gradient> with offset'
        )
        text6 = MarkupText(
            'fl ligature <gradient from="RED" to="YELLOW" offset="1">floating</gradient> inside'
        )
        text7 = MarkupText(
            'fl ligature <gradient from="RED" to="YELLOW" offset="1,1">floating</gradient> inside'
        )
        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)
        self.add(group)
Make interactive
Example: UnderlineExample 

../_images/UnderlineExample-1.png
from manim import *

class UnderlineExample(Scene):
    def construct(self):
        text1 = MarkupText(
            '<span underline="double" underline_color="green">bla</span>'
        )
        text2 = MarkupText(
            '<span underline="single" underline_color="green">xxx</span><gradient from="#ffff00" to="RED">aabb</gradient>y'
        )
        text3 = MarkupText(
            '<span underline="single" underline_color="green">xxx</span><gradient from="#ffff00" to="RED" offset="-1">aabb</gradient>y'
        )
        text4 = MarkupText(
            '<span underline="double" underline_color="green">xxx</span><gradient from="#ffff00" to="RED">aabb</gradient>y'
        )
        text5 = MarkupText(
            '<span underline="double" underline_color="green">xxx</span><gradient from="#ffff00" to="RED" offset="-2">aabb</gradient>y'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)
Make interactive
Example: FontExample 

../_images/FontExample-1.png
from manim import *

class FontExample(Scene):
    def construct(self):
        text1 = MarkupText(
            'all in sans <span font_family="serif">except this</span>', font="sans"
        )
        text2 = MarkupText(
            '<span font_family="serif">mixing</span> <span font_family="sans">fonts</span> <span font_family="monospace">is ugly</span>'
        )
        text3 = MarkupText("special char > or &gt;")
        text4 = MarkupText("special char &lt; and &amp;")
        group = VGroup(text1, text2, text3, text4).arrange(DOWN)
        self.add(group)
Make interactive
Example: NewlineExample 

../_images/NewlineExample-1.png
from manim import *

class NewlineExample(Scene):
    def construct(self):
        text = MarkupText('foooo<span foreground="red">oo\nbaa</span>aar')
        self.add(text)
Make interactive
Example: NoLigaturesExample 

../_images/NoLigaturesExample-1.png
from manim import *

class NoLigaturesExample(Scene):
    def construct(self):
        text1 = MarkupText('fl<gradient from="RED" to="GREEN">oat</gradient>ing')
        text2 = MarkupText('fl<gradient from="RED" to="GREEN">oat</gradient>ing', disable_ligatures=True)
        group = VGroup(text1, text2).arrange(DOWN)
        self.add(group)
Make interactive
As MarkupText uses Pango to render text, rendering non-English characters is easily possible:

Example: MultiLanguage 

../_images/MultiLanguage-1.png
from manim import *

class MultiLanguage(Scene):
    def construct(self):
        morning = MarkupText("வணக்கம்", font="sans-serif")
        japanese = MarkupText(
            '<span fgcolor="blue">日本</span>へようこそ'
        )  # works as in ``Text``.
        mess = MarkupText("Multi-Language", weight=BOLD)
        russ = MarkupText("Здравствуйте मस नम म ", font="sans-serif")
        hin = MarkupText("नमस्ते", font="sans-serif")
        chinese = MarkupText("臂猿「黛比」帶著孩子", font="sans-serif")
        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)
        self.add(group)
Make interactive
You can justify the text by passing justify parameter.

Example: JustifyText 

from manim import *

class JustifyText(Scene):
    def construct(self):
        ipsum_text = (
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
            "Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere "
            "quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam "
            "fermentum interdum justo, nec rutrum elit pretium ac. Nam quis "
            "leo pulvinar, dignissim est at, venenatis nisi."
        )
        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)
        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)
        just_title = Title("Justified")
        njust_title = Title("Not Justified")
        self.add(njust_title, not_justified_text)
        self.play(
            FadeOut(not_justified_text),
            FadeIn(justified_text),
            FadeOut(njust_title),
            FadeIn(just_title),
        )
        self.wait(1)
Make interactive
Tests

Check that the creation of MarkupText works:

MarkupText('The horse does not eat cucumber salad.')
MarkupText('The horse does not eat cucumber salad.')
Methods

font_list

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_count_real_chars(s)[source]
Counts characters that will be displayed.

This is needed for partial coloring or gradients, because space counts to the text’s len, but has no corresponding character.

_extract_color_tags()[source]
Used to determine which parts (if any) of the string should be formatted with a custom color.

Removes the <color> tag, as it is not part of Pango’s markup and would cause an error.

Note: Using the <color> tags is deprecated. As soon as the legacy syntax is gone, this function will be removed.

_extract_gradient_tags()[source]
Used to determine which parts (if any) of the string should be formatted with a gradient.

Removes the <gradient> tag, as it is not part of Pango’s markup and would cause an error.

_original__init__(text, fill_opacity=1, stroke_width=0, color=None, font_size=48, line_spacing=-1, font='', slant='NORMAL', weight='NORMAL', justify=False, gradient=None, tab_width=4, height=None, width=None, should_center=True, disable_ligatures=False, warn_missing_font=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
text (str)

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor | None)

font_size (float)

line_spacing (int)

font (str)

slant (str)

weight (str)

justify (bool)

gradient (tuple)

tab_width (int)

height (int)

width (int)

should_center (bool)

disable_ligatures (bool)

warn_missing_font (bool)

Return type:
None

_parse_color(col)[source]
Parse color given in <color> or <gradient> tags.

_text2hash(color)[source]
Generates sha256 hash for file name.

Parameters:
color (ParsableManimColor)

_text2svg(color)[source]
Convert the text to SVG using Pango.

Parameters:
color (ParsableManimColor | None)

Text
Qualified name: manim.mobject.text.text\_mobject.Text

class Text(text, fill_opacity=1.0, stroke_width=0, *, color=ManimColor('#FFFFFF'), font_size=48, line_spacing=-1, font='', slant='NORMAL', weight='NORMAL', t2c=None, t2f=None, t2g=None, t2s=None, t2w=None, gradient=None, tab_width=4, warn_missing_font=True, height=None, width=None, should_center=True, disable_ligatures=False, use_svg_cache=False, **kwargs)[source]
Bases: SVGMobject

Display (non-LaTeX) text rendered using Pango.

Text objects behave like a VGroup-like iterable of all characters in the given text. In particular, slicing is possible.

Parameters:
text (str) – The text that needs to be created as a mobject.

font (str) – The font family to be used to render the text. This is either a system font or one loaded with register_font(). Note that font family names may be different across operating systems.

warn_missing_font (bool) – If True (default), Manim will issue a warning if the font does not exist in the (case-sensitive) list of fonts returned from manimpango.list_fonts().

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor | None)

font_size (float)

line_spacing (float)

slant (str)

weight (str)

t2c (dict[str, str])

t2f (dict[str, str])

t2g (dict[str, tuple])

t2s (dict[str, str])

t2w (dict[str, str])

gradient (tuple)

tab_width (int)

height (float)

width (float)

should_center (bool)

disable_ligatures (bool)

use_svg_cache (bool)

Returns:
The mobject-like VGroup.

Return type:
Text

Examples

Example: Example1Text 

../_images/Example1Text-1.png
from manim import *

class Example1Text(Scene):
    def construct(self):
        text = Text('Hello world').scale(3)
        self.add(text)
Make interactive
Example: TextColorExample 

../_images/TextColorExample-1.png
from manim import *

class TextColorExample(Scene):
    def construct(self):
        text1 = Text('Hello world', color=BLUE).scale(3)
        text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)
        self.add(text1, text2)
Make interactive
Example: TextItalicAndBoldExample 

../_images/TextItalicAndBoldExample-1.png
from manim import *

class TextItalicAndBoldExample(Scene):
    def construct(self):
        text1 = Text("Hello world", slant=ITALIC)
        text2 = Text("Hello world", t2s={'world':ITALIC})
        text3 = Text("Hello world", weight=BOLD)
        text4 = Text("Hello world", t2w={'world':BOLD})
        text5 = Text("Hello world", t2c={'o':YELLOW}, disable_ligatures=True)
        text6 = Text(
            "Visit us at docs.manim.community",
            t2c={"docs.manim.community": YELLOW},
            disable_ligatures=True,
       )
        text6.scale(1.3).shift(DOWN)
        self.add(text1, text2, text3, text4, text5 , text6)
        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)
Make interactive
Example: TextMoreCustomization 

../_images/TextMoreCustomization-1.png
from manim import *

class TextMoreCustomization(Scene):
    def construct(self):
        text1 = Text(
            'Google',
            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',
                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',
                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)
        self.add(text1)
Make interactive
As Text uses Pango to render text, rendering non-English characters is easily possible:

Example: MultipleFonts 

../_images/MultipleFonts-1.png
from manim import *

class MultipleFonts(Scene):
    def construct(self):
        morning = Text("வணக்கம்", font="sans-serif")
        japanese = Text(
            "日本へようこそ", t2c={"日本": BLUE}
        )  # works same as ``Text``.
        mess = Text("Multi-Language", weight=BOLD)
        russ = Text("Здравствуйте मस नम म ", font="sans-serif")
        hin = Text("नमस्ते", font="sans-serif")
        arb = Text(
            "صباح الخير \n تشرفت بمقابلتك", font="sans-serif"
        )  # don't mix RTL and LTR languages nothing shows up then ;-)
        chinese = Text("臂猿「黛比」帶著孩子", font="sans-serif")
        self.add(morning, japanese, mess, russ, hin, arb, chinese)
        for i,mobj in enumerate(self.mobjects):
            mobj.shift(DOWN*(i-3))
Make interactive
Example: PangoRender 

from manim import *

class PangoRender(Scene):
    def construct(self):
        morning = Text("வணக்கம்", font="sans-serif")
        self.play(Write(morning))
        self.wait(2)
Make interactive
Tests

Check that the creation of Text works:

Text('The horse does not eat cucumber salad.')
Text('The horse does not eat cucumber salad.')
Methods

font_list

init_colors

Initializes the colors.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

font_size

hash_seed

A unique hash representing the result of the generated mobject points.

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_find_indexes(word, text)[source]
Finds the indexes of text in word.

Parameters:
word (str)

text (str)

_original__init__(text, fill_opacity=1.0, stroke_width=0, color=None, font_size=48, line_spacing=-1, font='', slant='NORMAL', weight='NORMAL', t2c=None, t2f=None, t2g=None, t2s=None, t2w=None, gradient=None, tab_width=4, warn_missing_font=True, height=None, width=None, should_center=True, disable_ligatures=False, use_svg_cache=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
text (str)

fill_opacity (float)

stroke_width (float)

color (ParsableManimColor | None)

font_size (float)

line_spacing (float)

font (str)

slant (str)

weight (str)

t2c (dict[str, str])

t2f (dict[str, str])

t2g (dict[str, tuple])

t2s (dict[str, str])

t2w (dict[str, str])

gradient (tuple)

tab_width (int)

warn_missing_font (bool)

height (float)

width (float)

should_center (bool)

disable_ligatures (bool)

use_svg_cache (bool)

Return type:
None

_set_color_by_t2c(t2c=None)[source]
Sets color for specified strings.

Attention

Deprecated The method Text._set_color_by_t2c has been deprecated since v0.14.0 and is expected to be removed after v0.15.0. This was internal function, you shouldn’t be using it anyway.

_set_color_by_t2g(t2g=None)[source]
Sets gradient colors for specified
strings. Behaves similarly to set_color_by_t2c.

Attention

Deprecated The method Text._set_color_by_t2g has been deprecated since v0.14.0 and is expected to be removed after v0.15.0. This was internal function, you shouldn’t be using it anyway.

_text2hash(color)[source]
Generates sha256 hash for file name.

Parameters:
color (ManimColor)

_text2settings(color)[source]
Converts the texts and styles to a setting for parsing.

Parameters:
color (str)

_text2svg(color)[source]
Convert the text to SVG using Pango.

Parameters:
color (ManimColor)

init_colors(propagate_colors=True)[source]
Initializes the colors.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

three_d
Three-dimensional mobjects.

Modules
polyhedra

General polyhedral class and platonic solids.

three_d_utils

Utility functions for three-dimensional mobjects.

three_dimensions

Three-dimensional mobjects.

